{
    "id": "root",
    "title": "Textbook",
    "content": null,
    "children": [
        {
            "id": "chapter-1",
            "title": "Propositional Logic",
            "content": null,
            "children": [
                {
                    "id": "chapter-1-section-1",
                    "title": "Declarative Sentences",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-2",
                    "title": "Natural Deduction",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-2-subsection-1",
                            "title": "Rules for Natural Deduction",
                            "content": "other prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\nφ ∨ψ\n∨i1\nψ\nφ ∨ψ\n∨i2\nφ ∨ψ\nφ\n...\nχ\nψ\n...\nχ\nχ\n∨e\n→\nφ\n...\nψ\nφ →ψ\n→i\nφ\nφ →ψ\nψ\n→e\n¬\nφ\n...\n⊥\n¬φ\n¬i\nφ\n¬φ\n⊥\n¬e\n⊥\n(no introduction rule for ⊥)\n⊥\nφ\n⊥e\n¬¬\n¬¬φ\nφ\n¬¬e\nSome useful derived rules:\nφ →ψ\n¬ψ\n¬φ\nMT\nφ\n¬¬φ\n¬¬i\n¬φ\n...\n⊥\nφ\nPBC\nφ ∨¬φ\nLEM\nFigure 1.2. Natural deduction rules for propositional logic.\n28\n1 Propositional logic\nAt any stage of a proof, it is permitted to introduce any formula as as-\nsumption, by choosing a proof rule that opens a box. As we saw, natural\ndeduction employs boxes to control the scope of assumptions. When an as-\nsumption is introduced, a box is opened. Discharging assumptions is achieved\nby closing a box according to the pattern of its particular proof rule. It’s\nuseful to make assumptions by opening boxes. But don’t forget you have to\nclose them in the manner prescribed by their proof rule.\nOK, but how do we actually go about constructing a proof?\nGiven a sequent, you write its premises at the top of your page and\nits conclusion at the bottom. Now, you’re trying to ﬁll in the gap,\nwhich involves working simultaneously on the premises (to bring them to-\nwards the conclusion) and on the conclusion (to massage it towards the\npremises).\nLook ﬁrst at the conclusion. If it is of the form φ →ψ, then apply6 the\nrule →i. This means drawing a box with φ at the top and ψ at the bottom.\nSo your proof, which started out like this:\n...\npremises\n...\nφ →ψ\nnow looks like this:\n...\npremises\n...\nφ\nassumption\nψ\nφ →ψ\n→i\nYou still have to ﬁnd a way of ﬁlling in the gap between the φ and the ψ.\nBut you now have an extra formula to work with and you have simpliﬁed\nthe conclusion you are trying to reach.\n6 Except in situations such as p →(q →¬r), p ⊢q →¬r where →e produces a simpler proof.\n1.2 Natural deduction\n29\n1\np →q\npremise\n2\n¬p ∨p\nLEM\n3\n¬p\nassumption\n4\n¬p ∨q\n∨i1 3\n5\np\nassumption\n6\nq\n→e 1, 5\n7\n¬p ∨q\n∨i2 6\n8\n¬p ∨q\n∨e 2, 3−4, 5−7\nIt can be diﬃcult to decide which instance of LEM would beneﬁt the progress\nof a proof. Can you re-do the example above with q ∨¬q as LEM?\n1.2.3 Natural deduction in summary\nThe proof rules for natural deduction are summarised in Figure 1.2. The\nexplanation of the rules we have given so far in this chapter is declarative;\nwe have presented each rule and justiﬁed it in terms of our intuition about\nthe logical connectives. However, when you try to use the rules yourself,\nyou’ll ﬁnd yourself looking for a more procedural interpretation; what does\na rule do and how do you use it? For example,\nr ∧i says: to prove φ ∧ψ, you must ﬁrst prove φ and ψ separately and then use\nthe rule ∧i.\nr ∧e1 says: to prove φ, try proving φ ∧ψ and then use the rule ∧e1. Actually,\nthis doesn’t sound like very good advice because probably proving φ ∧ψ will\nbe harder than proving φ alone. However, you might ﬁnd that you already have\nφ ∧ψ lying around, so that’s when this rule is useful. Compare this with the\nexample sequent in Example 1.15.\nr ∨i1 says: to prove φ ∨ψ, try proving φ. Again, in general it is harder to prove\nφ than it is to prove φ ∨ψ, so this will usually be useful only if you’ve already\nmanaged to prove φ. For example, if you want to prove q |−p ∨q, you certainly\nwon’t be able simply to use the rule ∨i1, but ∨i2 will work.\nr ∨e has an excellent procedural interpretation. It says: if you have φ ∨ψ, and you\nwant to prove some χ, then try to prove χ from φ and from ψ in turn. (In those\nsubproofs, of course you can use the other prevailing premises as well.)\nr Similarly, →i says, if you want to prove φ →ψ, try proving ψ from φ (and the\nother prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nrules for dealing with the quantiﬁers and with the equality symbol. Strictly\nspeaking, we are overloading the previously established proof rules for the\npropositional connectives ∧, ∨etc. That simply means that any proof rule\nof Chapter 1 is still valid for logical formulas of predicate logic (we origi-\nnally deﬁned those rules for logical formulas of propositional logic). As in\nthe natural deduction calculus for propositional logic, the additional rules\nfor the quantiﬁers and equality will come in two ﬂavours: introduction and\nelimination rules.\nThe proof rules for equality\nFirst, let us state the proof rules for\nequality. Here equality does not mean syntactic, or intensional, equality,\nbut equality in terms of computation results. In either of these senses, any\nterm t has to be equal to itself. This is expressed by the introduction rule\nfor equality:\nt = t\n=i\n(2.5)\nwhich is an axiom (as it does not depend on any premises). Notice that it\n108\n2 Predicate logic\nmay be invoked only if t is a term, our language doesn’t permit us to talk\nabout equality between formulas.\nThis rule is quite evidently sound, but it is not very useful on its own.\nWhat we need is a principle that allows us to substitute equals for equals\nrepeatedly. For example, suppose that y ∗(w + 2) equals y ∗w + y ∗2; then\nit certainly must be the case that z ≥y ∗(w + 2) implies z ≥y ∗w + y ∗2\nand vice versa. We may now express this substitution principle as the rule\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution\nthe summary of natural deduction rules in Figure 1.2 on page 27 to see which\ncases are still missing. Do you need to include derived rules?\n12. Show that the following sequents are not valid by ﬁnding a valuation in which\nthe truth values of the formulas to the left of ⊢are T and the truth value of\nthe formula to the right of ⊢is F.\n(a) ¬p ∨(q →p) ⊢¬p ∧q\n(b) ¬r →(p ∨q), r ∧¬q ⊢r →q\n(c)\n*\np →(q →r) ⊢p →(r →q)\n(d) ¬p, p ∨q ⊢¬q\n(e) p →(¬q ∨r), ¬r ⊢¬q →¬p.\n13. For each of the following invalid sequents, give examples of natural language\ndeclarative sentences for the atoms p, q and r such that the premises are true,\nbut the conclusion false.\n(a)\n*\np ∨q ⊢p ∧q\n(b)\n*\n¬p →¬q ⊢¬q →¬p\n(c) p →q ⊢p ∨q\n(d) p →(q ∨r) ⊢(p →q) ∧(p →r).\n14. Find a formula of propositional logic φ which contains only the atoms p, q\nand r and which is true only when p and q are false, or when ¬q ∧(p ∨r) is\ntrue.\n1.7 Exercises\n87\n15. Use mathematical induction on n to prove the theorem ((φ1 ∧(φ2 ∧(· · · ∧\nφn) . . . ) →ψ) →(φ1 →(φ2 →(. . . (φn →ψ) . . . )))).\n16. Prove the validity of the following sequents needed to secure the completeness\nresult for propositional logic:\n(a) φ1 ∧¬φ2 ⊢¬(φ1 →φ2)\n(b) ¬φ1 ∧¬φ2 ⊢φ1 →φ2\n(c) ¬φ1 ∧φ2 ⊢φ1 →φ2\n(d) φ1 ∧φ2 ⊢φ1 →φ2\n(e) ¬φ1 ∧φ2 ⊢¬(φ1 ∧φ2)\n(f) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(g) φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(h) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∨φ2)\n(i) φ1 ∧φ2 ⊢φ1 ∨φ2\n(j) ¬φ1 ∧φ2 ⊢φ1 ∨φ2\n(k) φ1 ∧¬φ2 ⊢φ1 ∨φ2.\n17. Does ⊨φ hold for the φ below? Please justify your answer.\n(a) (p →q) ∨(q →r)\n(b)\n*\n((q →(p ∨(q →p))) ∨¬(p →q)) →p.\nExercises 1.5\n1. Show that a formula φ is valid iﬀ⊤≡φ, where ⊤is an abbreviation for an\ninstance p ∨¬p of LEM.\n2. Which of these formulas are semantically equivalent to p →(q ∨r)?\n(a) q ∨(¬p ∨r)\n(b)\n*\nq ∧¬r →p\n(c) p ∧¬r →q\n(d)\n*\n¬q ∧¬r →¬p.\n3. An adequate set of connectives for propositional logic is a set such that for every\nformula of propositional logic there is an equivalent formula with only connectives\nfrom that set. For example, the set {¬, ∨} is adequate for propositional logic,\n1\np →(q →r)\npremise\n2\np\npremise\n3\n¬r\npremise\n4\nq\nassumption\n5\nq →r\n→e 1, 2\n6\nr\n→e 5, 4\n7\n⊥\n¬e 6, 3\n8\n¬q\n¬i 4−7\nExample 1.23 Finally, we return to the argument of Examples 1.1 and 1.2,\nwhich can be coded up by the sequent p ∧¬q →r, ¬r, p |−q whose validity\nwe now prove:\n1\np ∧¬q →r\npremise\n2\n¬r\npremise\n3\np\npremise\n4\n¬q\nassumption\n5\np ∧¬q\n∧i 3, 4\n6\nr\n→e 1, 5\n7\n⊥\n¬e 6, 2\n8\n¬¬q\n¬i 4−7\n9\nq\n¬¬e 8\n1.2.2 Derived rules\nWhen describing the proof rule modus tollens (MT), we mentioned that it\nis not a primitive rule of natural deduction, but can be derived from some\nof the other rules. Here is the derivation of\nφ →ψ\n¬ψ\n¬φ\nMT\n24\n1 Propositional logic\nfrom →e, ¬e and ¬i:\n1\nφ →ψ\npremise\n2\n¬ψ\npremise\n3\nφ\nassumption\n4\nψ\n→e 1, 3\n5\n⊥\n¬e 4, 2\n6\n¬φ\n¬i 3−5\nWe could now go back through the proofs in this chapter and replace applica-\ntions of MT by this combination of →e, ¬e and ¬i. However, it is convenient\nto think of MT as a shorthand (or a macro).\nThe same holds for the rule\nφ\n¬¬φ\n¬¬i.\nIt can be derived from the rules ¬i and ¬e, as follows:\n1\nφ\npremise\n2\n¬φ\nassumption\n3\n⊥\n¬e 1, 2\n4\n¬¬φ\n¬i 2−3\nThere are (unboundedly) many such derived rules which we could write\ndown. However, there is no point in making our calculus fat and unwieldy;\nand some purists would say that we should stick to a minimum set of rules,\nall of which are independent of each other. We don’t take such a purist view.\nIndeed, the two derived rules we now introduce are extremely useful. You will\nﬁnd that they crop up frequently when doing exercises in natural deduction,\nso it is worth giving them names as derived rules. In the case of the second\none, its derivation from the primitive proof rules is not very obvious.\nThe ﬁrst one has the Latin name reductio ad absurdum. It means ‘reduc-\ntion to absurdity’ and we will simply call it proof by contradiction (PBC\nfor short). The rule says: if from ¬φ we obtain a contradiction, then we are\nentitled to deduce φ:\n¬φ\n...\n⊥\nφ\nPBC.\n1.2 Natural deduction\n25",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-2",
                            "title": "Derived Rules",
                            "content": "the summary of natural deduction rules in Figure 1.2 on page 27 to see which\ncases are still missing. Do you need to include derived rules?\n12. Show that the following sequents are not valid by ﬁnding a valuation in which\nthe truth values of the formulas to the left of ⊢are T and the truth value of\nthe formula to the right of ⊢is F.\n(a) ¬p ∨(q →p) ⊢¬p ∧q\n(b) ¬r →(p ∨q), r ∧¬q ⊢r →q\n(c)\n*\np →(q →r) ⊢p →(r →q)\n(d) ¬p, p ∨q ⊢¬q\n(e) p →(¬q ∨r), ¬r ⊢¬q →¬p.\n13. For each of the following invalid sequents, give examples of natural language\ndeclarative sentences for the atoms p, q and r such that the premises are true,\nbut the conclusion false.\n(a)\n*\np ∨q ⊢p ∧q\n(b)\n*\n¬p →¬q ⊢¬q →¬p\n(c) p →q ⊢p ∨q\n(d) p →(q ∨r) ⊢(p →q) ∧(p →r).\n14. Find a formula of propositional logic φ which contains only the atoms p, q\nand r and which is true only when p and q are false, or when ¬q ∧(p ∨r) is\ntrue.\n1.7 Exercises\n87\n15. Use mathematical induction on n to prove the theorem ((φ1 ∧(φ2 ∧(· · · ∧\nφn) . . . ) →ψ) →(φ1 →(φ2 →(. . . (φn →ψ) . . . )))).\n16. Prove the validity of the following sequents needed to secure the completeness\nresult for propositional logic:\n(a) φ1 ∧¬φ2 ⊢¬(φ1 →φ2)\n(b) ¬φ1 ∧¬φ2 ⊢φ1 →φ2\n(c) ¬φ1 ∧φ2 ⊢φ1 →φ2\n(d) φ1 ∧φ2 ⊢φ1 →φ2\n(e) ¬φ1 ∧φ2 ⊢¬(φ1 ∧φ2)\n(f) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(g) φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(h) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∨φ2)\n(i) φ1 ∧φ2 ⊢φ1 ∨φ2\n(j) ¬φ1 ∧φ2 ⊢φ1 ∨φ2\n(k) φ1 ∧¬φ2 ⊢φ1 ∨φ2.\n17. Does ⊨φ hold for the φ below? Please justify your answer.\n(a) (p →q) ∨(q →r)\n(b)\n*\n((q →(p ∨(q →p))) ∨¬(p →q)) →p.\nExercises 1.5\n1. Show that a formula φ is valid iﬀ⊤≡φ, where ⊤is an abbreviation for an\ninstance p ∨¬p of LEM.\n2. Which of these formulas are semantically equivalent to p →(q ∨r)?\n(a) q ∨(¬p ∨r)\n(b)\n*\nq ∧¬r →p\n(c) p ∧¬r →q\n(d)\n*\n¬q ∧¬r →¬p.\n3. An adequate set of connectives for propositional logic is a set such that for every\nformula of propositional logic there is an equivalent formula with only connectives\nfrom that set. For example, the set {¬, ∨} is adequate for propositional logic,\n1\np →q\npremise\n2\n¬p ∨p\nLEM\n3\n¬p\nassumption\n4\n¬p ∨q\n∨i1 3\n5\np\nassumption\n6\nq\n→e 1, 5\n7\n¬p ∨q\n∨i2 6\n8\n¬p ∨q\n∨e 2, 3−4, 5−7\nIt can be diﬃcult to decide which instance of LEM would beneﬁt the progress\nof a proof. Can you re-do the example above with q ∨¬q as LEM?\n1.2.3 Natural deduction in summary\nThe proof rules for natural deduction are summarised in Figure 1.2. The\nexplanation of the rules we have given so far in this chapter is declarative;\nwe have presented each rule and justiﬁed it in terms of our intuition about\nthe logical connectives. However, when you try to use the rules yourself,\nyou’ll ﬁnd yourself looking for a more procedural interpretation; what does\na rule do and how do you use it? For example,\nr ∧i says: to prove φ ∧ψ, you must ﬁrst prove φ and ψ separately and then use\nthe rule ∧i.\nr ∧e1 says: to prove φ, try proving φ ∧ψ and then use the rule ∧e1. Actually,\nthis doesn’t sound like very good advice because probably proving φ ∧ψ will\nbe harder than proving φ alone. However, you might ﬁnd that you already have\nφ ∧ψ lying around, so that’s when this rule is useful. Compare this with the\nexample sequent in Example 1.15.\nr ∨i1 says: to prove φ ∨ψ, try proving φ. Again, in general it is harder to prove\nφ than it is to prove φ ∨ψ, so this will usually be useful only if you’ve already\nmanaged to prove φ. For example, if you want to prove q |−p ∨q, you certainly\nwon’t be able simply to use the rule ∨i1, but ∨i2 will work.\nr ∨e has an excellent procedural interpretation. It says: if you have φ ∨ψ, and you\nwant to prove some χ, then try to prove χ from φ and from ψ in turn. (In those\nsubproofs, of course you can use the other prevailing premises as well.)\nr Similarly, →i says, if you want to prove φ →ψ, try proving ψ from φ (and the\nother prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\n1\np →(q →r)\npremise\n2\np\npremise\n3\n¬r\npremise\n4\nq\nassumption\n5\nq →r\n→e 1, 2\n6\nr\n→e 5, 4\n7\n⊥\n¬e 6, 3\n8\n¬q\n¬i 4−7\nExample 1.23 Finally, we return to the argument of Examples 1.1 and 1.2,\nwhich can be coded up by the sequent p ∧¬q →r, ¬r, p |−q whose validity\nwe now prove:\n1\np ∧¬q →r\npremise\n2\n¬r\npremise\n3\np\npremise\n4\n¬q\nassumption\n5\np ∧¬q\n∧i 3, 4\n6\nr\n→e 1, 5\n7\n⊥\n¬e 6, 2\n8\n¬¬q\n¬i 4−7\n9\nq\n¬¬e 8\n1.2.2 Derived rules\nWhen describing the proof rule modus tollens (MT), we mentioned that it\nis not a primitive rule of natural deduction, but can be derived from some\nof the other rules. Here is the derivation of\nφ →ψ\n¬ψ\n¬φ\nMT\n24\n1 Propositional logic\nfrom →e, ¬e and ¬i:\n1\nφ →ψ\npremise\n2\n¬ψ\npremise\n3\nφ\nassumption\n4\nψ\n→e 1, 3\n5\n⊥\n¬e 4, 2\n6\n¬φ\n¬i 3−5\nWe could now go back through the proofs in this chapter and replace applica-\ntions of MT by this combination of →e, ¬e and ¬i. However, it is convenient\nto think of MT as a shorthand (or a macro).\nThe same holds for the rule\nφ\n¬¬φ\n¬¬i.\nIt can be derived from the rules ¬i and ¬e, as follows:\n1\nφ\npremise\n2\n¬φ\nassumption\n3\n⊥\n¬e 1, 2\n4\n¬¬φ\n¬i 2−3\nThere are (unboundedly) many such derived rules which we could write\ndown. However, there is no point in making our calculus fat and unwieldy;\nand some purists would say that we should stick to a minimum set of rules,\nall of which are independent of each other. We don’t take such a purist view.\nIndeed, the two derived rules we now introduce are extremely useful. You will\nﬁnd that they crop up frequently when doing exercises in natural deduction,\nso it is worth giving them names as derived rules. In the case of the second\none, its derivation from the primitive proof rules is not very obvious.\nThe ﬁrst one has the Latin name reductio ad absurdum. It means ‘reduc-\ntion to absurdity’ and we will simply call it proof by contradiction (PBC\nfor short). The rule says: if from ¬φ we obtain a contradiction, then we are\nentitled to deduce φ:\n¬φ\n...\n⊥\nφ\nPBC.\n1.2 Natural deduction\n25\n7. Explain why the four cases of the control structure for apply are exhaustive,\ni.e. there are no other possible cases in its execution.\n8. Consider the reduced OBDDs Bf and Bg in Figure 6.30. Recall that, in order\nto compute the reduced OBDD for f op g, you need to\n– construct the tree showing the recursive descent of apply (op, Bf, Bg) as\ndone in Figure 6.16;\n– use that tree to simulate apply (op, Bf, Bg); and\n– reduce, if necessary, the resulting OBDD.\nPerform these steps on the OBDDs of Figure 6.30 for the operation ‘op’ being\n(a) +\n(b) ⊕\n(c) ·\n9. Let Bf be the OBDD in Figure 6.11 (page 370). Compute apply (⊕, Bf, B1) and\nreduce the resulting OBDD. If you did everything correctly, then this OBDD\nshould be isomorphic to the one obtained from swapping 0- and 1-nodes in\nFigure 6.11.\n10.\n*\nConsider the OBDD Bc in Figure 6.31 which represents the ‘don’t care’ condi-\ntions for comparing the boolean functions f and g represented in Figure 6.30.\nThis means that we want to compare whether f and g are equal for all values\nof variables except those for which c is true (i.e. we ‘don’t care’ when c is true).\n(a) Show that the boolean formula (f ⊕g) + c is valid (always computes 1)\nif, and only if, f and g are equivalent on all values for which c evaluates\nto 0.\n404\n6 Binary decision diagrams\n0\n1\nz\ny\ny\nx\nFigure 6.31. The reduced OBDD Bc representing the ‘don’t care’ con-\nditions for the equivalence test of the OBDDs in Figure 6.30.\n(b) Proceed in three steps as in exercise 8 on page 403 to compute the reduced\nOBDD for (f ⊕g) + c from the OBDDs for f, g and c. Which call to apply\nneeds to be ﬁrst?\n11. We say that v ∈{0, 1} is a (left)-controlling value for the operation op, if either\nv op x = 1 or v op x = 0 for all values of x. We say that v is a controlling value\nif it is a left- and right-controlling value.\n(a) Deﬁne the notion of a right-controlling value.\n(b) Give examples of operations with controlling values.\npremise\n2\n∃x (P(x) ∧Q(x))\npremise\nx0\n3\nP(x0) ∧Q(x0)\nassumption\n4\nQ(x0) →R(x0)\n∀x e 1\n5\nQ(x0)\n∧e2 3\n6\nR(x0)\n→e 4, 5\n7\nP(x0)\n∧e1 3\n8\nP(x0) ∧R(x0)\n∧i 7, 6\n9\n∃x (P(x) ∧R(x))\n∃x i 8\n10\n∃x (P(x) ∧R(x))\n∃x e 2, 3−9\nNote the strategy of this proof: We list the two premises. The second premise\nis of use here only if we apply ∃x e to it. This sets up the proof box in\nlines 3−9 as well as the fresh parameter name x0. Since we want to prove\n∃x (P(x) ∧R(x)), this formula has to be the last one in the box (our goal)\nand the rest involves ∀x e and ∃x i.\nThe rules ∀i and ∃e both have the side condition that the dummy variable\ncannot occur outside the box in the rule. Of course, these rules may still be\nnested, by choosing another fresh name (e.g. y0) for the dummy variable. For\nexample, consider the sequent ∃x P(x), ∀x ∀y (P(x) →Q(y)) ⊢∀y Q(y).\n(Look how strong the second premise is, by the way: given any x, y, if P(x),\nthen Q(y). This means that, if there is any object with the property P, then\nall objects shall have the property Q.) Its proof goes as follows: We take an\narbitrary y0 and prove Q(y0); this we do by observing that, since some x\n116\n2 Predicate logic\nsatisﬁes P, so by the second premise any y satisﬁes Q:\n1\n∃x P(x)\npremise\n2\n∀x∀y (P(x) →Q(y))\npremise\ny0\n3\nx0\n4\nP(x0)\nassumption\n5\n∀y (P(x0) →Q(y))\n∀x e 2\n6\nP(x0) →Q(y0)\n∀y e 5\n7\nQ(y0)\n→e 6, 4\n8\nQ(y0)\n∃x e 1, 4−7\n9\n∀y Q(y)\n∀y i 3−8\nThere is no special reason for picking x0 as a name for the dummy variable\nwe use for ∀x and ∃x and y0 as a name for ∀y and ∃y. We do this only\nbecause it makes it easier for us humans. Again, study the strategy of this\nproof. We ultimately have to show a ∀y formula which requires us to use\n∀y i, i.e. we need to open up a proof box (lines 3−8) whose subgoal is to\nprove a generic instance Q(y0). Within that box we want to make use of the\npremise ∃x P(x) which results in the proof box set-up of lines 4−7. Notice\nthat, in line 8, we may well move Q(y0) out of the box controlled by x0.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-3",
                            "title": "Natural Deduction in Summary",
                            "content": "other prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\nφ ∨ψ\n∨i1\nψ\nφ ∨ψ\n∨i2\nφ ∨ψ\nφ\n...\nχ\nψ\n...\nχ\nχ\n∨e\n→\nφ\n...\nψ\nφ →ψ\n→i\nφ\nφ →ψ\nψ\n→e\n¬\nφ\n...\n⊥\n¬φ\n¬i\nφ\n¬φ\n⊥\n¬e\n⊥\n(no introduction rule for ⊥)\n⊥\nφ\n⊥e\n¬¬\n¬¬φ\nφ\n¬¬e\nSome useful derived rules:\nφ →ψ\n¬ψ\n¬φ\nMT\nφ\n¬¬φ\n¬¬i\n¬φ\n...\n⊥\nφ\nPBC\nφ ∨¬φ\nLEM\nFigure 1.2. Natural deduction rules for propositional logic.\n28\n1 Propositional logic\nAt any stage of a proof, it is permitted to introduce any formula as as-\nsumption, by choosing a proof rule that opens a box. As we saw, natural\ndeduction employs boxes to control the scope of assumptions. When an as-\nsumption is introduced, a box is opened. Discharging assumptions is achieved\nby closing a box according to the pattern of its particular proof rule. It’s\nuseful to make assumptions by opening boxes. But don’t forget you have to\nclose them in the manner prescribed by their proof rule.\nOK, but how do we actually go about constructing a proof?\nGiven a sequent, you write its premises at the top of your page and\nits conclusion at the bottom. Now, you’re trying to ﬁll in the gap,\nwhich involves working simultaneously on the premises (to bring them to-\nwards the conclusion) and on the conclusion (to massage it towards the\npremises).\nLook ﬁrst at the conclusion. If it is of the form φ →ψ, then apply6 the\nrule →i. This means drawing a box with φ at the top and ψ at the bottom.\nSo your proof, which started out like this:\n...\npremises\n...\nφ →ψ\nnow looks like this:\n...\npremises\n...\nφ\nassumption\nψ\nφ →ψ\n→i\nYou still have to ﬁnd a way of ﬁlling in the gap between the φ and the ψ.\nBut you now have an extra formula to work with and you have simpliﬁed\nthe conclusion you are trying to reach.\n6 Except in situations such as p →(q →¬r), p ⊢q →¬r where →e produces a simpler proof.\n1.2 Natural deduction\n29\nthe summary of natural deduction rules in Figure 1.2 on page 27 to see which\ncases are still missing. Do you need to include derived rules?\n12. Show that the following sequents are not valid by ﬁnding a valuation in which\nthe truth values of the formulas to the left of ⊢are T and the truth value of\nthe formula to the right of ⊢is F.\n(a) ¬p ∨(q →p) ⊢¬p ∧q\n(b) ¬r →(p ∨q), r ∧¬q ⊢r →q\n(c)\n*\np →(q →r) ⊢p →(r →q)\n(d) ¬p, p ∨q ⊢¬q\n(e) p →(¬q ∨r), ¬r ⊢¬q →¬p.\n13. For each of the following invalid sequents, give examples of natural language\ndeclarative sentences for the atoms p, q and r such that the premises are true,\nbut the conclusion false.\n(a)\n*\np ∨q ⊢p ∧q\n(b)\n*\n¬p →¬q ⊢¬q →¬p\n(c) p →q ⊢p ∨q\n(d) p →(q ∨r) ⊢(p →q) ∧(p →r).\n14. Find a formula of propositional logic φ which contains only the atoms p, q\nand r and which is true only when p and q are false, or when ¬q ∧(p ∨r) is\ntrue.\n1.7 Exercises\n87\n15. Use mathematical induction on n to prove the theorem ((φ1 ∧(φ2 ∧(· · · ∧\nφn) . . . ) →ψ) →(φ1 →(φ2 →(. . . (φn →ψ) . . . )))).\n16. Prove the validity of the following sequents needed to secure the completeness\nresult for propositional logic:\n(a) φ1 ∧¬φ2 ⊢¬(φ1 →φ2)\n(b) ¬φ1 ∧¬φ2 ⊢φ1 →φ2\n(c) ¬φ1 ∧φ2 ⊢φ1 →φ2\n(d) φ1 ∧φ2 ⊢φ1 →φ2\n(e) ¬φ1 ∧φ2 ⊢¬(φ1 ∧φ2)\n(f) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(g) φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(h) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∨φ2)\n(i) φ1 ∧φ2 ⊢φ1 ∨φ2\n(j) ¬φ1 ∧φ2 ⊢φ1 ∨φ2\n(k) φ1 ∧¬φ2 ⊢φ1 ∨φ2.\n17. Does ⊨φ hold for the φ below? Please justify your answer.\n(a) (p →q) ∨(q →r)\n(b)\n*\n((q →(p ∨(q →p))) ∨¬(p →q)) →p.\nExercises 1.5\n1. Show that a formula φ is valid iﬀ⊤≡φ, where ⊤is an abbreviation for an\ninstance p ∨¬p of LEM.\n2. Which of these formulas are semantically equivalent to p →(q ∨r)?\n(a) q ∨(¬p ∨r)\n(b)\n*\nq ∧¬r →p\n(c) p ∧¬r →q\n(d)\n*\n¬q ∧¬r →¬p.\n3. An adequate set of connectives for propositional logic is a set such that for every\nformula of propositional logic there is an equivalent formula with only connectives\nfrom that set. For example, the set {¬, ∨} is adequate for propositional logic,\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nrules for dealing with the quantiﬁers and with the equality symbol. Strictly\nspeaking, we are overloading the previously established proof rules for the\npropositional connectives ∧, ∨etc. That simply means that any proof rule\nof Chapter 1 is still valid for logical formulas of predicate logic (we origi-\nnally deﬁned those rules for logical formulas of propositional logic). As in\nthe natural deduction calculus for propositional logic, the additional rules\nfor the quantiﬁers and equality will come in two ﬂavours: introduction and\nelimination rules.\nThe proof rules for equality\nFirst, let us state the proof rules for\nequality. Here equality does not mean syntactic, or intensional, equality,\nbut equality in terms of computation results. In either of these senses, any\nterm t has to be equal to itself. This is expressed by the introduction rule\nfor equality:\nt = t\n=i\n(2.5)\nwhich is an axiom (as it does not depend on any premises). Notice that it\n108\n2 Predicate logic\nmay be invoked only if t is a term, our language doesn’t permit us to talk\nabout equality between formulas.\nThis rule is quite evidently sound, but it is not very useful on its own.\nWhat we need is a principle that allows us to substitute equals for equals\nrepeatedly. For example, suppose that y ∗(w + 2) equals y ∗w + y ∗2; then\nit certainly must be the case that z ≥y ∗(w + 2) implies z ≥y ∗w + y ∗2\nand vice versa. We may now express this substitution principle as the rule\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution\n1\np →q\npremise\n2\n¬p ∨p\nLEM\n3\n¬p\nassumption\n4\n¬p ∨q\n∨i1 3\n5\np\nassumption\n6\nq\n→e 1, 5\n7\n¬p ∨q\n∨i2 6\n8\n¬p ∨q\n∨e 2, 3−4, 5−7\nIt can be diﬃcult to decide which instance of LEM would beneﬁt the progress\nof a proof. Can you re-do the example above with q ∨¬q as LEM?\n1.2.3 Natural deduction in summary\nThe proof rules for natural deduction are summarised in Figure 1.2. The\nexplanation of the rules we have given so far in this chapter is declarative;\nwe have presented each rule and justiﬁed it in terms of our intuition about\nthe logical connectives. However, when you try to use the rules yourself,\nyou’ll ﬁnd yourself looking for a more procedural interpretation; what does\na rule do and how do you use it? For example,\nr ∧i says: to prove φ ∧ψ, you must ﬁrst prove φ and ψ separately and then use\nthe rule ∧i.\nr ∧e1 says: to prove φ, try proving φ ∧ψ and then use the rule ∧e1. Actually,\nthis doesn’t sound like very good advice because probably proving φ ∧ψ will\nbe harder than proving φ alone. However, you might ﬁnd that you already have\nφ ∧ψ lying around, so that’s when this rule is useful. Compare this with the\nexample sequent in Example 1.15.\nr ∨i1 says: to prove φ ∨ψ, try proving φ. Again, in general it is harder to prove\nφ than it is to prove φ ∨ψ, so this will usually be useful only if you’ve already\nmanaged to prove φ. For example, if you want to prove q |−p ∨q, you certainly\nwon’t be able simply to use the rule ∨i1, but ∨i2 will work.\nr ∨e has an excellent procedural interpretation. It says: if you have φ ∨ψ, and you\nwant to prove some χ, then try to prove χ from φ and from ψ in turn. (In those\nsubproofs, of course you can use the other prevailing premises as well.)\nr Similarly, →i says, if you want to prove φ →ψ, try proving ψ from φ (and the\nother prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\nthe truth-table semantics. In the exercises, we apply this to show that a se-\nquent does not have a proof: simply show that φ1, φ2, . . . , φ2 does not seman-\ntically entail ψ; then soundness implies that the sequent φ1, φ2, . . . , φ2 ⊢ψ\ndoes not have a proof. Completeness comprised a much more powerful state-\nment: no matter what (semantically) valid sequents there are, they all have\nsyntactic proofs in the proof system of natural deduction. This tight cor-\nrespondence allows us to freely switch between working with the notion of\nproofs (⊢) and that of semantic entailment (⊨).\nUsing natural deduction to decide the validity of instances of ⊢is only\none of many possibilities. In Exercise 1.2.6 we sketch a non-linear, tree-like,\nnotion of proofs for sequents. Likewise, checking an instance of ⊨by apply-\ning Deﬁnition 1.34 literally is only one of many ways of deciding whether\nφ1, φ2, . . . , φn ⊨ψ holds. We now investigate various alternatives for deciding\nφ1, φ2, . . . , φn ⊨ψ which are based on transforming these formulas syntac-\ntically into ‘equivalent’ ones upon which we can then settle the matter by\npurely syntactic or algorithmic means. This requires that we ﬁrst clarify\nwhat exactly we mean by equivalent formulas.\n1.5.1 Semantic equivalence, satisfiability and validity\nTwo formulas φ and ψ are said to be equivalent if they have the same\n‘meaning.’ This suggestion is vague and needs to be reﬁned. For example,\np →q and ¬p ∨q have the same truth table; all four combinations of T and F\nfor p and q return the same result. ’Coincidence of truth tables’ is not good\nenough for what we have in mind, for what about the formulas p ∧q →p\nand r ∨¬r? At ﬁrst glance, they have little in common, having diﬀerent\natomic formulas and diﬀerent connectives. Moreover, the truth table for\np ∧q →p is four lines long, whereas the one for r ∨¬r consists of only two\nlines. However, both formulas are always true. This suggests that we deﬁne",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-4",
                            "title": "Provable Equivalence",
                            "content": "and r ∨¬r? At ﬁrst glance, they have little in common, having diﬀerent\natomic formulas and diﬀerent connectives. Moreover, the truth table for\np ∧q →p is four lines long, whereas the one for r ∨¬r consists of only two\nlines. However, both formulas are always true. This suggests that we deﬁne\nthe equivalence of formulas φ and ψ via ⊨: if φ semantically entails ψ and\nvice versa, then these formulas should be the same as far as our truth-table\nsemantics is concerned.\nDeﬁnition 1.40 Let φ and ψ be formulas of propositional logic. We say\nthat φ and ψ are semantically equivalent iﬀφ ⊨ψ and ψ ⊨φ hold. In that\ncase we write φ ≡ψ. Further, we call φ valid if ⊨φ holds.\nNote that we could also have deﬁned φ ≡ψ to mean that ⊨(φ →ψ) ∧\n(ψ →φ) holds; it amounts to the same concept. Indeed, because of soundness\nand completeness, semantic equivalence is identical to provable equivalence\n1.5 Normal forms\n55\n(Deﬁnition 1.25). Examples of equivalent formulas are\np →q ≡¬q →¬p\np →q ≡¬p ∨q\np ∧q →p ≡r ∨¬r\np ∧q →r ≡p →(q →r).\nRecall that a formula η is called a tautology if ⊨η holds, so the tautologies\nare exactly the valid formulas. The following lemma says that any decision\nprocedure for tautologies is in fact a decision procedure for the validity of\nsequents as well.\nLemma 1.41 Given formulas φ1, φ2, . . . , φn and ψ of propositional logic,\nφ1, φ2, . . . , φn ⊨ψ holds iﬀ⊨φ1 →(φ2 →(φ3 →· · · →(φn →ψ))) holds.\nProof: First, suppose that ⊨φ1 →(φ2 →(φ3 →· · · →(φn →ψ))) holds.\nIf φ1, φ2, . . . , φn are all true under some valuation, then ψ has to be true\nas well for that same valuation. Otherwise,\n⊨φ1 →(φ2 →(φ3 →· · · →\n(φn →ψ))) would not hold (compare this with Figure 1.11). Second, if\nφ1, φ2, . . . , φn ⊨ψ holds, we have already shown that ⊨φ1 →(φ2 →(φ3 →\n· · · →(φn →ψ))) follows in step 1 of our completeness proof.\n2\nFor our current purposes, we want to transform formulas into ones which\ndon’t contain →at all and the occurrences of ∧and ∨are conﬁned to\nan interpretation function =M to be actual equality on the set A of M.\nThus, (a, b) is in the set =M iﬀa and b are the same elements in the set A.\nFor example, given A\ndef\n= {a, b, c}, the interpretation =M of equality is forced\nto be {(a, a), (b, b), (c, c)}. Hence the semantics of equality is easy, for it is\nalways modelled extensionally.\n2.5 Undecidability of predicate logic\nWe continue our introduction to predicate logic with some negative results.\nGiven a formula φ in propositional logic we can, at least in principle, de-\ntermine whether ⊨φ holds: if φ has n propositional atoms, then the truth\ntable of φ contains 2n lines; and ⊨φ holds if, and only if, the column for φ\n(of length 2n) contains only T entries.\nThe bad news is that such a mechanical procedure, working for all for-\nmulas φ, cannot be provided in predicate logic. We will give a formal proof\nof this negative result, though we rely on an informal (yet intuitive) notion\nof computability.\nThe problem of determining whether a predicate logic formula is valid is\nknown as a decision problem. A solution to a decision problem is a program\n(written in Java, C, or any other common language) that takes problem\ninstances as input and always terminates, producing a correct ‘yes’ or ‘no’\noutput. In the case of the decision problem for predicate logic, the input to\nthe program is an arbitrary formula φ of predicate logic and the program\n132\n2 Predicate logic\nis correct if it produces ‘yes’ whenever the input formula is valid and ‘no’\nwhenever it is not. Note that the program which solves a decision problem\nmust terminate for all well-formed input: a program which goes on thinking\nabout it for ever is not allowed. The decision problem at hand is this:\nValidity in predicate logic.\nGiven a logical formula φ in predicate logic, does\n⊨φ hold, yes or no?\nWe now show that this problem is not solvable; we cannot write a correct\nC or Java program that works for all φ. It is important to be clear about\nthat R(y, z), or y equals z, or R(z, y);\nr total: if for every x, y ∈W we have R(x, y) or R(y, x); and\nr an equivalence relation: if it is reﬂexive, symmetric and transitive.\nNow, let us consider this question: according to the various readings of\nR, which of these properties do we expect R to have?\nExample 5.9 If 2φ means ‘agent Q knows φ,’ then R(x, y) means y could\nbe the actual world according to Q’s knowledge at x.\nr Should R be reﬂexive? This would say: x could be the actual world according\nto Q’s knowledge at x. In other words, Q cannot know that things are diﬀerent\nfrom how they really are – i.e., Q cannot have false knowledge. This is a desirable\nproperty for R to have. Moreover, it seems to rest on the same intuition – i.e. the\nimpossibility of false knowledge – as the validity of the formula 2φ →φ. Indeed,\nthe validity of this formula and the property of reﬂexivity are closely related, as\nwe see later on.\nr Should R be transitive? It would say: if y is possible according to Q’s knowledge\nat x and z is possible according to her knowledge at y, then z is possible according\nto her knowledge at x.\nWell, this seems to be true. For suppose it was not true, i.e. at x she knew\nsomething preventing z from being the real world. Then, she would know she\nknew this thing at x; therefore, she would know something at y which prevented\nz from being the real world; which contradicts our premise.\n322\n5 Modal logics and agents\nIn this argument, we relied on positive introspection, i.e. the formula 2φ →22φ.\nAgain, we will shortly see that there is a close correspondence between R being\ntransitive and the validity of this formula.\n5.3.3 Correspondence theory\nWe saw in the preceding section that there appeared to be a correspondence\nbetween the validity of 2φ →φ and the property that the accessibility re-\nlation R is reﬂexive. The connection between them is that both relied on\nthe intuition that anything which is known by an agent is true. Moreover,\nterms of the Ki and CG is deﬁned in terms of EG.\nMany of the results we had for basic modal logic with a single accessi-\nbility relation also hold in this more general setting of several accessibility\nrelations. Summarising,\nr a frame F for KT45n (W, (Ri)i∈A) for the modal logic KT45n is a set W of\nworlds and, for each i ∈A, an equivalence relation Ri on W.\nr a frame F = (W, (Ri)i∈A) for KT45n is said to satisfy φ if, for each labelling\nfunction L: W →P(Atoms) and each w ∈W, we have M, w ⊩φ holds, where\nM = (W, (Ri)i∈A, L). In that case, we say that F ⊨φ holds.\nThe following theorem is useful for answering questions about formu-\nlas involving E and C. Let M = (W, (Ri)i∈A, L) be a model for KT45n\n338\n5 Modal logics and agents\nand x, y ∈W. We say that y is G-reachable in k steps from x if there are\nw1, w2, . . . , wk−1 ∈W and i1, i2, . . . , ik in G such that\nx Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y\nmeaning Ri1(x, w1), Ri2(w1, w2), . . . , Rik(wk, y). We also say that y is G-\nreachable from x if there is some k such that it is G-reachable in k steps.\nTheorem 5.26\n1.\nx ⊩Ek\nGφ iﬀ, for all y that are G-reachable from x in k steps, we have y ⊩φ.\n2.\nx ⊩CG φ iﬀ, for all y that are G-reachable from x, we have y ⊩φ.\nPROOF:\n1.\nFirst, suppose y ⊩φ for all y G-reachable from x in k steps. We will prove\nthat x ⊩Ek\nGφ holds. It is suﬃcient to show that x ⊩Ki1Ki2 . . . Kik φ for any\ni1, i2, . . . , ik ∈G. Take any i1, i2, . . . , ik ∈G and any w1, w2,. . . , wk−1 and y\nsuch that there is a path of the form x Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y. Since\ny is G-reachable from x in k steps, we have y ⊩φ by our assumption, so x ⊩\nKi1Ki2 . . . Kik φ as required.\nConversely, suppose x ⊩Ek\nGφ holds and y is G-reachable from x in k steps. We\nmust show that y ⊩φ holds. Take i1, i2, . . . , ik by G-reachability; since x ⊩Ek\nGφ\nimplies x ⊩Ki1Ki2 . . . Kik φ, we have y ⊩φ.\n2.\nThis argument is similar.\nSome valid formulas in KT45n\nThe formula K holds for the connec-\nbut at least one world does not satisfy ¬q ∨p; the scheme ¬φ ∨ψ is not\nsatisﬁed.\nEquivalences between modal formulas\nDeﬁnition 5.7 1.\nWe say that a set of formulas Γ of basic modal logic seman-\ntically entails a formula ψ of basic modal logic if, in any world x of any model\nM = (W, R, L), we have x ⊩ψ whenever x ⊩φ for all φ ∈Γ. In that case, we\nsay that Γ ⊨ψ holds.\n2.\nWe say that φ and ψ are semantically equivalent if φ ⊨ψ and ψ ⊨φ hold. We\ndenote this by φ ≡ψ.\nNote that φ ≡ψ holds iﬀany world in any model which satisﬁes one\nof them also satisﬁes the other. The deﬁnition of semantic equivalence is\nbased on semantic entailment in the same way as the corresponding one for\nformulas of propositional logic. However, the underlying notion of semantic\nentailment for modal logic is quite diﬀerent, as we will see shortly.\nAny equivalence in propositional logic is also an equivalence in modal\nlogic. Indeed, if we take any equivalence in propositional logic and substi-\ntute the atoms uniformly for any modal logic formula, the result is also\nan equivalence in modal logic. For example, take the equivalent formulas\np →¬q and ¬(p ∧q) and now perform the substitution\np\n\u000e→\n2p ∧(q →p)\nq\n\u000e→\nr →3(q ∨p).\nThe result of this substitution is the pair of formulas\n2p ∧(q →p) →¬(r →3(q ∨p))\n(5.2)\n¬((2p ∧(q →p)) ∧(r →3(q ∨p)))\nwhich are equivalent as formulas of basic modal logic.\nWe have already noticed that 2 is a universal quantiﬁer on accessible\nworlds and 3 is the corresponding existential quantiﬁer. In view of these\nfacts, it is not surprising to ﬁnd that de Morgan rules apply for 2 and 3:\n¬2φ ≡3¬φ and ¬3φ ≡2¬φ.\n314\n5 Modal logics and agents\nMoreover, 2 distributes over ∧and 3 distributes over ∨:\n2(φ ∧ψ) ≡2φ ∧2ψ and 3(φ ∨ψ) ≡3φ ∨3ψ.\nThese equivalences correspond closely to the quantiﬁer equivalences dis-\ncussed in Section 2.3.2. It is also not surprising to ﬁnd that 2 does not\ndistribute over ∨and 3 does not distribute over ∧, i.e. we do not have equiv-",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-5",
                            "title": "Proof by Contradiction",
                            "content": "more than once.\nThe rules for negation\nWe have seen the rules ¬¬i and ¬¬e, but we\nhaven’t seen any rules that introduce or eliminate single negations. These\nrules involve the notion of contradiction. This detour is to be expected since\nour reasoning is concerned about the inference, and therefore the preserva-\ntion, of truth. Hence, there cannot be a direct way of inferring ¬φ, given\nφ.\nDeﬁnition 1.19 Contradictions are expressions of the form φ ∧¬φ or ¬φ ∧\nφ, where φ is any formula.\nExamples of such contradictions are r ∧¬r, (p →q) ∧¬(p →q) and ¬(r ∨\ns →q) ∧(r ∨s →q). Contradictions are a very important notion in logic.\nAs far as truth is concerned, they are all equivalent; that means we should\nbe able to prove the validity of\n¬(r ∨s →q) ∧(r ∨s →q) ⊣⊢(p →q) ∧¬(p →q)\n(1.2)\nsince both sides are contradictions. We’ll be able to prove this later, when\nwe have introduced the rules for negation.\nIndeed, it’s not just that contradictions can be derived from contradic-\ntions; actually, any formula can be derived from a contradiction. This can be\n1.2 Natural deduction\n21\nconfusing when you ﬁrst encounter it; why should we endorse the argument\np ∧¬p ⊢q, where\np : The moon is made of green cheese.\nq : I like pepperoni on my pizza.\nconsidering that our taste in pizza doesn’t have anything to do with the\nconstitution of the moon? On the face of it, such an endorsement may seem\nabsurd. Nevertheless, natural deduction does have this feature that any for-\nmula can be derived from a contradiction and therefore it makes this argu-\nment valid. The reason it takes this stance is that ⊢tells us all the things\nwe may infer, provided that we can assume the formulas to the left of it.\nThis process does not care whether such premises make any sense. This has\nat least the advantage that we can match ⊢to checks based on semantic\nintuitions which we formalise later by using truth tables: if all the premises\ncompute to ‘true’, then the conclusion must compute ‘true’ as well. In partic-\nThe ﬁrst one has the Latin name reductio ad absurdum. It means ‘reduc-\ntion to absurdity’ and we will simply call it proof by contradiction (PBC\nfor short). The rule says: if from ¬φ we obtain a contradiction, then we are\nentitled to deduce φ:\n¬φ\n...\n⊥\nφ\nPBC.\n1.2 Natural deduction\n25\nThis rule looks rather similar to ¬i, except that the negation is in a diﬀerent\nplace. This is the clue to how to derive PBC from our basic proof rules.\nSuppose we have a proof of ⊥from ¬φ. By →i, we can transform this into\na proof of ¬φ →⊥and proceed as follows:\n1\n¬φ →⊥\ngiven\n2\n¬φ\nassumption\n3\n⊥\n→e 1, 2\n4\n¬¬φ\n¬i 2−3\n5\nφ\n¬¬e 4\nThis shows that PBC can be derived from →i, ¬i, →e and ¬¬e.\nThe ﬁnal derived rule we consider in this section is arguably the most\nuseful to use in proofs, because its derivation is rather long and complicated,\nso its usage often saves time and eﬀort. It also has a Latin name, tertium\nnon datur; the English name is the law of the excluded middle, or LEM for\nshort. It simply says that φ ∨¬φ is true: whatever φ is, it must be either true\nor false; in the latter case, ¬φ is true. There is no third possibility (hence\nexcluded middle): the sequent ⊢φ ∨¬φ is valid. Its validity is implicit, for\nexample, whenever you write an if-statement in a programming language:\n‘if B {C1} else {C2}’ relies on the fact that B ∨¬B is always true (and\nthat B and ¬B can never be true at the same time). Here is a proof in\nnatural deduction that derives the law of the excluded middle from basic\nproof rules:\n1\n¬(φ ∨¬φ)\nassumption\n2\nφ\nassumption\n3\nφ ∨¬φ\n∨i1 2\n4\n⊥\n¬e 3, 1\n5\n¬φ\n¬i 2−4\n6\nφ ∨¬φ\n∨i2 5\n7\n⊥\n¬e 6, 1\n8\n¬¬(φ ∨¬φ)\n¬i 1−7\n9\nφ ∨¬φ\n¬¬e 8\n26\n1 Propositional logic\nExample 1.24 Using LEM, we show that p →q ⊢¬p ∨q is valid:\n1\np →q\npremise\n2\n¬p ∨p\nLEM\n3\n¬p\nassumption\n4\n¬p ∨q\n∨i1 3\n5\np\nassumption\n6\nq\n→e 1, 5\n7\n¬p ∨q\n∨i2 6\n8\n¬p ∨q\n∨e 2, 3−4, 5−7\nIt can be diﬃcult to decide which instance of LEM would beneﬁt the progress\nof a proof. Can you re-do the example above with q ∨¬q as LEM?\nIf a sequent is valid, there may be many diﬀerent ways of proving it. So if\nyou compare your solution to these exercises with those of others, they need\nnot coincide. The important thing to realise, though, is that any putative\nproof can be checked for correctness by checking each individual line, starting\nat the top, for the valid application of its proof rule.\n8\n1 Propositional logic\nThe rules of double negation\nIntuitively, there is no diﬀerence be-\ntween a formula φ and its double negation ¬¬φ, which expresses no more\nand nothing less than φ itself. The sentence\n‘It is not true that it does not rain.’\nis just a more contrived way of saying\n‘It rains.’\nConversely, knowing ‘It rains,’ we are free to state this fact in this more\ncomplicated manner if we wish. Thus, we obtain rules of elimination and\nintroduction for double negation:\n¬¬φ\nφ\n¬¬e\nφ\n¬¬φ\n¬¬i.\n(There are rules for single negation on its own, too, which we will see later.)\nExample 1.5 The proof of the sequent p, ¬¬(q ∧r) ⊢¬¬p ∧r below uses\nmost of the proof rules discussed so far:\n1\np\npremise\n2\n¬¬(q ∧r)\npremise\n3\n¬¬p\n¬¬i 1\n4\nq ∧r\n¬¬e 2\n5\nr\n∧e2 4\n6\n¬¬p ∧r\n∧i 3, 5\nExample 1.6 We now prove the sequent (p ∧q) ∧r, s ∧t |−q ∧s which\nyou were invited to prove by yourself in the last section. Please compare\nthe proof below with your solution:\n1\n(p ∧q) ∧r\npremise\n2\ns ∧t\npremise\n3\np ∧q\n∧e1 1\n4\nq\n∧e2 3\n5\ns\n∧e1 2\n6\nq ∧s\n∧i 4, 5\n1.2 Natural deduction\n9\nThe rule for eliminating implication\nThere is one rule to introduce\n→and one to eliminate it. The latter is one of the best known rules of\npropositional logic and is often referred to by its Latin name modus ponens.\nWe will usually call it by its modern name, implies-elimination (sometimes\nalso referred to as arrow-elimination). This rule states that, given φ and\nknowing that φ implies ψ, we may rightfully conclude ψ. In our calculus, we\nwrite this as\nφ\nφ →ψ\nψ\n→e.\nLet us justify this rule by spelling out instances of some declarative sen-\ntences p and q. Suppose that\nof proof, which states rules for transforming valid sequents into valid sequents.\nFor example, if we have already a proof for the sequent Γ, φ ⊢ψ, then we ob-\ntain a proof of the sequent Γ ⊢φ →ψ by augmenting this very proof with one\napplication of the rule →i. The new approach expresses this as an inference rule\nbetween sequents:\nΓ, φ ⊢ψ\nΓ ⊢φ →ψ →i.\nThe rule ‘assumption’ is written as\nφ ⊢φ assumption\ni.e. the premise is empty. Such rules are called axioms.\n(a) Express all remaining proof rules of Figure 1.2 in such a form. (Hint: some\nof your rules may have more than one premise.)\n(b) Explain why proofs of Γ ⊢ψ in this new system have a tree-like structure\nwith Γ ⊢ψ as root.\n(c) Prove p ∨(p ∧q) ⊢p in your new proof system.\n1.7 Exercises\n81\n7. Show that\n√\n2 cannot be a rational number. Proceed by proof by contradiction:\nassume that\n√\n2 is a fraction k/l with integers k and l ̸= 0. On squaring both sides\nwe get 2 = k2/l2, or equivalently 2l2 = k2. We may assume that any common 2\nfactors of k and l have been cancelled. Can you now argue that 2l2 has a diﬀerent\nnumber of 2 factors from k2? Why would that be a contradiction and to what?\n8. There is an alternative approach to treating negation. One could simply ban the\noperator ¬ from propositional logic and think of φ →⊥as ‘being’ ¬φ. Naturally,\nsuch a logic cannot rely on the natural deduction rules for negation. Which of\nthe rules ¬i, ¬e, ¬¬e and ¬¬i can you simulate with the remaining proof rules\nby letting ¬φ be φ →⊥?\n9. Let us introduce a new connective φ ↔ψ which should abbreviate (φ →ψ) ∧\n(ψ →φ). Design introduction and elimination rules for ↔and show that they\nare derived rules if φ ↔ψ is interpreted as (φ →ψ) ∧(ψ →φ).\nExercises 1.3\nIn order to facilitate reading these exercises we assume below the usual\nconventions about binding priorities agreed upon in Convention 1.3.\n1. Given the following formulas, draw their corresponding parse tree:\n(a) p\n(b)\n*\np ∧q\n(c) p ∧¬q →¬p\n(d)\n*\np ∧(¬q →¬p)\n(e) p →(¬q ∨(q →p))\n(f)\nan implication. Suppose that p →q and ¬q are the case. Then, if p holds\nwe can use →e to conclude that q holds. Thus, we then have that q and ¬q\nhold, which is impossible. Therefore, we may infer that p must be false. But\nthis can only mean that ¬p is true. We summarise this reasoning into the\nrule modus tollens, or MT for short:5\nφ →ψ\n¬ψ\n¬φ\nMT.\nAgain, let us see an example of this rule in the natural language setting:\n‘If Abraham Lincoln was Ethiopian, then he was African. Abraham\nLincoln was not African; therefore he was not Ethiopian.’\nExample 1.7 In the following proof of\np →(q →r), p, ¬r ⊢¬q\nwe use several of the rules introduced so far:\n1\np →(q →r)\npremise\n2\np\npremise\n3\n¬r\npremise\n4\nq →r\n→e 1, 2\n5\n¬q\nMT 4, 3\n5 We will be able to derive this rule from other ones later on, but we introduce it here because it\nallows us already to do some pretty slick proofs. You may think of this rule as one on a higher\nlevel insofar as it does not mention the lower-level rules upon which it depends.\n1.2 Natural deduction\n11\nExamples 1.8 Here are two example proofs which combine the rule MT\nwith either ¬¬e or ¬¬i:\n1\n¬p →q\npremise\n2\n¬q\npremise\n3\n¬¬p\nMT 1, 2\n4\np\n¬¬e 3\nproves that the sequent ¬p →q, ¬q ⊢p is valid; and\n1\np →¬q\npremise\n2\nq\npremise\n3\n¬¬q\n¬¬i 2\n4\n¬p\nMT 1, 3\nshows the validity of the sequent p →¬q, q ⊢¬p.\nNote that the order of applying double negation rules and MT is diﬀerent\nin these examples; this order is driven by the structure of the particular\nsequent whose validity one is trying to show.\nThe rule implies introduction\nThe rule MT made it possible for us to\nshow that p →q, ¬q ⊢¬p is valid. But the validity of the sequent p →q ⊢\n¬q →¬p seems just as plausible. That sequent is, in a certain sense, saying\nthe same thing. Yet, so far we have no rule which builds implications that\ndo not already occur as premises in our proofs. The mechanics of such a rule\nare more involved than what we have seen so far. So let us proceed with",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-3",
                    "title": "Semantics of Propositional Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-3-subsection-1",
                            "title": "Meaning of Logical Connectives",
                            "content": "reality (they are true), or they don’t (they are false).\nIf we combine declarative sentences p and q with a logical connective, say\n∧, then the truth value of p ∧q is determined by three things: the truth value\nof p, the truth value of q and the meaning of ∧. The meaning of ∧is captured\nby the observation that p ∧q is true iﬀp and q are both true; otherwise p ∧q\nis false. Thus, as far as ∧is concerned, it needs only to know whether p and\nq are true, it does not need to know what p and q are actually saying about\nthe world out there. This is also the case for all the other logical connectives\nand is the reason why we can compute the truth value of a formula just by\nknowing the truth values of the atomic propositions occurring in it.\nDeﬁnition 1.28 1.\nThe set of truth values contains two elements T and F, where\nT represents ‘true’ and F represents ‘false’.\n2.\nA valuation or model of a formula φ is an assignment of each propositional atom\nin φ to a truth value.\nExample 1.29 The map which assigns T to q and F to p is a valuation for\np ∨¬q. Please list the remaining three valuations for this formula.\nWe can think of the meaning of ∧as a function of two arguments; each\nargument is a truth value and the result is again such a truth value. We\nspecify this function in a table, called the truth table for conjunction, which\nyou can see in Figure 1.5. In the ﬁrst column, labelled φ, we list all possible\nφ\nψ\nφ ∧ψ\nT\nT\nT\nT\nF\nF\nF\nT\nF\nF\nF\nF\nFigure 1.5. The truth table for conjunction, the logical connective ∧.\n38\n1 Propositional logic\nφ\nψ\nφ ∧ψ\nT\nT\nT\nT\nF\nF\nF\nT\nF\nF\nF\nF\nφ\nψ\nφ ∨ψ\nT\nT\nT\nT\nF\nT\nF\nT\nT\nF\nF\nF\nφ\nψ\nφ →ψ\nT\nT\nT\nT\nF\nF\nF\nT\nT\nF\nF\nT\nφ\n¬φ\nT\nF\nF\nT\n⊤\nT\n⊥\nF\nFigure 1.6. The truth tables for all the logical connectives discussed so far.\ntruth values of φ. Actually we list them twice since we also have to deal\nwith another formula ψ, so the possible number of combinations of truth\nvalues for φ and ψ equals 2 · 2 = 4. Notice that the four pairs of φ and ψ\nFigure 1.6. The truth tables for all the logical connectives discussed so far.\ntruth values of φ. Actually we list them twice since we also have to deal\nwith another formula ψ, so the possible number of combinations of truth\nvalues for φ and ψ equals 2 · 2 = 4. Notice that the four pairs of φ and ψ\nvalues in the ﬁrst two columns really exhaust all those possibilities (TT, TF,\nFT and FF). In the third column, we list the result of φ ∧ψ according to the\ntruth values of φ and ψ. So in the ﬁrst line, where φ and ψ have value T,\nthe result is T again. In all other lines, the result is F since at least one of\nthe propositions φ or ψ has value F.\nIn Figure 1.6 you ﬁnd the truth tables for all logical connectives of propo-\nsitional logic. Note that ¬ turns T into F and vice versa. Disjunction is the\nmirror image of conjunction if we swap T and F, namely, a disjunction re-\nturns F iﬀboth arguments are equal to F, otherwise (= at least one of the\narguments equals T) it returns T. The behaviour of implication is not quite\nas intuitive. Think of the meaning of →as checking whether truth is being\npreserved. Clearly, this is not the case when we have T →F, since we infer\nsomething that is false from something that is true. So the second entry\nin the column φ →ψ equals F. On the other hand, T →T obviously pre-\nserves truth, but so do the cases F →T and F →F, because there is no truth\nto be preserved in the ﬁrst place as the assumption of the implication is\nfalse.\nIf you feel slightly uncomfortable with the semantics (= the meaning)\nof →, then it might be good to think of φ →ψ as an abbreviation of the\nformula ¬φ ∨ψ as far as meaning is concerned; these two formulas are very\ndiﬀerent syntactically and natural deduction treats them diﬀerently as well.\nBut using the truth tables for ¬ and ∨you can check that φ →ψ evaluates\n1.4 Semantics of propositional logic\n39\nto T iﬀ¬φ ∨ψ does so. This means that φ →ψ and ¬φ ∨ψ are semantically\nequivalent; more on that in Section 1.5.\nknowledge.\nModal logic adds unary connectives to express one, or more, of these\ndiﬀerent modes of truth. The simplest modal logics just deal with one con-\ncept – such as knowledge, necessity, or time. More sophisticated modal logics\nhave connectives for expressing several modes of truth in the same logic; we\nwill see some of these towards the end of this chapter.\nWe take a logic engineering approach in this chapter, in which we address\nthe following question: given a particular mode of truth, how may we develop\na logic capable of expressing and formalising that concept? To answer this\nquestion, we need to decide what properties the logic should have and what\nexamples of reasoning it should be able to express. Our main case study will\nbe the logic of knowledge in a multi-agent system. But ﬁrst, we look at the\nsyntax and semantics of basic modal logic.\n5.2 Basic modal logic\n5.2.1 Syntax\nThe language of basic modal logic is that of propositional logic with two\nextra connectives, 2 and 3. Like negation (¬), they are unary connectives\nas they apply themselves to a single formula only. As done in Chapters 1\nand 3, we write p, q, r, p3 . . . to denote atomic formulas.\nDeﬁnition 5.1 The formulas of basic modal logic φ are deﬁned by the\nfollowing Backus Naur form (BNF):\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (φ ↔φ) | (2φ) | (3φ)\n(5.1)\nwhere p is any atomic formula.\nExample formulas of basic modal logic are (p ∧3(p →2¬r)) and 2((3q ∧\n¬r) →2p), having the parse trees shown in Figure 5.1. The following strings\nare not formulas, because they cannot be constructed using the grammar\nin (5.1): (p2 →q) and (p →3(q 3 r)).\nConvention 5.2 As done in Chapter 1, we assume that the unary connec-\ntives (¬, 2 and 3) bind most closely, followed by ∧and ∨and then followed\nby →and ↔.\n308\n5 Modal logics and agents\n∧\np\n3\n→\np\n2\n¬\nr\n2\n→\n2\n¬\n3\n∧\nr\np\nq\nFigure 5.1. Parse trees for (p ∧3(p →2¬r)) and 2((3q ∧¬r) →2p).\nThis convention allows us to remove many sets of brackets, retaining them\nThe tree in Figure 1.21 on page 82, however, does not represent a well-\nformed formula for two reasons. First, the leaf ∧(and a similar argument\napplies to the leaf ¬), the left subtree of the node →, is not a propositional\natom. This could be ﬁxed by saying that we decided to leave the left and\nright subtree of that node unspeciﬁed and that we are willing to provide\nthose now. However, the second reason is fatal. The p node is not a leaf\nsince it has a subtree, the node ¬. This cannot make sense if we think of\nthe entire tree as some logical formula. So this tree does not represent a\nwell-formed logical formula.\n1.4 Semantics of propositional logic\n1.4.1 The meaning of logical connectives\nIn the second section of this chapter, we developed a calculus of reasoning\nwhich could verify that sequents of the form φ1, φ2, . . . , φn ⊢ψ are valid,\nwhich means: from the premises φ1, φ2, . . . , φn, we may conclude ψ.\nIn this section we give another account of this relationship between the\npremises φ1, φ2, . . . , φn and the conclusion ψ. To contrast with the sequent\n1.4 Semantics of propositional logic\n37\nabove, we deﬁne a new relationship, written\nφ1, φ2, . . . , φn ⊨ψ.\nThis account is based on looking at the ‘truth values’ of the atomic formu-\nlas in the premises and the conclusion; and at how the logical connectives\nmanipulate these truth values. What is the truth value of a declarative sen-\ntence, like sentence (3) ‘Every even natural number > 2 is the sum of two\nprime numbers’? Well, declarative sentences express a fact about the real\nworld, the physical world we live in, or more abstract ones such as computer\nmodels, or our thoughts and feelings. Such factual statements either match\nreality (they are true), or they don’t (they are false).\nIf we combine declarative sentences p and q with a logical connective, say\n∧, then the truth value of p ∧q is determined by three things: the truth value\nof p, the truth value of q and the meaning of ∧. The meaning of ∧is captured\n(b)\n*\nq ∧¬r →p\n(c) p ∧¬r →q\n(d)\n*\n¬q ∧¬r →¬p.\n3. An adequate set of connectives for propositional logic is a set such that for every\nformula of propositional logic there is an equivalent formula with only connectives\nfrom that set. For example, the set {¬, ∨} is adequate for propositional logic,\nbecause any occurrence of ∧and →can be removed by using the equivalences\nφ →ψ ≡¬φ ∨ψ and φ ∧ψ ≡¬(¬φ ∨¬ψ).\n(a) Show that {¬, ∧}, {¬, →} and {→, ⊥} are adequate sets of connectives for\npropositional logic. (In the latter case, we are treating ⊥as a nullary con-\nnective.)\n(b) Show that, if C ⊆{¬, ∧, ∨, →, ⊥} is adequate for propositional logic, then\n¬ ∈C or ⊥∈C. (Hint: suppose C contains neither ¬ nor ⊥and consider\nthe truth value of a formula φ, formed by using only the connectives in C,\nfor a valuation in which every atom is assigned T.)\n(c) Is {↔, ¬} adequate? Prove your answer.\n4. Use soundness or completeness to show that a sequent φ1, φ2, . . . , φn ⊢ψ has a\nproof iﬀφ1 →φ2 →. . . φn →ψ is a tautology.\n88\n1 Propositional logic\n5. Show that the relation ≡is\n(a) reﬂexive: φ ≡φ holds for all φ\n(b) symmetric: φ ≡ψ implies ψ ≡φ and\n(c) transitive: φ ≡ψ and ψ ≡η imply φ ≡η.\n6. Show that, with respect to ≡,\n(a) ∧and ∨are idempotent:\ni. φ ∧φ ≡φ\nii. φ ∨φ ≡φ\n(b) ∧and ∨are commutative:\ni. φ ∧ψ ≡ψ ∧φ\nii. φ ∨ψ ≡ψ ∨φ\n(c) ∧and ∨are associative:\ni. φ ∧(ψ ∧η) ≡(φ ∧ψ) ∧η\nii. φ ∨(ψ ∨η) ≡(φ ∨ψ) ∨η\n(d) ∧and ∨are absorptive:\ni.\n*\nφ ∧(φ ∨η) ≡φ\nii. φ ∨(φ ∧η) ≡φ\n(e) ∧and ∨are distributive:\ni. φ ∧(ψ ∨η) ≡(φ ∧ψ) ∨(φ ∧η)\nii.\n*\nφ ∨(ψ ∧η) ≡(φ ∨ψ) ∧(φ ∨η)\n(f) ≡allows for double negation: φ ≡¬¬φ and\n(g) ∧and ∨satisﬁes the de Morgan rules:\ni. ¬(φ ∧ψ) ≡¬φ ∨¬ψ\nii.\n*\n¬(φ ∨ψ) ≡¬φ ∧¬ψ.\n7. Construct a formula in CNF based on each of the following truth tables:\n(a)\n*\np\nq\nφ1\nT\nT\nF\nF\nT\nF\nT\nF\nF\nF\nF\nT\n(b)\n*\np\nq\nr\nφ2\nT\nT\nT\nT\nT\nT\nF\nF\nT\nF\nT\nF\nF\nT\nT\nT\nT\nF\nF\nF\nF\nT\nF\nF\nF\nF\nT\nT\nF\nF\nF\nF\n1.7 Exercises\n89\n(c)\nr\ns\nq\nφ3\nT\nT\nT\nF\nT\nT\nF\nT\nT\nF\nT\nF\nF\nT\nT\nF\nT\nF\nF\nT\nF\nT\nF\nF\nF\nF\nT\nF\nF\nF\nF\nT\n8.\n*",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-2",
                            "title": "Mathematical Induction",
                            "content": "of our proof we write LHSn for the expression 1 + 2 + 3 + 4 + · · · + n and\nRHSn for n · (n + 1)/2. Thus, we need to show LHSn = RHSn for all n ≥1.\nBase case: If n equals 1, then LHS1 is just 1 (there is only one summand),\nwhich happens to equal RHS1 = 1 · (1 + 1)/2.\nInductive step: Let us assume that LHSn = RHSn. Recall that this as-\nsumption is called the induction hypothesis; it is the driving force of\nour argument. We need to show LHSn+1 = RHSn+1, i.e. that the longer\nsum 1 + 2 + 3 + 4 + · · · + (n + 1) equals (n + 1) · ((n + 1) + 1)/2. The key\nobservation is that the sum 1 + 2 + 3 + 4 + · · · + (n + 1) is nothing but\nthe sum (1 + 2 + 3 + 4 + · · · + n) + (n + 1) of two summands, where the\nﬁrst one is the sum of our induction hypothesis. The latter says that\n1 + 2 + 3 + 4 + · · · + n equals n · (n + 1)/2, and we are certainly entitled\nto substitute equals for equals in our reasoning. Thus, we compute\nLHSn+1\n= 1 + 2 + 3 + 4 + · · · + (n + 1)\n= LHSn + (n + 1) regrouping the sum\n1.4 Semantics of propositional logic\n43\n= RHSn + (n + 1) by our induction hypothesis\n= n·(n+1)\n2\n+ (n + 1)\n= n·(n+1)\n2\n+ 2·(n+1)\n2\narithmetic\n= (n+2)·(n+1)\n2\narithmetic\n= ((n+1)+1)·(n+1)\n2\narithmetic\n= RHSn+1.\nSince we successfully showed the base case and the inductive step, we can\nuse mathematical induction to infer that all natural numbers n have the\nproperty stated in the theorem above.\n2\nActually, there are numerous variations of this principle. For example, we\ncan think of a version in which the base case is n = 0, which would then\ncover all natural numbers including 0. Some statements hold only for all\nnatural numbers, say, greater than 3. So you would have to deal with a\nbase case 4, but keep the version of the inductive step (see the exercises for\nsuch an example). The use of mathematical induction typically suceeds on\nproperties M(n) that involve inductive deﬁnitions (e.g. the deﬁnition of kl\nwith l ≥0). Sentence (3) on page 2 suggests there may be true properties\ndone. Otherwise, we can use the inductive step, applied to n = 1, to infer\nthat 2 = 1 + 1 has property M(2). We can do that using →e, for we know\nthat 1 has the property in question. Now we use that same inductive step on\nn = 2 to infer that 3 has property M(3) and we repeat this until we reach\nn = k (see Figure 1.9). Therefore, we should have no objections about using\nthe principle of mathematical induction for natural numbers.\nReturning to Gauss’ example we claim that the sum 1 + 2 + 3 + 4 + · · · +\nn equals n · (n + 1)/2 for all natural numbers n.\nTheorem 1.31 The sum 1 + 2 + 3 + 4 + · · · + n equals n · (n + 1)/2 for all\nnatural numbers n.\n9 There is another way of ﬁnding the sum 1 + 2 + · · · + 100, which works like this: write the\nsum backwards, as 100 + 99 + · · · + 1. Now add the forwards and backwards versions, obtaining\n101 + 101 + · · · + 101 (100 times), which is 10100. Since we added the sum to itself, we now\ndivide by two to get the answer 5050. Gauss probably used this method; but the method of\nmathematical induction that we explore in this section is much more powerful and can be\napplied in a wide variety of situations.\n42\n1 Propositional logic\nWe prove M(1)\n...\n...\n1\n2\n3\n...\nn + 1\nn\nWe prove M(2) using M(1) and M(1) →M(2)\nWe prove M(3) using M(2) and M(2) →M(3)\nWe prove M(n) using M(n −1) and M(n −1) →M(n)\nWe prove M(n + 1) using M(n) and M(n) →M(n + 1)\nFigure 1.9. How the principle of mathematical induction works. By\nproving just two facts, M(1) and M(n) →M(n + 1) for a formal (and\nunconstrained) parameter n, we are able to deduce M(k) for each natural\nnumber k.\nProof: We use mathematical induction. In order to reveal the ﬁne structure\nof our proof we write LHSn for the expression 1 + 2 + 3 + 4 + · · · + n and\nRHSn for n · (n + 1)/2. Thus, we need to show LHSn = RHSn for all n ≥1.\nBase case: If n equals 1, then LHS1 is just 1 (there is only one summand),\nwhich happens to equal RHS1 = 1 · (1 + 1)/2.\nsuch an example). The use of mathematical induction typically suceeds on\nproperties M(n) that involve inductive deﬁnitions (e.g. the deﬁnition of kl\nwith l ≥0). Sentence (3) on page 2 suggests there may be true properties\nM(n) for which mathematical induction won’t work.\nCourse-of-values induction.\nThere is a variant of mathematical induction\nin which the induction hypothesis for proving M(n + 1) is not just M(n), but\nthe conjunction M(1) ∧M(2) ∧· · · ∧M(n). In that variant, called course-\nof-values induction, there doesn’t have to be an explicit base case at all –\neverything can be done in the inductive step.\nHow can this work without a base case? The answer is that the base\ncase is implicitly included in the inductive step. Consider the case n = 3:\nthe inductive-step instance is M(1) ∧M(2) ∧M(3) →M(4). Now consider\nn = 1: the inductive-step instance is M(1) →M(2). What about the case\nwhen n equals 0? In this case, there are zero formulas on the left of the →,\nso we have to prove M(1) from nothing at all. The inductive-step instance\nis simply the obligation to show M(1). You might ﬁnd it useful to modify\nFigure 1.9 for course-of-values induction.\nHaving said that the base case is implicit in course-of-values induction,\nit frequently turns out that it still demands special attention when you get\ninside trying to prove the inductive case. We will see precisely this in the\ntwo applications of course-of-values induction in the following pages.\n44\n1 Propositional logic\n¬\n∧\n→\n→\nq\n¬\np\n∨\nr\nq\np\nFigure 1.10. A parse tree with height 5.\nIn computer science, we often deal with ﬁnite structures of some kind, data\nstructures, programs, ﬁles etc. Often we need to show that every instance of\nsuch a structure has a certain property. For example, the well-formed for-\nmulas of Deﬁnition 1.27 have the property that the number of ‘(’ brackets\nin a particular formula equals its number of ‘)’ brackets. We can use mathe-\nare no left or right brackets, 0 equals 0.\nr Course-of-values inductive step: Then n > 1 and so the root of the parse tree\nof φ must be ¬, →, ∨or ∧, for φ is well-formed. We assume that it is →, the other\nthree cases are argued in a similar way. Then φ equals (φ1 →φ2) for some well-\nformed formulas φ1 and φ2 (of course, they are just the left, respectively right,\nlinear representations of the root’s two subtrees). It is clear that the heights\nof φ1 and φ2 are strictly smaller than n. Using the induction hypothesis, we\ntherefore conclude that φ1 has the same number of left and right brackets and\nthat the same is true for φ2. But in (φ1 →φ2) we added just two more brackets,\none ‘(’ and one ‘)’. Thus, the number of occurrences of ‘(’ and ‘)’ in φ is the\nsame.\n2\nThe formula (p →(q ∧¬r)) illustrates why we could not prove the above\ndirectly with mathematical induction on the height of formulas. While this\nformula has height 4, its two subtrees have heights 1 and 3, respectively.\nThus, an induction hypothesis for height 3 would have worked for the right\nsubtree but failed for the left subtree.\n1.4.3 Soundness of propositional logic\nThe natural deduction rules make it possible for us to develop rigorous\nthreads of argumentation, in the course of which we arrive at a conclusion\nψ assuming certain other propositions φ1, φ2, . . . , φn. In that case, we said\nthat the sequent φ1, φ2, . . . , φn ⊢ψ is valid. Do we have any evidence that\nthese rules are all correct in the sense that valid sequents all ‘preserve truth’\ncomputed by our truth-table semantics?\nGiven a proof of φ1, φ2, . . . , φn ⊢ψ, is it conceivable that there is a valu-\nation in which ψ above is false although all propositions φ1, φ2, . . . , φn are\ntrue? Fortunately, this is not the case and in this subsection we demonstrate\nwhy this is so. Let us suppose that some proof in our natural deduction cal-\nculus has established that the sequent φ1, φ2, . . . , φn ⊢ψ is valid. We need\ncomputes T for at least one of its valuations. Is the formula of the parse tree in\nFigure 1.10 on page 44 valid? Is it satisﬁable?\n6. Let ∗be a new logical connective such that p ∗q does not hold iﬀp and q are\neither both false or both true.\n(a) Write down the truth table for p ∗q.\n(b) Write down the truth table for (p ∗p) ∗(q ∗q).\n(c) Does the table in (b) coincide with a table in Figure 1.6 (page 38)? If so,\nwhich one?\n(d) Do you know ∗already as a logic gate in circuit design? If so, what is it\ncalled?\n7. These exercises let you practice proofs using mathematical induction. Make sure\nthat you state your base case and inductive step clearly. You should also indicate\nwhere you apply the induction hypothesis.\n(a) Prove that\n(2 · 1 −1) + (2 · 2 −1) + (2 · 3 −1) + · · · + (2 · n −1) = n2\nby mathematical induction on n ≥1.\n(b) Let k and l be natural numbers. We say that k is divisible by l if there\nexists a natural number p such that k = p · l. For example, 15 is divisible by\n3 because 15 = 5 · 3. Use mathematical induction to show that 11n −4n is\ndivisible by 7 for all natural numbers n ≥1.\n(c)\n*\nUse mathematical induction to show that\n12 + 22 + 32 + · · · + n2 = n · (n + 1) · (2n + 1)\n6\nfor all natural numbers n ≥1.\n(d)\n*\nProve that 2n ≥n + 12 for all natural numbers n ≥4. Here the base case is\nn = 4. Is the statement true for any n < 4?\n(e) Suppose a post oﬃce sells only 2c| and 3c| stamps. Show that any postage of\n2c|, or over, can be paid for using only these stamps. Hint: use mathematical\ninduction on n, where nc| is the postage. In the inductive step consider two\npossibilities: ﬁrst, nc| can be paid for using only 2c| stamps. Second, paying\nnc| requires the use of at least one 3c| stamp.\n(f) Prove that for every preﬁx of a well-formed propositional logic formula the\nnumber of left brackets is greater or equal to the number of right brackets.\n8.\n*\nThe Fibonacci numbers are most useful in modelling the growth of populations.\nWe deﬁne them by F1\ndef\n= 1, F2\ndef",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-3",
                            "title": "Soundness of Propositional Logic",
                            "content": "29\n1.3\nPropositional logic as a formal language\n31\n1.4\nSemantics of propositional logic\n36\n1.4.1\nThe meaning of logical connectives\n36\n1.4.2\nMathematical induction\n40\n1.4.3\nSoundness of propositional logic\n45\n1.4.4\nCompleteness of propositional logic\n49\n1.5\nNormal forms\n53\n1.5.1\nSemantic equivalence, satisﬁability and validity\n54\n1.5.2\nConjunctive normal forms and validity\n58\n1.5.3\nHorn clauses and satisﬁability\n65\n1.6\nSAT solvers\n68\n1.6.1\nA linear solver\n69\n1.6.2\nA cubic solver\n72\n1.7\nExercises\n78\n1.8\nBibliographic notes\n91\n2\nPredicate logic\n93\n2.1\nThe need for a richer language\n93\nv\nvi\nContents\n2.2\nPredicate logic as a formal language\n98\n2.2.1\nTerms\n99\n2.2.2\nFormulas\n100\n2.2.3\nFree and bound variables\n102\n2.2.4\nSubstitution\n104\n2.3\nProof theory of predicate logic\n107\n2.3.1\nNatural deduction rules\n107\n2.3.2\nQuantiﬁer equivalences\n117\n2.4\nSemantics of predicate logic\n122\n2.4.1\nModels\n123\n2.4.2\nSemantic entailment\n129\n2.4.3\nThe semantics of equality\n130\n2.5\nUndecidability of predicate logic\n131\n2.6\nExpressiveness of predicate logic\n136\n2.6.1\nExistential second-order logic\n139\n2.6.2\nUniversal second-order logic\n140\n2.7\nMicromodels of software\n141\n2.7.1\nState machines\n142\n2.7.2\nAlma – re-visited\n146\n2.7.3\nA software micromodel\n148\n2.8\nExercises\n157\n2.9\nBibliographic notes\n170\n3\nVeriﬁcation by model checking\n172\n3.1\nMotivation for veriﬁcation\n172\n3.2\nLinear-time temporal logic\n175\n3.2.1\nSyntax of LTL\n175\n3.2.2\nSemantics of LTL\n178\n3.2.3\nPractical patterns of speciﬁcations\n183\n3.2.4\nImportant equivalences between LTL formulas\n184\n3.2.5\nAdequate sets of connectives for LTL\n186\n3.3\nModel checking: systems, tools, properties\n187\n3.3.1\nExample: mutual exclusion\n187\n3.3.2\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nIn Chapter 1, we gave a natural de-\nduction system for propositional logic which was sound and complete with\n328\n5 Modal logics and agents\nrespect to semantic entailment based on truth tables. We also pointed out\nthat the proof rules PBC, LEM and ¬¬e are questionable in certain com-\nputational situations. If we disallow their usage in natural deduction proofs,\nwe obtain a logic, called intuitionistic propositional logic, together with its\nown proof theory. So far so good; but it is less clear what sort of semantics\none could have for such a logic – again with soundness and completeness in\nmind. This is where certain models of KT4 will do the job quite nicely. Recall\nthat correspondence theory implies that a model M = (W, R, L) of KT4 is\nsuch that R is reﬂexive and transitive. The only additional requirement we\nimpose on a model for intuitionistic propositional logic is that its labelling\nfunction L be monotone in R: R(x, y) implies that L(x) is a subset of L(y).\nThis models that the truth of atomic positive formulas persist throughout\nthe worlds that are reachable from a given world.\nDeﬁnition 5.19 A model of intuitionistic propositional logic is a model\nM = (W, R, L) of KT4 such that R(x, y) always implies L(x) ⊆L(y). Given\na propositional logic formula as in (1.3), we deﬁne x ⊩φ as in Deﬁnition 5.4\nexception for the clauses →and ¬. For φ1 →φ2 we deﬁne x ⊩φ1 →φ2 iﬀ\nfor all y with R(x, y) we have y ⊩φ2 whenever we have y ⊩φ1. For ¬φ we\ndeﬁne x ⊩¬φ iﬀfor all y with R(x, y) we have y ̸⊩φ.\nAs an example, consider the model W = {x, y} with accessibility relation\nR = {(x, x), (x, y), (y, y)}, which is indeed reﬂexive and transitive. For a la-\nbelling function L with L(x) = ∅and L(y) = {p}, we claim that x ̸⊩p ∨¬p.\n(Recall that p ∨¬p is an instance of LEM which we proved in Chapter 1 with\nthe full natural deduction calculus.) We do not have x ⊩p, for p is not in\nthe set L(x) which is empty. Thus, Deﬁnition 5.4 for the case ∨implies that\nciding their satisﬁability. One such example is the class of Horn formu-\nlas; the name ‘Horn’ is derived from the logician A. Horn’s last name.\nWe shortly deﬁne them and give an algorithm for checking their satisﬁ-\nability.\nRecall that the logical constants ⊥(‘bottom’) and ⊤(‘top’) denote an\nunsatisﬁable formula, respectively, a tautology.\nDeﬁnition 1.46 A Horn formula is a formula φ of propositional logic if it\ncan be generated as an instance of H in this grammar:\nP ::= ⊥| ⊤| p\nA ::= P | P ∧A\nC ::= A →P\nH ::= C | C ∧H.\n(1.7)\nWe call each instance of C a Horn clause.\n66\n1 Propositional logic\nHorn formulas are conjunctions of Horn clauses. A Horn clause is an impli-\ncation whose assumption A is a conjunction of propositions of type P and\nwhose conclusion is also of type P. Examples of Horn formulas are\n(p ∧q ∧s →p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13) ∧(⊤→p5) ∧(p5 ∧p11 →⊥).\nExamples of formulas which are not Horn formulas are\n(p ∧q ∧s →¬p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(¬q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 →⊥)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 ∨⊥).\nThe ﬁrst formula is not a Horn formula since ¬p, the conclusion of the\nimplication of the ﬁrst conjunct, is not of type P. The second formula does\nnot qualify since the premise of the implication of the second conjunct,\n¬q ∧r, is not a conjunction of atoms, ⊥, or ⊤. The third formula is not a\nHorn formula since the conclusion of the implication of the ﬁrst conjunct,\np13 ∧p27, is not of type P. The fourth formula clearly is not a Horn formula\nsince it is not a conjunction of implications.\nThe algorithm we propose for deciding the satisﬁability of a Horn for-\nmula φ maintains a list of all occurrences of type P in φ and proceeds like\nthis:\n1.\nIt marks ⊤if it occurs in that list.\n2.\nIf there is a conjunct P1 ∧P2 ∧· · · ∧Pki →P ′ of φ such that all Pj with 1 ≤j ≤\nki are marked, mark P ′ as well and go to 2. Otherwise (= there is no conjunct\nto predicate logic, let’s now look at how the semantics of predicate logic\nworks. Just like in the propositional case, the semantics should provide a\nseparate, but ultimately equivalent, characterisation of the logic. By ‘sepa-\nrate,’ we mean that the meaning of the connectives is deﬁned in a diﬀerent\nway; in proof theory, they were deﬁned by proof rules providing an oper-\native explanation. In semantics, we expect something like truth tables. By\n‘equivalent,’ we mean that we should be able to prove soundness and com-\npleteness, as we did for propositional logic – although a fully ﬂedged proof\nof soundness and completeness for predicate logic is beyond the scope of this\nbook.\nBefore we begin describing the semantics of predicate logic, let us look\nmore closely at the real diﬀerence between a semantic and a proof-theoretic\naccount. In proof theory, the basic object which is constructed is a proof.\nLet us write Γ as a shorthand for lists of formulas φ1, φ2, . . . , φn. Thus, to\nshow that Γ ⊢ψ is valid, we need to provide a proof of ψ from Γ. Yet,\nhow can we show that ψ is not a consequence of Γ? Intuitively, this is\nharder; how can you possibly show that there is no proof of something?\nYou would have to consider every ‘candidate’ proof and show it is not one.\nThus, proof theory gives a ‘positive’ characterisation of the logic; it pro-\nvides convincing evidence for assertions like ‘Γ ⊢ψ is valid,’ but it is not\nvery useful for establishing evidence for assertions of the form ‘Γ ⊢φ is not\nvalid.’\n2.4 Semantics of predicate logic\n123\nSemantics, on the other hand, works in the opposite way. To show that ψ\nis not a consequence of Γ is the ‘easy’ bit: ﬁnd a model in which all φi are\ntrue, but ψ isn’t. Showing that ψ is a consequence of Γ, on the other hand,\nis harder in principle. For propositional logic, you need to show that every\nvaluation (an assignment of truth values to all atoms involved) that makes\ndiﬀerent syntactically and natural deduction treats them diﬀerently as well.\nBut using the truth tables for ¬ and ∨you can check that φ →ψ evaluates\n1.4 Semantics of propositional logic\n39\nto T iﬀ¬φ ∨ψ does so. This means that φ →ψ and ¬φ ∨ψ are semantically\nequivalent; more on that in Section 1.5.\nGiven a formula φ which contains the propositional atoms p1, p2, . . . , pn,\nwe can construct a truth table for φ, at least in principle. The caveat is that\nthis truth table has 2n many lines, each line listing a possible combination\nof truth values for p1, p2, . . . , pn; and for large n this task is impossible to\ncomplete. Our aim is thus to compute the value of φ for each of these 2n\ncases for moderately small values of n. Let us consider the example φ in\nFigure 1.3. It involves three propositional atoms (n = 3) so we have 23 = 8\ncases to consider.\nWe illustrate how things go for one particular case, namely for the val-\nuation in which q evaluates to F; and p and r evaluate to T. What does\n¬p ∧q →p ∧(q ∨¬r) evaluate to? Well, the beauty of our semantics is that\nit is compositional. If we know the meaning of the subformulas ¬p ∧q and\np ∧(q ∨¬r), then we just have to look up the appropriate line of the →\ntruth table to ﬁnd the value of φ, for φ is an implication of these two sub-\nformulas. Therefore, we can do the calculation by traversing the parse tree\nof φ in a bottom-up fashion. We know what its leaves evaluate to since we\nstated what the atoms p, q and r evaluated to. Because the meaning of p is\nT, we see that ¬p computes to F. Now q is assumed to represent F and the\nconjunction of F and F is F. Thus, the left subtree of the node →evaluates\nto F. As for the right subtree of →, r stands for T so ¬r computes to F and q\nmeans F, so the disjunction of F and F is still F. We have to take that result,\nF, and compute its conjunction with the meaning of p which is T. Since the\nconjunction of T and F is F, we get F as the meaning of the right subtree",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-4",
                            "title": "Completeness of Propositional Logic",
                            "content": "ciding their satisﬁability. One such example is the class of Horn formu-\nlas; the name ‘Horn’ is derived from the logician A. Horn’s last name.\nWe shortly deﬁne them and give an algorithm for checking their satisﬁ-\nability.\nRecall that the logical constants ⊥(‘bottom’) and ⊤(‘top’) denote an\nunsatisﬁable formula, respectively, a tautology.\nDeﬁnition 1.46 A Horn formula is a formula φ of propositional logic if it\ncan be generated as an instance of H in this grammar:\nP ::= ⊥| ⊤| p\nA ::= P | P ∧A\nC ::= A →P\nH ::= C | C ∧H.\n(1.7)\nWe call each instance of C a Horn clause.\n66\n1 Propositional logic\nHorn formulas are conjunctions of Horn clauses. A Horn clause is an impli-\ncation whose assumption A is a conjunction of propositions of type P and\nwhose conclusion is also of type P. Examples of Horn formulas are\n(p ∧q ∧s →p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13) ∧(⊤→p5) ∧(p5 ∧p11 →⊥).\nExamples of formulas which are not Horn formulas are\n(p ∧q ∧s →¬p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(¬q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 →⊥)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 ∨⊥).\nThe ﬁrst formula is not a Horn formula since ¬p, the conclusion of the\nimplication of the ﬁrst conjunct, is not of type P. The second formula does\nnot qualify since the premise of the implication of the second conjunct,\n¬q ∧r, is not a conjunction of atoms, ⊥, or ⊤. The third formula is not a\nHorn formula since the conclusion of the implication of the ﬁrst conjunct,\np13 ∧p27, is not of type P. The fourth formula clearly is not a Horn formula\nsince it is not a conjunction of implications.\nThe algorithm we propose for deciding the satisﬁability of a Horn for-\nmula φ maintains a list of all occurrences of type P in φ and proceeds like\nthis:\n1.\nIt marks ⊤if it occurs in that list.\n2.\nIf there is a conjunct P1 ∧P2 ∧· · · ∧Pki →P ′ of φ such that all Pj with 1 ≤j ≤\nki are marked, mark P ′ as well and go to 2. Otherwise (= there is no conjunct\n1.4.4 Completeness of propositional logic\nIn this subsection, we hope to convince you that the natural deduction rules\nof propositional logic are complete: whenever φ1, φ2, . . . , φn ⊨ψ holds, then\nthere exists a natural deduction proof for the sequent φ1, φ2, . . . , φn ⊢ψ.\nCombined with the soundness result of the previous subsection, we then\nobtain\nφ1, φ2, . . . , φn ⊢ψ is valid iﬀφ1, φ2, . . . , φn ⊨ψ holds.\nThis gives you a certain freedom regarding which method you prefer to\nuse. Often it is much easier to show one of these two relationships (al-\nthough neither of the two is universally better, or easier, to establish).\nThe ﬁrst method involves a proof search, upon which the logic program-\nming paradigm is based. The second method typically forces you to com-\npute a truth table which is exponential in the size of occurring proposi-\ntional atoms. Both methods are intractable in general but particular in-\nstances of formulas often respond diﬀerently to treatment under these two\nmethods.\nThe remainder of this section is concerned with an argument saying that\nif φ1, φ2, . . . , φn ⊨ψ holds, then φ1, φ2, . . . , φn ⊢ψ is valid. Assuming that\nφ1, φ2, . . . , φn ⊨ψ holds, the argument proceeds in three steps:\nStep 1: We show that ⊨φ1 →(φ2 →(φ3 →(. . . (φn →ψ) . . . ))) holds.\nStep 2: We show that ⊢φ1 →(φ2 →(φ3 →(. . . (φn →ψ) . . . ))) is valid.\nStep 3: Finally, we show that φ1, φ2, . . . , φn ⊢ψ is valid.\nThe ﬁrst and third steps are quite easy; all the real work is done in the\nsecond one.\n50\n1 Propositional logic\n→\n→\n→\n→\n→\nF\nF\nF\nF\nF\nψ\nF\nT\nT\nT\nT\nT\nφn\nφn−1\nφ3\nφ2\nφ1\nFigure 1.11. The only way this parse tree can evaluate to F. We repre-\nsent parse trees for φ1, φ2, . . . , φn as triangles as their internal structure\ndoes not concern us here.\nStep 1:\nDeﬁnition 1.36 A formula of propositional logic φ is called a tautology iﬀ\nit evaluates to T under all its valuations, i.e. iﬀ⊨φ.\nSupposing that φ1, φ2, . . . , φn ⊨ψ holds, let us verify that φ1 →(φ2 →\n29\n1.3\nPropositional logic as a formal language\n31\n1.4\nSemantics of propositional logic\n36\n1.4.1\nThe meaning of logical connectives\n36\n1.4.2\nMathematical induction\n40\n1.4.3\nSoundness of propositional logic\n45\n1.4.4\nCompleteness of propositional logic\n49\n1.5\nNormal forms\n53\n1.5.1\nSemantic equivalence, satisﬁability and validity\n54\n1.5.2\nConjunctive normal forms and validity\n58\n1.5.3\nHorn clauses and satisﬁability\n65\n1.6\nSAT solvers\n68\n1.6.1\nA linear solver\n69\n1.6.2\nA cubic solver\n72\n1.7\nExercises\n78\n1.8\nBibliographic notes\n91\n2\nPredicate logic\n93\n2.1\nThe need for a richer language\n93\nv\nvi\nContents\n2.2\nPredicate logic as a formal language\n98\n2.2.1\nTerms\n99\n2.2.2\nFormulas\n100\n2.2.3\nFree and bound variables\n102\n2.2.4\nSubstitution\n104\n2.3\nProof theory of predicate logic\n107\n2.3.1\nNatural deduction rules\n107\n2.3.2\nQuantiﬁer equivalences\n117\n2.4\nSemantics of predicate logic\n122\n2.4.1\nModels\n123\n2.4.2\nSemantic entailment\n129\n2.4.3\nThe semantics of equality\n130\n2.5\nUndecidability of predicate logic\n131\n2.6\nExpressiveness of predicate logic\n136\n2.6.1\nExistential second-order logic\n139\n2.6.2\nUniversal second-order logic\n140\n2.7\nMicromodels of software\n141\n2.7.1\nState machines\n142\n2.7.2\nAlma – re-visited\n146\n2.7.3\nA software micromodel\n148\n2.8\nExercises\n157\n2.9\nBibliographic notes\n170\n3\nVeriﬁcation by model checking\n172\n3.1\nMotivation for veriﬁcation\n172\n3.2\nLinear-time temporal logic\n175\n3.2.1\nSyntax of LTL\n175\n3.2.2\nSemantics of LTL\n178\n3.2.3\nPractical patterns of speciﬁcations\n183\n3.2.4\nImportant equivalences between LTL formulas\n184\n3.2.5\nAdequate sets of connectives for LTL\n186\n3.3\nModel checking: systems, tools, properties\n187\n3.3.1\nExample: mutual exclusion\n187\n3.3.2\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\n(b)\n*\nq ∧¬r →p\n(c) p ∧¬r →q\n(d)\n*\n¬q ∧¬r →¬p.\n3. An adequate set of connectives for propositional logic is a set such that for every\nformula of propositional logic there is an equivalent formula with only connectives\nfrom that set. For example, the set {¬, ∨} is adequate for propositional logic,\nbecause any occurrence of ∧and →can be removed by using the equivalences\nφ →ψ ≡¬φ ∨ψ and φ ∧ψ ≡¬(¬φ ∨¬ψ).\n(a) Show that {¬, ∧}, {¬, →} and {→, ⊥} are adequate sets of connectives for\npropositional logic. (In the latter case, we are treating ⊥as a nullary con-\nnective.)\n(b) Show that, if C ⊆{¬, ∧, ∨, →, ⊥} is adequate for propositional logic, then\n¬ ∈C or ⊥∈C. (Hint: suppose C contains neither ¬ nor ⊥and consider\nthe truth value of a formula φ, formed by using only the connectives in C,\nfor a valuation in which every atom is assigned T.)\n(c) Is {↔, ¬} adequate? Prove your answer.\n4. Use soundness or completeness to show that a sequent φ1, φ2, . . . , φn ⊢ψ has a\nproof iﬀφ1 →φ2 →. . . φn →ψ is a tautology.\n88\n1 Propositional logic\n5. Show that the relation ≡is\n(a) reﬂexive: φ ≡φ holds for all φ\n(b) symmetric: φ ≡ψ implies ψ ≡φ and\n(c) transitive: φ ≡ψ and ψ ≡η imply φ ≡η.\n6. Show that, with respect to ≡,\n(a) ∧and ∨are idempotent:\ni. φ ∧φ ≡φ\nii. φ ∨φ ≡φ\n(b) ∧and ∨are commutative:\ni. φ ∧ψ ≡ψ ∧φ\nii. φ ∨ψ ≡ψ ∨φ\n(c) ∧and ∨are associative:\ni. φ ∧(ψ ∧η) ≡(φ ∧ψ) ∧η\nii. φ ∨(ψ ∨η) ≡(φ ∨ψ) ∨η\n(d) ∧and ∨are absorptive:\ni.\n*\nφ ∧(φ ∨η) ≡φ\nii. φ ∨(φ ∧η) ≡φ\n(e) ∧and ∨are distributive:\ni. φ ∧(ψ ∨η) ≡(φ ∧ψ) ∨(φ ∧η)\nii.\n*\nφ ∨(ψ ∧η) ≡(φ ∨ψ) ∧(φ ∨η)\n(f) ≡allows for double negation: φ ≡¬¬φ and\n(g) ∧and ∨satisﬁes the de Morgan rules:\ni. ¬(φ ∧ψ) ≡¬φ ∨¬ψ\nii.\n*\n¬(φ ∨ψ) ≡¬φ ∧¬ψ.\n7. Construct a formula in CNF based on each of the following truth tables:\n(a)\n*\np\nq\nφ1\nT\nT\nF\nF\nT\nF\nT\nF\nF\nF\nF\nT\n(b)\n*\np\nq\nr\nφ2\nT\nT\nT\nT\nT\nT\nF\nF\nT\nF\nT\nF\nF\nT\nT\nT\nT\nF\nF\nF\nF\nT\nF\nF\nF\nF\nT\nT\nF\nF\nF\nF\n1.7 Exercises\n89\n(c)\nr\ns\nq\nφ3\nT\nT\nT\nF\nT\nT\nF\nT\nT\nF\nT\nF\nF\nT\nT\nF\nT\nF\nF\nT\nF\nT\nF\nF\nF\nF\nT\nF\nF\nF\nF\nT\n8.\n*\ndoes not seem to make a lot of sense as far as propositional logic is concerned.\nSo what we have to deﬁne are those strings which we want to call formulas.\nWe call such formulas well-formed.\nDeﬁnition 1.27 The well-formed formulas of propositional logic are those\nwhich we obtain by using the construction rules below, and only those,\nﬁnitely many times:\n1.3 Propositional logic as a formal language\n33\natom: Every propositional atom p, q, r, . . . and p1, p2, p3, . . . is a well-\nformed formula.\n¬: If φ is a well-formed formula, then so is (¬φ).\n∧: If φ and ψ are well-formed formulas, then so is (φ ∧ψ).\n∨: If φ and ψ are well-formed formulas, then so is (φ ∨ψ).\n→: If φ and ψ are well-formed formulas, then so is (φ →ψ).\nIt is most crucial to realize that this deﬁnition is the one a computer would\nexpect and that we did not make use of the binding priorities agreed upon\nin the previous section.\nConvention. In this section we act as if we are a rigorous computer and\nwe call formulas well-formed iﬀthey can be deduced to be so using the\ndeﬁnition above.\nFurther, note that the condition ‘and only those’ in the deﬁnition above\nrules out the possibility of any other means of establishing that formulas are\nwell-formed. Inductive deﬁnitions, like the one of well-formed propositional\nlogic formulas above, are so frequent that they are often given by a deﬁning\ngrammar in Backus Naur form (BNF). In that form, the above deﬁnition\nreads more compactly as\nφ ::= p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ)\n(1.3)\nwhere p stands for any atomic proposition and each occurrence of φ to the\nright of ::= stands for any already constructed formula.\nSo how can we show that a string is a well-formed formula? For example,\nhow do we answer this for φ being\n(((¬p) ∧q) →(p ∧(q ∨(¬r)))) ?\n(1.4)\nSuch reasoning is greatly facilitated by the fact that the grammar in (1.3)\nsatisﬁes the inversion principle, which means that we can invert the process",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-4",
                    "title": "Normal Forms",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-4-subsection-1",
                            "title": "Semantic Equivalence, Satisfiability and Validity",
                            "content": "29\n1.3\nPropositional logic as a formal language\n31\n1.4\nSemantics of propositional logic\n36\n1.4.1\nThe meaning of logical connectives\n36\n1.4.2\nMathematical induction\n40\n1.4.3\nSoundness of propositional logic\n45\n1.4.4\nCompleteness of propositional logic\n49\n1.5\nNormal forms\n53\n1.5.1\nSemantic equivalence, satisﬁability and validity\n54\n1.5.2\nConjunctive normal forms and validity\n58\n1.5.3\nHorn clauses and satisﬁability\n65\n1.6\nSAT solvers\n68\n1.6.1\nA linear solver\n69\n1.6.2\nA cubic solver\n72\n1.7\nExercises\n78\n1.8\nBibliographic notes\n91\n2\nPredicate logic\n93\n2.1\nThe need for a richer language\n93\nv\nvi\nContents\n2.2\nPredicate logic as a formal language\n98\n2.2.1\nTerms\n99\n2.2.2\nFormulas\n100\n2.2.3\nFree and bound variables\n102\n2.2.4\nSubstitution\n104\n2.3\nProof theory of predicate logic\n107\n2.3.1\nNatural deduction rules\n107\n2.3.2\nQuantiﬁer equivalences\n117\n2.4\nSemantics of predicate logic\n122\n2.4.1\nModels\n123\n2.4.2\nSemantic entailment\n129\n2.4.3\nThe semantics of equality\n130\n2.5\nUndecidability of predicate logic\n131\n2.6\nExpressiveness of predicate logic\n136\n2.6.1\nExistential second-order logic\n139\n2.6.2\nUniversal second-order logic\n140\n2.7\nMicromodels of software\n141\n2.7.1\nState machines\n142\n2.7.2\nAlma – re-visited\n146\n2.7.3\nA software micromodel\n148\n2.8\nExercises\n157\n2.9\nBibliographic notes\n170\n3\nVeriﬁcation by model checking\n172\n3.1\nMotivation for veriﬁcation\n172\n3.2\nLinear-time temporal logic\n175\n3.2.1\nSyntax of LTL\n175\n3.2.2\nSemantics of LTL\n178\n3.2.3\nPractical patterns of speciﬁcations\n183\n3.2.4\nImportant equivalences between LTL formulas\n184\n3.2.5\nAdequate sets of connectives for LTL\n186\n3.3\nModel checking: systems, tools, properties\n187\n3.3.1\nExample: mutual exclusion\n187\n3.3.2\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nand r ∨¬r? At ﬁrst glance, they have little in common, having diﬀerent\natomic formulas and diﬀerent connectives. Moreover, the truth table for\np ∧q →p is four lines long, whereas the one for r ∨¬r consists of only two\nlines. However, both formulas are always true. This suggests that we deﬁne\nthe equivalence of formulas φ and ψ via ⊨: if φ semantically entails ψ and\nvice versa, then these formulas should be the same as far as our truth-table\nsemantics is concerned.\nDeﬁnition 1.40 Let φ and ψ be formulas of propositional logic. We say\nthat φ and ψ are semantically equivalent iﬀφ ⊨ψ and ψ ⊨φ hold. In that\ncase we write φ ≡ψ. Further, we call φ valid if ⊨φ holds.\nNote that we could also have deﬁned φ ≡ψ to mean that ⊨(φ →ψ) ∧\n(ψ →φ) holds; it amounts to the same concept. Indeed, because of soundness\nand completeness, semantic equivalence is identical to provable equivalence\n1.5 Normal forms\n55\n(Deﬁnition 1.25). Examples of equivalent formulas are\np →q ≡¬q →¬p\np →q ≡¬p ∨q\np ∧q →p ≡r ∨¬r\np ∧q →r ≡p →(q →r).\nRecall that a formula η is called a tautology if ⊨η holds, so the tautologies\nare exactly the valid formulas. The following lemma says that any decision\nprocedure for tautologies is in fact a decision procedure for the validity of\nsequents as well.\nLemma 1.41 Given formulas φ1, φ2, . . . , φn and ψ of propositional logic,\nφ1, φ2, . . . , φn ⊨ψ holds iﬀ⊨φ1 →(φ2 →(φ3 →· · · →(φn →ψ))) holds.\nProof: First, suppose that ⊨φ1 →(φ2 →(φ3 →· · · →(φn →ψ))) holds.\nIf φ1, φ2, . . . , φn are all true under some valuation, then ψ has to be true\nas well for that same valuation. Otherwise,\n⊨φ1 →(φ2 →(φ3 →· · · →\n(φn →ψ))) would not hold (compare this with Figure 1.11). Second, if\nφ1, φ2, . . . , φn ⊨ψ holds, we have already shown that ⊨φ1 →(φ2 →(φ3 →\n· · · →(φn →ψ))) follows in step 1 of our completeness proof.\n2\nFor our current purposes, we want to transform formulas into ones which\ndon’t contain →at all and the occurrences of ∧and ∨are conﬁned to\n9. Let φ and ψ and η be sentences of predicate logic.\n(a) If ψ is semantically entailed by φ, is it necessarily the case that ψ is not\nsemantically entailed by ¬φ?\n(b)\n*\nIf ψ is semantically entailed by φ ∧η, is it necessarily the case that ψ is\nsemantically entailed by φ and semantically entailed by η?\n(c) If ψ is semantically entailed by φ or by η, is it necessarily the case that ψ\nis semantically entailed by φ ∨η?\n(d) Explain why ψ is semantically entailed by φ iﬀφ →ψ is valid.\n10. Is ∀x (P(x) ∨Q(x)) ⊨∀x P(x) ∨∀x Q(x) a semantic entailment? Justify your\nanswer.\n11. For each set of formulas below show that they are consistent:\n(a) ∀x ¬S(x, x), ∃x P(x), ∀x ∃y S(x, y), ∀x (P(x) →∃y S(y, x))\n(b)\n*\n∀x ¬S(x, x), ∀x ∃y S(x, y),\n∀x ∀y ∀z ((S(x, y) ∧S(y, z)) →S(x, z))\n(c) (∀x (P(x) ∨Q(x))) →∃y R(y), ∀x (R(x) →Q(x)), ∃y (¬Q(y) ∧P(y))\n(d)\n*\n∃x S(x, x), ∀x ∀y (S(x, y) →(x = y)).\n12. For each of the formulas of predicate logic below, either ﬁnd a model which\ndoes not satisfy it, or prove it is valid:\n(a) (∀x ∀y (S(x, y) →S(y, x))) →(∀x ¬S(x, x))\n(b)\n*\n∃y ((∀x P(x)) →P(y))\n(c) (∀x (P(x) →∃y Q(y))) →(∀x ∃y (P(x) →Q(y)))\n(d) (∀x ∃y (P(x) →Q(y))) →(∀x (P(x) →∃y Q(y)))\n(e) ∀x ∀y (S(x, y) →(∃z (S(x, z) ∧S(z, y))))\n(f) (∀x ∀y (S(x, y) →(x = y))) →(∀z ¬S(z, z))\n(g)\n*\n(∀x ∃y (S(x, y) ∧((S(x, y) ∧S(y, x)) →(x = y)))) →\n(¬∃z ∀w (S(z, w))).\n(h) ∀x ∀y ((P(x) →P(y)) ∧(P(y) →P(x)))\n(i) (∀x ((P(x) →Q(x)) ∧(Q(x) →P(x)))) →((∀x P(x)) →(∀x Q(x)))\n(j) ((∀x P(x)) →(∀x Q(x))) →(∀x ((P(x) →Q(x)) ∧(Q(x) →P(x))))\n(k) Diﬃcult: (∀x ∃y (P(x) →Q(y))) →(∃y ∀x (P(x) →Q(y))).\nExercises 2.5\n1. Assuming that our proof calculus for predicate logic is sound (see exercise 3\nbelow), show that the validity of the following sequents cannot be proved by\nﬁnding for each sequent a model such that all formulas to the left of ⊢evaluate\nto T and the sole formula to the right of ⊢evaluates to F (explain why this\nguarantees the non-existence of a proof):\n2.8 Exercises\n165\n(a) ∀x (P(x) ∨Q(x)) ⊢∀x P(x) ∨∀x Q(x)\n(b)\n*\n57\nDeﬁnition 1.44 Given a formula φ in propositional logic, we say that φ is\nsatisﬁable if it has a valuation in which is evaluates to T.\nFor example, the formula p ∨q →p is satisﬁable since it computes T if we\nassign T to p. Clearly, p ∨q →p is not valid. Thus, satisﬁability is a weaker\nconcept since every valid formula is by deﬁnition also satisﬁable but not vice\nversa. However, these two notions are just mirror images of each other, the\nmirror being negation.\nProposition 1.45 Let φ be a formula of propositional logic. Then φ is sat-\nisﬁable iﬀ¬φ is not valid.\nProof: First, assume that φ is satisﬁable. By deﬁnition, there exists a\nvaluation of φ in which φ evaluates to T; but that means that ¬φ evaluates\nto F for that same valuation. Thus, ¬φ cannot be valid.\nSecond, assume that ¬φ is not valid. Then there must be a valuation\nof ¬φ in which ¬φ evaluates to F. Thus, φ evaluates to T and is there-\nfore satisﬁable. (Note that the valuations of φ are exactly the valuations of\n¬φ.)\n2\nThis result is extremely useful since it essentially says that we need provide\na decision procedure for only one of these concepts. For example, let’s say\nthat we have a procedure P for deciding whether any φ is valid. We obtain a\ndecision procedure for satisﬁability simply by asking P whether ¬φ is valid.\nIf it is, φ is not satisﬁable; otherwise φ is satisﬁable. Similarly, we may\ntransform any decision procedure for satisﬁability into one for validity. We\nwill encounter both kinds of procedures in this text.\nThere is one scenario in which computing an equivalent formula in CNF\nis really easy; namely, when someone else has already done the work of\nwriting down a full truth table for φ. For example, take the truth table\nof (p →¬q) →(q ∨¬p) in Figure 1.8 (page 40). For each line where (p →\n¬q) →(q ∨¬p) computes F we now construct a disjunction of literals. Since\nthere is only one such line, we have only one conjunct ψ1. That conjunct\nbut at least one world does not satisfy ¬q ∨p; the scheme ¬φ ∨ψ is not\nsatisﬁed.\nEquivalences between modal formulas\nDeﬁnition 5.7 1.\nWe say that a set of formulas Γ of basic modal logic seman-\ntically entails a formula ψ of basic modal logic if, in any world x of any model\nM = (W, R, L), we have x ⊩ψ whenever x ⊩φ for all φ ∈Γ. In that case, we\nsay that Γ ⊨ψ holds.\n2.\nWe say that φ and ψ are semantically equivalent if φ ⊨ψ and ψ ⊨φ hold. We\ndenote this by φ ≡ψ.\nNote that φ ≡ψ holds iﬀany world in any model which satisﬁes one\nof them also satisﬁes the other. The deﬁnition of semantic equivalence is\nbased on semantic entailment in the same way as the corresponding one for\nformulas of propositional logic. However, the underlying notion of semantic\nentailment for modal logic is quite diﬀerent, as we will see shortly.\nAny equivalence in propositional logic is also an equivalence in modal\nlogic. Indeed, if we take any equivalence in propositional logic and substi-\ntute the atoms uniformly for any modal logic formula, the result is also\nan equivalence in modal logic. For example, take the equivalent formulas\np →¬q and ¬(p ∧q) and now perform the substitution\np\n\u000e→\n2p ∧(q →p)\nq\n\u000e→\nr →3(q ∨p).\nThe result of this substitution is the pair of formulas\n2p ∧(q →p) →¬(r →3(q ∨p))\n(5.2)\n¬((2p ∧(q →p)) ∧(r →3(q ∨p)))\nwhich are equivalent as formulas of basic modal logic.\nWe have already noticed that 2 is a universal quantiﬁer on accessible\nworlds and 3 is the corresponding existential quantiﬁer. In view of these\nfacts, it is not surprising to ﬁnd that de Morgan rules apply for 2 and 3:\n¬2φ ≡3¬φ and ¬3φ ≡2¬φ.\n314\n5 Modal logics and agents\nMoreover, 2 distributes over ∧and 3 distributes over ∨:\n2(φ ∧ψ) ≡2φ ∧2ψ and 3(φ ∨ψ) ≡3φ ∨3ψ.\nThese equivalences correspond closely to the quantiﬁer equivalences dis-\ncussed in Section 2.3.2. It is also not surprising to ﬁnd that 2 does not\ndistribute over ∨and 3 does not distribute over ∧, i.e. we do not have equiv-",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-2",
                            "title": "Conjunctive Normal Forms and Validity",
                            "content": "φ1, φ2, . . . , φn ⊨ψ holds, we have already shown that ⊨φ1 →(φ2 →(φ3 →\n· · · →(φn →ψ))) follows in step 1 of our completeness proof.\n2\nFor our current purposes, we want to transform formulas into ones which\ndon’t contain →at all and the occurrences of ∧and ∨are conﬁned to\nseparate layers such that validity checks are easy. This is being done by\n1.\nusing the equivalence φ →ψ ≡¬φ ∨ψ to remove all occurrences of →from a\nformula and\n2.\nby specifying an algorithm that takes a formula without any →into a normal\nform (still without →) for which checking validity is easy.\nNaturally, we have to specify which forms of formulas we think of as being\n‘normal.’ Again, there are many such notions, but in this text we study only\ntwo important ones.\nDeﬁnition 1.42 A literal L is either an atom p or the negation of an atom\n¬p. A formula C is in conjunctive normal form (CNF) if it is a conjunction\nof clauses, where each clause D is a disjunction of literals:\nL ::= p | ¬p\nD ::= L | L ∨D\n(1.6)\nC ::= D | D ∧C.\n56\n1 Propositional logic\nExamples of formulas in conjunctive normal form are\n(i)\n(¬q ∨p ∨r) ∧(¬p ∨r) ∧q\n(ii)\n(p ∨r) ∧(¬p ∨r) ∧(p ∨¬r).\nIn the ﬁrst case, there are three clauses of type D: ¬q ∨p ∨r, ¬p ∨r, and q –\nwhich is a literal promoted to a clause by the ﬁrst rule of clauses in (1.6).\nNotice how we made implicit use of the associativity laws for ∧and ∨,\nsaying that φ ∨(ψ ∨η) ≡(φ ∨ψ) ∨η and φ ∧(ψ ∧η) ≡(φ ∧ψ) ∧η, since\nwe omitted some parentheses. The formula (¬(q ∨p) ∨r) ∧(q ∨r) is not in\nCNF since q ∨p is not a literal.\nWhy do we care at all about formulas φ in CNF? One of the reasons\nfor their usefulness is that they allow easy checks of validity which other-\nwise take times exponential in the number of atoms. For example, consider\nthe formula in CNF from above: (¬q ∨p ∨r) ∧(¬p ∨r) ∧q. The semantic\nentailment ⊨(¬q ∨p ∨r) ∧(¬p ∨r) ∧q holds iﬀall three relations\n⊨¬q ∨p ∨r\n⊨¬p ∨r\n⊨q\nhold, by the semantics of ∧. But since all of these formulas are disjunctions\n(¬p ∨¬q ∨r) ∧(p ∨¬q ∨¬r) ∧(p ∨¬q ∨r) ∧(p ∨q ∨¬r).\nIf we don’t have a full truth table at our disposal, but do know the structure\nof φ, then we would like to compute a version of φ in CNF. It should be\nclear by now that a full truth table of φ and an equivalent formula in\nCNF are pretty much the same thing as far as questions about validity are\nconcerned – although the formula in CNF may be much more compact.\n1.5.2 Conjunctive normal forms and validity\nWe have already seen the beneﬁts of conjunctive normal forms in that they\nallow for a fast and easy syntactic test of validity. Therefore, one wonders\nwhether any formula can be transformed into an equivalent formula in CNF.\nWe now develop an algorithm achieving just that. Note that, by Deﬁni-\ntion 1.40, a formula is valid iﬀany of its equivalent formulas is valid. We\nreduce the problem of determining whether any φ is valid to the problem\nof computing an equivalent ψ ≡φ such that ψ is in CNF and checking, via\nLemma 1.43, whether ψ is valid.\n1.5 Normal forms\n59\nBefore we sketch such a procedure, we make some general remarks about\nits possibilities and its realisability constraints. First of all, there could be\nmore or less eﬃcient ways of computing such normal forms. But even more\nso, there could be many possible correct outputs, for ψ1 ≡φ and ψ2 ≡φ\ndo not generally imply that ψ1 is the same as ψ2, even if ψ1 and ψ2 are in\nCNF. For example, take φ\ndef\n= p, ψ1\ndef\n= p and ψ2\ndef\n= p ∧(p ∨q); then convince\nyourself that φ ≡ψ2 holds. Having this ambiguity of equivalent conjunctive\nnormal forms, the computation of a CNF for φ with minimal ‘cost’ (where\n‘cost’ could for example be the number of conjuncts, or the height of φ’s\nparse tree) becomes a very important practical problem, an issue persued in\nChapter 6. Right now, we are content with stating a deterministic algorithm\nwhich always computes the same output CNF for a given input φ.\nThis algorithm, called CNF, should satisfy the following requirements:\n(1)\n(x)\n*\np →(q ∨r), q →s, r →s ⊢p →s\n(y)\n*\n(p ∧q) ∨(p ∧r) ⊢p ∧(q ∨r).\n2. For the sequents below, show which ones are valid and which ones aren’t:\n(a)\n*\n¬p →¬q ⊢q →p\n(b)\n*\n¬p ∨¬q ⊢¬(p ∧q)\n(c)\n*\n¬p, p ∨q ⊢q\n(d)\n*\np ∨q, ¬q ∨r ⊢p ∨r\n(e)\n*\np →(q ∨r), ¬q, ¬r ⊢¬p without using the MT rule\n(f)\n*\n¬p ∧¬q ⊢¬(p ∨q)\n(g)\n*\np ∧¬p ⊢¬(r →q) ∧(r →q)\n(h) p →q, s →t ⊢p ∨s →q ∧t\n(i)\n*\n¬(¬p ∨q) ⊢p.\n3. Prove the validity of the sequents below:\n(a) ¬p →p ⊢p\n(b) ¬p ⊢p →q\n(c) p ∨q, ¬q ⊢p\n(d)\n*\n⊢¬p →(p →(p →q))\n(e) ¬(p →q) ⊢q →p\n(f) p →q ⊢¬p ∨q\n(g) ⊢¬p ∨q →(p →q)\n80\n1 Propositional logic\n(h) p →(q ∨r), ¬q, ¬r |−¬p\n(i) (c ∧n) →t, h ∧¬s, h ∧¬(s ∨c) →p |−(n ∧¬t) →p\n(j) the two sequents implict in (1.2) on page 20\n(k) q |−(p ∧q) ∨(¬p ∧q) using LEM\n(l) ¬(p ∧q) |−¬p ∨¬q\n(m) p ∧q →r |−(p →r) ∨(q →r)\n(n)\n*\np ∧q ⊢¬(¬p ∨¬q)\n(o) ¬(¬p ∨¬q) ⊢p ∧q\n(p) p →q ⊢¬p ∨q possibly without using LEM?\n(q)\n*\n⊢(p →q) ∨(q →r) using LEM\n(r) p →q, ¬p →r, ¬q →¬r ⊢q\n(s) p →q, r →¬t, q →r ⊢p →¬t\n(t) (p →q) →r, s →¬p, t, ¬s ∧t →q ⊢r\n(u) (s →p) ∨(t →q) ⊢(s →q) ∨(t →p)\n(v) (p ∧q) →r, r →s, q ∧¬s ⊢¬p.\n4. Explain why intuitionistic logicians also reject the proof rule PBC.\n5. Prove the following theorems of propositional logic:\n(a)\n*\n((p →q) →q) →((q →p) →p)\n(b) Given a proof for the sequent of the previous item, do you now have a quick\nargument for ((q →p) →p) →((p →q) →q)?\n(c) ((p →q) ∧(q →p)) →((p ∨q) →(p ∧q))\n(d)\n*\n(p →q) →((¬p →q) →q).\n6. Natural deduction is not the only possible formal framework for proofs in propo-\nsitional logic. As an abbreviation, we write Γ to denote any ﬁnite sequence of\nformulas φ1, φ2, . . . , φn (n ≥0). Thus, any sequent may be written as Γ ⊢ψ for\nan appropriate, possibly empty, Γ. In this exercise we propose a diﬀerent notion\nof proof, which states rules for transforming valid sequents into valid sequents.\nFor example, if we have already a proof for the sequent Γ, φ ⊢ψ, then we ob-\ntain a proof of the sequent Γ ⊢φ →ψ by augmenting this very proof with one\nwe cannot simply insert ∧between the two formulas, because the result will\nnot in general be in DNF, so we have to perform lengthy applications of\nthe distributivity rule φ ∧(ψ1 ∨ψ2) ≡(φ ∧ψ1) ∨(φ ∧ψ1). Computing the\nnegation of a DNF formula is also expensive. The DNF formula φ may be\n6.1 Representing boolean functions\n361\nRepresentation of\ntest for\nboolean operations\nboolean functions\ncompact?\nsatisf’ty\nvalidity\n·\n+\n¯\nProp. formulas\noften\nhard\nhard\neasy\neasy\neasy\nFormulas in DNF\nsometimes\neasy\nhard\nhard\neasy\nhard\nFormulas in CNF\nsometimes\nhard\neasy\neasy\nhard\nhard\nOrdered truth tables\nnever\nhard\nhard\nhard\nhard\nhard\nReduced OBDDs\noften\neasy\neasy\nmedium\nmedium\neasy\nFigure 6.1. Comparing efficiency of five representations of boolean formulas.\ny\ny\n0\n1\n0\n0\nx\nFigure 6.2. An example of a binary decision tree.\nquite short, whereas the length of the disjunctive normal form of ¬φ can be\nexponential in the length of φ.\nThe situation for representation in conjunctive normal form is the dual. A\nsummary of these remarks is contained in Figure 6.1 (for now, please ignore\nthe last row).\n6.1.2 Binary decision diagrams\nBinary decision diagrams (BDDs) are another way of representing boolean\nfunctions. A certain class of such diagrams will provide the implementational\nframework for our symbolic model-checking algorithm. Binary decision di-\nagrams were ﬁrst considered in a simpler form called binary decision trees.\nThese are trees whose non-terminal nodes are labelled with boolean vari-\nables x, y, z, . . . and whose terminal nodes are labelled with either 0 or 1.\nEach non-terminal node has two edges, one dashed line and one solid line.\nIn Figure 6.2 you can see such a binary decision tree with two layers of\nvariables x and y.\nDeﬁnition 6.3 Let T be a ﬁnite binary decision tree. Then T determines\na unique boolean function of the variables in non-terminal nodes, in the\nfollowing way. Given an assignment of 0s and 1s to the boolean variables\n362\n6 Binary decision diagrams\n1\n0\ny\nx\ny\n1\n0\ny\n29\n1.3\nPropositional logic as a formal language\n31\n1.4\nSemantics of propositional logic\n36\n1.4.1\nThe meaning of logical connectives\n36\n1.4.2\nMathematical induction\n40\n1.4.3\nSoundness of propositional logic\n45\n1.4.4\nCompleteness of propositional logic\n49\n1.5\nNormal forms\n53\n1.5.1\nSemantic equivalence, satisﬁability and validity\n54\n1.5.2\nConjunctive normal forms and validity\n58\n1.5.3\nHorn clauses and satisﬁability\n65\n1.6\nSAT solvers\n68\n1.6.1\nA linear solver\n69\n1.6.2\nA cubic solver\n72\n1.7\nExercises\n78\n1.8\nBibliographic notes\n91\n2\nPredicate logic\n93\n2.1\nThe need for a richer language\n93\nv\nvi\nContents\n2.2\nPredicate logic as a formal language\n98\n2.2.1\nTerms\n99\n2.2.2\nFormulas\n100\n2.2.3\nFree and bound variables\n102\n2.2.4\nSubstitution\n104\n2.3\nProof theory of predicate logic\n107\n2.3.1\nNatural deduction rules\n107\n2.3.2\nQuantiﬁer equivalences\n117\n2.4\nSemantics of predicate logic\n122\n2.4.1\nModels\n123\n2.4.2\nSemantic entailment\n129\n2.4.3\nThe semantics of equality\n130\n2.5\nUndecidability of predicate logic\n131\n2.6\nExpressiveness of predicate logic\n136\n2.6.1\nExistential second-order logic\n139\n2.6.2\nUniversal second-order logic\n140\n2.7\nMicromodels of software\n141\n2.7.1\nState machines\n142\n2.7.2\nAlma – re-visited\n146\n2.7.3\nA software micromodel\n148\n2.8\nExercises\n157\n2.9\nBibliographic notes\n170\n3\nVeriﬁcation by model checking\n172\n3.1\nMotivation for veriﬁcation\n172\n3.2\nLinear-time temporal logic\n175\n3.2.1\nSyntax of LTL\n175\n3.2.2\nSemantics of LTL\n178\n3.2.3\nPractical patterns of speciﬁcations\n183\n3.2.4\nImportant equivalences between LTL formulas\n184\n3.2.5\nAdequate sets of connectives for LTL\n186\n3.3\nModel checking: systems, tools, properties\n187\n3.3.1\nExample: mutual exclusion\n187\n3.3.2\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-3",
                            "title": "Horn Clauses and Satisfiability",
                            "content": "ciding their satisﬁability. One such example is the class of Horn formu-\nlas; the name ‘Horn’ is derived from the logician A. Horn’s last name.\nWe shortly deﬁne them and give an algorithm for checking their satisﬁ-\nability.\nRecall that the logical constants ⊥(‘bottom’) and ⊤(‘top’) denote an\nunsatisﬁable formula, respectively, a tautology.\nDeﬁnition 1.46 A Horn formula is a formula φ of propositional logic if it\ncan be generated as an instance of H in this grammar:\nP ::= ⊥| ⊤| p\nA ::= P | P ∧A\nC ::= A →P\nH ::= C | C ∧H.\n(1.7)\nWe call each instance of C a Horn clause.\n66\n1 Propositional logic\nHorn formulas are conjunctions of Horn clauses. A Horn clause is an impli-\ncation whose assumption A is a conjunction of propositions of type P and\nwhose conclusion is also of type P. Examples of Horn formulas are\n(p ∧q ∧s →p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13) ∧(⊤→p5) ∧(p5 ∧p11 →⊥).\nExamples of formulas which are not Horn formulas are\n(p ∧q ∧s →¬p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(¬q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 →⊥)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 ∨⊥).\nThe ﬁrst formula is not a Horn formula since ¬p, the conclusion of the\nimplication of the ﬁrst conjunct, is not of type P. The second formula does\nnot qualify since the premise of the implication of the second conjunct,\n¬q ∧r, is not a conjunction of atoms, ⊥, or ⊤. The third formula is not a\nHorn formula since the conclusion of the implication of the ﬁrst conjunct,\np13 ∧p27, is not of type P. The fourth formula clearly is not a Horn formula\nsince it is not a conjunction of implications.\nThe algorithm we propose for deciding the satisﬁability of a Horn for-\nmula φ maintains a list of all occurrences of type P in φ and proceeds like\nthis:\n1.\nIt marks ⊤if it occurs in that list.\n2.\nIf there is a conjunct P1 ∧P2 ∧· · · ∧Pki →P ′ of φ such that all Pj with 1 ≤j ≤\nki are marked, mark P ′ as well and go to 2. Otherwise (= there is no conjunct\nmula φ maintains a list of all occurrences of type P in φ and proceeds like\nthis:\n1.\nIt marks ⊤if it occurs in that list.\n2.\nIf there is a conjunct P1 ∧P2 ∧· · · ∧Pki →P ′ of φ such that all Pj with 1 ≤j ≤\nki are marked, mark P ′ as well and go to 2. Otherwise (= there is no conjunct\nP1 ∧P2 ∧· · · ∧Pki →P ′ such that all Pj are marked) go to 3.\n3.\nIf ⊥is marked, print out ‘The Horn formula φ is unsatisﬁable.’ and stop. Oth-\nerwise, go to 4.\n4.\nPrint out ‘The Horn formula φ is satisﬁable.’ and stop.\nIn these instructions, the markings of formulas are shared by all other oc-\ncurrences of these formulas in the Horn formula. For example, once we\nmark p2 because of one of the criteria above, then all other occurrences\nof p2 are marked as well. We use pseudo code to specify this algorithm\nformally:\n1.5 Normal forms\n67\nfunction HORN (φ):\n/* precondition: φ is a Horn formula */\n/* postcondition: HORN (φ) decides the satisﬁability for φ */\nbegin function\nmark all occurrences of ⊤in φ;\nwhile there is a conjunct P1 ∧P2 ∧· · · ∧Pki →P ′ of φ\nsuch that all Pj are marked but P ′ isn’t do\nmark P ′\nend while\nif ⊥is marked then return ‘unsatisﬁable’ else return ‘satisﬁable’\nend function\nWe need to make sure that this algorithm terminates on all Horn formulas\nφ as input and that its output (= its decision) is always correct.\nTheorem 1.47 The algorithm HORN is correct for the satisﬁability decision\nproblem of Horn formulas and has no more than n + 1 cycles in its while-\nstatement if n is the number of atoms in φ. In particular, HORN always\nterminates on correct input.\nProof: Let us ﬁrst consider the question of program termination. Notice\nthat entering the body of the while-statement has the eﬀect of marking an\nunmarked P which is not ⊤. Since this marking applies to all occurrences\nof P in φ, the while-statement can have at most one more cycle than there\nare atoms in φ.\nSince we guaranteed termination, it suﬃces to show that the answers\n57\nDeﬁnition 1.44 Given a formula φ in propositional logic, we say that φ is\nsatisﬁable if it has a valuation in which is evaluates to T.\nFor example, the formula p ∨q →p is satisﬁable since it computes T if we\nassign T to p. Clearly, p ∨q →p is not valid. Thus, satisﬁability is a weaker\nconcept since every valid formula is by deﬁnition also satisﬁable but not vice\nversa. However, these two notions are just mirror images of each other, the\nmirror being negation.\nProposition 1.45 Let φ be a formula of propositional logic. Then φ is sat-\nisﬁable iﬀ¬φ is not valid.\nProof: First, assume that φ is satisﬁable. By deﬁnition, there exists a\nvaluation of φ in which φ evaluates to T; but that means that ¬φ evaluates\nto F for that same valuation. Thus, ¬φ cannot be valid.\nSecond, assume that ¬φ is not valid. Then there must be a valuation\nof ¬φ in which ¬φ evaluates to F. Thus, φ evaluates to T and is there-\nfore satisﬁable. (Note that the valuations of φ are exactly the valuations of\n¬φ.)\n2\nThis result is extremely useful since it essentially says that we need provide\na decision procedure for only one of these concepts. For example, let’s say\nthat we have a procedure P for deciding whether any φ is valid. We obtain a\ndecision procedure for satisﬁability simply by asking P whether ¬φ is valid.\nIf it is, φ is not satisﬁable; otherwise φ is satisﬁable. Similarly, we may\ntransform any decision procedure for satisﬁability into one for validity. We\nwill encounter both kinds of procedures in this text.\nThere is one scenario in which computing an equivalent formula in CNF\nis really easy; namely, when someone else has already done the work of\nwriting down a full truth table for φ. For example, take the truth table\nof (p →¬q) →(q ∨¬p) in Figure 1.8 (page 40). For each line where (p →\n¬q) →(q ∨¬p) computes F we now construct a disjunction of literals. Since\nthere is only one such line, we have only one conjunct ψ1. That conjunct\nof the proof rule LEM; and the linear SAT solver does not employ any case\nanalysis.)\n4.\n*\nConsider the sequent p ∨q, p →r ⊢r. Determine a DAG which is not satisﬁable\niﬀthis sequent is valid. Tag the DAG’s root node with ‘1: T,’ apply the forcing\nlaws to it, and extract a witness to the DAG’s satisﬁability. Explain in what\nsense this witness serves as an explanation for the fact that p ∨q, p →r ⊢r is\nnot valid.\n5. Explain in what sense the SAT solving technique, as presented in this chapter,\ncan be used to check whether formulas are tautologies.\n6. For φ from (1.10), can one reverse engineer φ from the DAG of T(φ)?\n7. Consider a modiﬁcation of our method which initially tags a DAG’s root node\nwith ‘1: F.’ In that case,\n(a) are the forcing laws still sound? If so, state the invariant.\n(b) what can we say about the formula(s) a DAG represents if\ni. we detect contradictory constraints?\nii. we compute consistent forced constraints for each node?\n8. Given an arbitrary Horn formula φ, compare our linear SAT solver – applied\nto T(φ) –\nto the marking algorithm – applied to φ. Discuss similarities and\ndiﬀerences of these approaches.\n1.8 Bibliographic notes\n91\n9. Consider Figure 1.20 on page 77. Verify that\n(a) its test produces contradictory constraints\n(b) its cubic analysis does not decide satisﬁability, regardless of whether the\ntwo optimizations we described are present.\n10. Verify that the DAG of Figure 1.17 (page 74) is indeed the one obtained for\nT(φ), where φ is the formula in (1.11) on page 73.\n11.\n*\nAn implementor may be concerned with the possibility that the answers to the\ncubic SAT solver may depend on a particular order in which we test unmarked\nnodes or use the rules in Figure 1.14. Give a semi-formal argument for why the\nanalysis results don’t depend on such an order.\n12. Find a formula φ such that our cubic SAT solver cannot decide the satisﬁability\nof T(φ).\n13. Advanced Project: Write a complete implementation of the cubic SAT solver\nof φ – the translation T causes only a linear blow-up – our SAT solver has\na linear running time in the length of the formula. This linearity came with\na price: our linear solver fails for all formulas of the form ¬(φ1 ∧φ2).\n1.6.2 A cubic solver\nWhen we applied our linear SAT solver, we saw two possible outcomes:\nwe either detected contradictory constraints, meaning that no formula rep-\nresented by the DAG is satisﬁable (e.g. Fig. 1.16); or we managed to force\nconsistent constraints on all nodes, in which case all formulas represented by\nthis DAG are satisﬁable with those constraints as a witness (e.g. Fig. 1.13).\nUnfortunately, there is a third possibility: all forced constraints are consis-\ntent with each other, but not all nodes are constrained! We already remarked\nthat this occurs for formulas of the form ¬(φ1 ∧φ2).\n1.6 SAT solvers\n73\np\nq\nr\n¬\n∧\n∧\n∧\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n¬\n1: T\n2: F\n3: T\n4: T\n4: T\n5: F\n6: T\n5: F\n7: T\n8: F\n9: T\n11: F\n10: T\n10: T\n7: T\nits conjunction parent\n– a contradiction\nand ∧frr force F\nits children and\n∧ti force T\nFigure 1.16. The forcing rules, applied to the DAG of Figure 1.15,\ndetect contradictory constraints at the indicated node – implying that\nthe initial constraint ‘1:T’ cannot be realized. Thus, formulas represented\nby this DAG are not satisfiable.\nRecall that checking validity of formulas in CNF is very easy. We already\nhinted at the fact that checking satisﬁability of formulas in CNF is hard. To\nillustrate, consider the formula\n((p ∨(q ∨r)) ∧((p ∨¬q) ∧((q ∨¬r) ∧((r ∨¬p) ∧(¬p ∨(¬q ∨¬r))))))\n(1.11)\nin CNF – based on Example 4.2, page 77, in [Pap94]. Intuitively, this formula\nshould not be satisﬁable. The ﬁrst and last clause in (1.11) ‘say’ that at least\none of p, q, and r are false and true (respectively). The remaining three\nclauses, in their conjunction, ‘say’ that p, q, and r all have the same truth\nvalue. This cannot be satisﬁable, and a good SAT solver should discover",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-5",
                    "title": "SAT Solvers",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-5-subsection-1",
                            "title": "A Linear Solver",
                            "content": "one of p, q, and r are false and true (respectively). The remaining three\nclauses, in their conjunction, ‘say’ that p, q, and r all have the same truth\nvalue. This cannot be satisﬁable, and a good SAT solver should discover\nthis without any user intervention. Unfortunately, our linear SAT solver can\nneither detect inconsistent constraints nor compute constraints for all nodes.\nFigure 1.17 depicts the DAG for T(φ), where φ is as in (1.11); and reveals\n74\n1 Propositional logic\np\nq\nr\n¬\n¬\n¬\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n∧\n∧\n5: T\n6: F\n3: T\n4: F\n5: T\n6: F\n3: F\n4: T\n3: T\n2: T\n1: T\n2: T\n∧\n5: F\n4: T\nFigure 1.17. The DAG for the translation of the formula in (1.11). It\nhas a ∧-spine of length 4 as it is a conjunction of five clauses. Its linear\nanalysis gets stuck: all forced constraints are consistent with each other\nbut several nodes, including all atoms, are unconstrained.\nthat our SAT solver got stuck: no inconsistent constraints were found and\nnot all nodes obtained constraints; in particular, no atom received a mark!\nSo how can we improve this analysis? Well, we can mimic the role of LEM\nto improve the precision of our SAT solver. For the DAG with marks as in\nFigure 1.17, pick any node n that is not yet marked. Then test node n by\nmaking two independent computations:\n1.\ndetermine which temporary marks are forced by adding to the marks in Fig-\nure 1.17 the T mark only to n; and\n2.\ndetermine which temporary marks are forced by adding, again to the marks in\nFigure 1.17, the F mark only to n.\n1.6 SAT solvers\n75\np\nq\nr\n¬\n¬\n¬\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n∧\n∧\n5: T\n6: F\n3: T\n4: F\n5: T\n6: F\n3: F\n4: T\n3: T\n2: T\n1: T\n2: T\n∧\n5: F\n4: T\na:T\nb:F\nc:T\nf:T\ng:F\ni:F\nh:T\nb:F\nc:T\nb:F\nc:T\nc:T\nconstraints\ntemporary T mark\nat test node;\nexplore consequences\ne:F\ng:F\nd:F\nat conjunction\ncontradictory\nFigure 1.18. Marking an unmarked node with T and exploring what\nnew constraints would follow from this. The analysis shows that this\nt = a[0];\n(Inv1(a[0], k) ∧Inv2(t, k))\nAssignment\ns = a[0];\n(Inv1(s, k) ∧Inv2(t, k))\nAssignment\nwhile (k != n) {\n(Inv1(s, k) ∧Inv2(t, k) ∧k ̸= n)\nInvariant Hyp. ∧guard\n(Inv1(min(s, min(t + a[k], a[k])), k + 1)\n∧Inv2(min(t + a[k], a[k]), k + 1))\nImplied (Lemma 4.20)\nt = min(t + a[k], a[k]);\n(Inv1(min(s, t), k + 1) ∧Inv2(t, k + 1))\nAssignment\ns = min(s,t);\n(Inv1(s, k + 1) ∧Inv2(t, k + 1))\nAssignment\nk = k + 1;\n(Inv1(s, k) ∧Inv2(t, k))\nAssignment\n}\n(Inv1(s, k) ∧Inv2(t, k) ∧¬¬(k = n))\nPartial-while\n(Inv1(s, n))\nImplied\nFigure 4.3. Tableau proof for specification S1 of Min Sum.\ncomputation is\nInv2(t, k)\ndef\n= ∀i (0 ≤i < k →t ≤Si,k−1)\n(4.13)\nsaying that t is not greater than the sum of any section ending in a[k −1].\nOur invariant is the conjunction of these formulas, namely\nInv1(s, k) ∧Inv2(t, k).\n(4.14)\nThe completed proof tableau of S1 for Min Sum is given in Figure 4.3. The\ntableau is constructed by\nr Proving that the candidate invariant (4.14) is indeed an invariant. This involves\npushing it upwards through the body of the while-statement and showing that\nwhat emerges follows from the invariant and the boolean guard. This non-trivial\nimplication is shown in the proof of Lemma 4.20.\nr Proving that the invariant, together with the negation of the boolean guard, is\nstrong enough to prove the desired postcondition. This is the last implication of\nthe proof tableau.\n292\n4 Program verification\nr Proving that the invariant is established by the code before the while-statement.\nWe simply push it upwards through the three initial assignments and check that\nthe resulting formula is implied by the precondition of the speciﬁcation, here ⊤.\nAs so often the case, in constructing the tableau, we ﬁnd that two formulas\nmeet; and we have to prove that the ﬁrst one implies the second one. Some-\ntimes this is easy and we can just note the implication in the tableau. For\nexample, we readily see that ⊤implies Inv1(a[0], 1) ∧Inv2(a[0], 1): k being\nof φ – the translation T causes only a linear blow-up – our SAT solver has\na linear running time in the length of the formula. This linearity came with\na price: our linear solver fails for all formulas of the form ¬(φ1 ∧φ2).\n1.6.2 A cubic solver\nWhen we applied our linear SAT solver, we saw two possible outcomes:\nwe either detected contradictory constraints, meaning that no formula rep-\nresented by the DAG is satisﬁable (e.g. Fig. 1.16); or we managed to force\nconsistent constraints on all nodes, in which case all formulas represented by\nthis DAG are satisﬁable with those constraints as a witness (e.g. Fig. 1.13).\nUnfortunately, there is a third possibility: all forced constraints are consis-\ntent with each other, but not all nodes are constrained! We already remarked\nthat this occurs for formulas of the form ¬(φ1 ∧φ2).\n1.6 SAT solvers\n73\np\nq\nr\n¬\n∧\n∧\n∧\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n¬\n1: T\n2: F\n3: T\n4: T\n4: T\n5: F\n6: T\n5: F\n7: T\n8: F\n9: T\n11: F\n10: T\n10: T\n7: T\nits conjunction parent\n– a contradiction\nand ∧frr force F\nits children and\n∧ti force T\nFigure 1.16. The forcing rules, applied to the DAG of Figure 1.15,\ndetect contradictory constraints at the indicated node – implying that\nthe initial constraint ‘1:T’ cannot be realized. Thus, formulas represented\nby this DAG are not satisfiable.\nRecall that checking validity of formulas in CNF is very easy. We already\nhinted at the fact that checking satisﬁability of formulas in CNF is hard. To\nillustrate, consider the formula\n((p ∨(q ∨r)) ∧((p ∨¬q) ∧((q ∨¬r) ∧((r ∨¬p) ∧(¬p ∨(¬q ∨¬r))))))\n(1.11)\nin CNF – based on Example 4.2, page 77, in [Pap94]. Intuitively, this formula\nshould not be satisﬁable. The ﬁrst and last clause in (1.11) ‘say’ that at least\none of p, q, and r are false and true (respectively). The remaining three\nclauses, in their conjunction, ‘say’ that p, q, and r all have the same truth\nvalue. This cannot be satisﬁable, and a good SAT solver should discover\ngramming language you used a list of features of its software development envi-\nronment (compiler, editor, linker, run-time environment etc) that may improve\nthe likelihood that your programs work correctly. Try to rate the eﬀectiveness of\neach such feature.\n2. Repeat the previous exercise by listing and rating features that may decrease\nthe likelihood of procuding correct and reliable programs.\nExercises 4.2\n1.\n*\nIn what circumstances would if (B) {C1} else {C2} fail to terminate?\n2.\n*\nA familiar command missing from our language is the for-statement. It may be\nused to sum the elements in an array, for example, by programming as follows:\ns = 0;\nfor (i = 0; i <= max; i = i+1) {\ns = s + a[i];\n}\nAfter performing the initial assignment s = 0, this executes i = 0 ﬁrst, then\nexecutes the body s = s + a[i] and the incrementation i = i + 1 continually\nuntil i <= max becomes false. Explain how for (C1; B; C2) {C3} can be deﬁned\nas a derived program in our core language.\n3. Suppose that you need a language construct repeat {C} until (B) which re-\npeats C until B becomes true, i.e.\ni. executes C in the current state of the store;\nii. evaluates B in the resulting state of the store;\niii. if B is false, the program resumes with (i); otherwise, the program\nrepeat {C} until (B) terminates.\nThis construct sometimes allows more elegant code than a corresponding while-\nstatement.\n300\n4 Program verification\n(a) Deﬁne repeat C until B as a derived expression using our core language.\n(b) Can one deﬁne every repeat expression in our core language extended with\nfor-statements? (You might need the empty command skip which does noth-\ning.)\nExercises 4.3\n1. For any store l as in Example 4.4 (page 264), determine which of the relations\nbelow hold; justify your answers:\n(a)\n*\nl ⊨(x + y < z) →¬(x ∗y = z)\n(b) l ⊨∀u (u < y) ∨(u ∗z < y ∗z)\n(c)\n*\nl ⊨x + y −z < x ∗y ∗z.\n2.\n*\nFor any φ, ψ and P explain why ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever the relation\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds.\nv op x = 1 or v op x = 0 for all values of x. We say that v is a controlling value\nif it is a left- and right-controlling value.\n(a) Deﬁne the notion of a right-controlling value.\n(b) Give examples of operations with controlling values.\n(c) Describe informally how apply can be optimised when op has a controlling\nvalue.\n(d) Could one still do some optimisation if op had only a left- or right-controlling\nvalue?\n12. We showed that the worst-time complexity of apply is O(|Bf| · |Bg|). Show that\nthis upper bound is hard, i.e. it cannot be improved:\n(a) Consider the functions f(x1, x2, . . . , x2n+2m)\ndef\n= x1 · xn+m+1 + · · · + xn ·\nx2n+m and g(x1, x2, . . . , x2n+2m)\ndef\n= xn+1 · x2n+m+1 + · · · + xn+m · x2n+2m\nwhich are in sum-of-product form. Compute the sum-of-product form of\nf + g.\n(b) Choose the ordering [x1, x2, . . . , x2n+2m] and argue that the OBDDs Bf\nand Bg have 2n+1 and 2m+1 edges, respectively.\n(c) Use the result from part (a) to conclude that Bf+g has 2n+m+1 edges, i.e.\n0.5 · |Bf| · |Bg|.\nExercises 6.8\n1. Let f be the reduced OBDD represented in Figure 6.5(b) (page 364). Compute\nthe reduced OBDD for the restrictions:\n(a) f[0/x]\n(b)\n*\nf[1/x]\n6.5 Exercises\n405\n(c) f[1/y]\n(d)\n*\nf[0/z].\n2.\n*\nSuppose that we intend to modify the algorithm restrict so that it is capable\nof computing reduced OBDDs for a general composition f[g/x].\n(a) Generalise Equation (6.1) to reﬂect the intuitive meaning of the operation\n[g/x].\n(b) What fact about OBDDs causes problems for computing this composition\ndirectly?\n(c) How can we compute this composition given the algorithms discussed so far?\n3. We deﬁne read-1-BDDs as BDDs B where each boolean variable occurs at most\nonce on any evaluation path of B. In particular, read-1-BDDs need not possess\nan ordering on their boolean variables. Clearly, every OBDD is a read-1-BDD;\nbut not every read-1-BDD is an OBDD (see Figure 6.10). In Figure 6.18 we see\na BDD which is not a read-1-BDD; the path for (x, y, z) ⇒(1, 0, 1) ‘reads’ the",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-5-subsection-2",
                            "title": "A Cubic Solver",
                            "content": "nodes or use the rules in Figure 1.14. Give a semi-formal argument for why the\nanalysis results don’t depend on such an order.\n12. Find a formula φ such that our cubic SAT solver cannot decide the satisﬁability\nof T(φ).\n13. Advanced Project: Write a complete implementation of the cubic SAT solver\ndescribed in Section 1.6.2. It should read formulas from the keyboard or a ﬁle;\nshould assume right-associativity of ∨, ∧, and →(respectively); compute the\nDAG of T(φ); perform the cubic SAT solver next. Think also about including\nappropriate user output, diagnostics, and optimizations.\n14. Show that our cubic SAT solver speciﬁed in this section\n(a) terminates on all syntactically correct input;\n(b) satisﬁes the invariant (1.9) after the ﬁrst permanent marking;\n(c) preserves (1.9) for all permanent markings it makes;\n(d) computes only correct satisﬁability witnesses;\n(e) computes only correct ‘not satisﬁable’ replies; and\n(f) remains to be correct under the two modiﬁcations described on page 77 for\nhandling results of a node’s two test runs.\n1.8 Bibliographic notes\nLogic has a long history stretching back at least 2000 years, but the truth-\nvalue semantics of propositional logic presented in this and every logic text-\nbook today was invented only about 160 years ago, by G. Boole [Boo54].\nBoole used the symbols + and · for disjunction and conjunction.\nNatural deduction was invented by G. Gentzen [Gen69], and further de-\nveloped by D. Prawitz [Pra65]. Other proof systems existed before then, no-\ntably axiomatic systems which present a small number of axioms together\nwith the rule modus ponens (which we call →e). Proof systems often present\nas small a number of axioms as possible; and only for an adequate set of con-\nnectives such as →and ¬. This makes them hard to use in practice. Gentzen\nimproved the situation by inventing the idea of working with assumptions\n(used by the rules →i, ¬i and ∨e) and by treating all the connectives sepa-\nrately.\n92\n1 Propositional logic\nFinally, let’s consider a really big integer:\n32498723462509735034567279652376420563047563456356347563\\\\\n96598734085384756074086560785607840745067340563457640875\\\\\n62984573756306537856405634056245634578692825623542135761\\\\\n9519765129854122965424895465956457\nwhere \\\\ denotes concatenation of digits. Although this is a very large num-\nber indeed, our program Collatz requires only 4940 iterations to terminate.\nUnfortunately, nobody knows a suitable variant for this program that could\nprove the validity of ⊢tot\n\u0001\n0 < x\n\u0002\nCollatz\n\u0001\n⊤\n\u0002\n. Observe how the use of ⊤as\na postcondition emphasizes that this Hoare triple is merely concerned about\nprogram termination as such. Ironically, there is also no known initial value\nof x greater than 0 for which Collatz doesn’t terminate. In fact, things are\neven subtler than they may appear: if we replace 3*c + 1 in Collatz with a\ndiﬀerent such linear expression in c, the program may not terminate despite\nmeeting the precondition 0 < x; see exercise 6 on page 303.\n4.5 Programming by contract\nFor a valid sequent ⊢tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n, the triple\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nmay be seen as a\ncontract between a supplier and a consumer of a program P. The supplier\ninsists that consumers run P only on initial state satisﬁes φ. In that case,\nthe supplier promises the consumer that the ﬁnal state of that run satisﬁes\nψ. For a valid ⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n, the latter guarantee applies only when a run\nterminates.\nFor imperative programming, the validation of Hoare triples can be in-\nterpreted as the validation of contracts for method or procedure calls. For\nexample, our program fragment Fac1 may be the ... in the method body\nint factorial (x: int) { ... return y; }\nThe code for this method can be annotated with its contractual assumptions\nand guarantees. These annotations can be checked oﬀ-line by humans, during\ncompile-time or even at run-time in languages such as Eiﬀel. A possible\nformat for such contracts for the method factorial is given in Figure 4.4.\nz = z + x;\nx = x - 1;\n}\nThis program adds up the ﬁrst x integers and stores the result in z.\nThus,\n\u0001\nx = 3\n\u0002\nSum\n\u0001\nz = 6\n\u0002\n,\n\u0001\nx = 8\n\u0002\nSum\n\u0001\nz = 36\n\u0002\netc. We know from The-\norem 1.31 on page 41 that 1 + 2 + · · · + x = x(x + 1)/2 for all x ≥0, so\n4.3 Proof calculus for partial correctness\n269\nwe would like to express, as a Hoare triple, that the value of z upon\ntermination is x0(x0 + 1)/2 where x0 is the initial value of x. Thus, we write\n\u0001\nx = x0 ∧x ≥0\n\u0002\nSum\n\u0001\nz = x0(x0 + 1)/2\n\u0002\n.\nVariables like x0 in these examples are called logical variables, because they\noccur only in the logical formulas that constitute the precondition and post-\ncondition; they do not occur in the code to be veriﬁed. The state of the\nsystem gives a value to each program variable, but not for the logical vari-\nables. Logical variables take a similar role to the dummy variables of the\nrules for ∀i and ∃e in Chapter 2.\nDeﬁnition 4.10 For a Hoare triple\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n, its set of logical variables\nare those variables that are free in φ or ψ; and don’t occur in P.\n4.3 Proof calculus for partial correctness\nThe proof calculus which we now present goes back to R. Floyd and C.\nA. R. Hoare. In the next subsection, we specify proof rules for each of the\ngrammar clauses for commands. We could go on to use these proof rules\ndirectly, but it turns out to be more convenient to present them in a diﬀerent\nform, suitable for the construction of proofs known as proof tableaux. This\nis what we do in the subsection following the next one.\n4.3.1 Proof rules\nThe proof rules for our calculus are given in Figure 4.1. They should be\ninterpreted as rules that allow us to pass from simple assertions of the form\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nto more complex ones. The rule for assignment is an axiom as\nit has no premises. This allows us to construct some triples out of noth-\ning, to get the proof going. Complete proofs are trees, see page 274 for an\nexample.\nComposition.\nGiven speciﬁcations for the program fragments C1 and C2,\nsay\n\u0001\nφ\npairs C\ndef\n= ((1, 101), (10, 00), (011, 11)) so\ns1\ndef\n= 1\ns2\ndef\n= 10\ns3\ndef\n= 011\nt1\ndef\n= 101\nt2\ndef\n= 00\nt3\ndef\n= 11.\nA solution to the problem is the sequence of indices (1, 3, 2, 3) since s1s3s2s3\nand t1t3t2t3 both equal 101110011. Maybe you think that this problem must\nsurely be solvable; but remember that a computational solution would have\n2.5 Undecidability of predicate logic\n133\nto be a program that solves all such problem instances. Things get a bit\ntougher already if we look at this (solvable) problem:\ns1\ndef\n= 001\ns2\ndef\n= 01\ns3\ndef\n= 01\ns4\ndef\n= 10\nt1\ndef\n= 0\nt2\ndef\n= 011\nt3\ndef\n= 101\nt4\ndef\n= 001\nwhich you are invited to solve by hand, or by writing a program for this\nspeciﬁc instance.\nNote that the same number can occur in the sequence of indices, as hap-\npened in the ﬁrst example in which 3 occurs twice. This means that the\nsearch space we are dealing with is inﬁnite, which should give us some indi-\ncation that the problem is unsolvable. However, we do not formally prove it\nin this book. The proof of the following theorem is due to the mathematician\nA. Church.\nTheorem 2.22 The decision problem of validity in predicate logic is unde-\ncidable: no program exists which, given any φ, decides whether ⊨φ.\nPROOF: As said before, we pretend that validity is decidable for predicate\nlogic and thereby solve the (insoluble) Post correspondence problem. Given\na correspondence problem instance C:\ns1 s2 . . . sk\nt1 t2 . . . tk\nwe need to be able to construct, within ﬁnite space and time and uniformly\nso for all instances, some formula φ of predicate logic such that ⊨φ holds\niﬀthe correspondence problem instance C above has a solution.\nAs function symbols, we choose a constant e and two function symbols\nf0 and f1 each of which requires one argument. We think of e as the empty\nstring, or word, and f0 and f1 symbolically stand for concatenation with 0,\nrespectively 1. So if b1b2 . . . bl is a binary string of bits, we can code that up\none of p, q, and r are false and true (respectively). The remaining three\nclauses, in their conjunction, ‘say’ that p, q, and r all have the same truth\nvalue. This cannot be satisﬁable, and a good SAT solver should discover\nthis without any user intervention. Unfortunately, our linear SAT solver can\nneither detect inconsistent constraints nor compute constraints for all nodes.\nFigure 1.17 depicts the DAG for T(φ), where φ is as in (1.11); and reveals\n74\n1 Propositional logic\np\nq\nr\n¬\n¬\n¬\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n∧\n∧\n5: T\n6: F\n3: T\n4: F\n5: T\n6: F\n3: F\n4: T\n3: T\n2: T\n1: T\n2: T\n∧\n5: F\n4: T\nFigure 1.17. The DAG for the translation of the formula in (1.11). It\nhas a ∧-spine of length 4 as it is a conjunction of five clauses. Its linear\nanalysis gets stuck: all forced constraints are consistent with each other\nbut several nodes, including all atoms, are unconstrained.\nthat our SAT solver got stuck: no inconsistent constraints were found and\nnot all nodes obtained constraints; in particular, no atom received a mark!\nSo how can we improve this analysis? Well, we can mimic the role of LEM\nto improve the precision of our SAT solver. For the DAG with marks as in\nFigure 1.17, pick any node n that is not yet marked. Then test node n by\nmaking two independent computations:\n1.\ndetermine which temporary marks are forced by adding to the marks in Fig-\nure 1.17 the T mark only to n; and\n2.\ndetermine which temporary marks are forced by adding, again to the marks in\nFigure 1.17, the F mark only to n.\n1.6 SAT solvers\n75\np\nq\nr\n¬\n¬\n¬\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n∧\n∧\n∧\n5: T\n6: F\n3: T\n4: F\n5: T\n6: F\n3: F\n4: T\n3: T\n2: T\n1: T\n2: T\n∧\n5: F\n4: T\na:T\nb:F\nc:T\nf:T\ng:F\ni:F\nh:T\nb:F\nc:T\nb:F\nc:T\nc:T\nconstraints\ntemporary T mark\nat test node;\nexplore consequences\ne:F\ng:F\nd:F\nat conjunction\ncontradictory\nFigure 1.18. Marking an unmarked node with T and exploring what\nnew constraints would follow from this. The analysis shows that this",
                            "children": []
                        }
                    ]
                }
            ]
        },
        {
            "id": "chapter-1",
            "title": "Predicate Logic",
            "content": null,
            "children": [
                {
                    "id": "chapter-1-section-1",
                    "title": "The Need for a Richer Language",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-2",
                    "title": "Predicate Logic as a Formal Language",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-2-subsection-1",
                            "title": "Terms",
                            "content": "r more complex terms are built from function symbols using as many previously\nbuilt terms as required by such function symbols; and\nr the notion of terms is dependent on the set F. If you change it, you change the\nset of terms.\n100\n2 Predicate logic\nExample 2.2 Suppose n, f and g are function symbols, respectively\nnullary, unary and binary. Then g(f(n), n) and f(g(n, f(n))) are terms, but\ng(n) and f(f(n), n) are not (they violate the arities). Suppose 0, 1, . . . are\nnullary, s is unary, and +, −, and ∗are binary. Then ∗(−(2, +(s(x), y)), x)\nis a term, whose parse tree is illustrated in Figure 2.14 (page 159). Usually,\nthe binary symbols are written inﬁx rather than preﬁx; thus, the term is\nusually written (2 −(s(x) + y)) ∗x.\n2.2.2 Formulas\nThe choice of sets P and F for predicate and function symbols, respectively,\nis driven by what we intend to describe. For example, if we work on a\ndatabase representing relations between our kin we might want to consider\nP = {M, F, S, D}, referring to being male, being female, being a son of . . .\nand being a daughter of . . . . Naturally, F and M are unary predicates (they\ntake one argument) whereas D and S are binary (taking two). Similarly, we\nmay deﬁne F = {mother-of, father-of}.\nWe already know what the terms over F are. Given that knowledge, we\ncan now proceed to deﬁne the formulas of predicate logic.\nDeﬁnition 2.3 We deﬁne the set of formulas over (F, P) inductively, using\nthe already deﬁned set of terms over F:\nr If P ∈P is a predicate symbol of arity n ≥1, and if t1, t2, . . . , tn are terms over\nF, then P(t1, t2, . . . , tn) is a formula.\nr If φ is a formula, then so is (¬φ).\nr If φ and ψ are formulas, then so are (φ ∧ψ), (φ ∨ψ) and (φ →ψ).\nr If φ is a formula and x is a variable, then (∀x φ) and (∃x φ) are formulas.\nr Nothing else is a formula.\nNote how the arguments given to predicates are always terms. This can also\nbe seen in the Backus Naur form (BNF) for predicate logic:\nexamples, as are variables such as x and v. Function symbols also allow us\nto refer to objects: thus, m(a) and g(x, y) are also objects. Expressions in\npredicate logic which denote objects are called terms.\nThe other sort of things in predicate logic denotes truth values; expres-\nsions of this kind are formulas: Y (x, m(x)) is a formula, though x and m(x)\nare terms.\nA predicate vocabulary consists of three sets: a set of predicate symbols\nP, a set of function symbols F and a set of constant symbols C. Each pred-\nicate symbol and each function symbol comes with an arity, the number of\narguments it expects. In fact, constants can be thought of as functions which\ndon’t take any arguments (and we even drop the argument brackets) – there-\nfore, constants live in the set F together with the ‘true’ functions which do\ntake arguments. From now on, we will drop the set C, since it is convenient to\ndo so, and stipulate that constants are 0-arity, so-called nullary, functions.\n2.2.1 Terms\nThe terms of our language are made up of variables, constant symbols\nand functions applied to those. Functions may be nested, as in m(m(x))\nor g(m(a), c): the grade obtained by Andy’s mother in the course c.\nDeﬁnition 2.1 Terms are deﬁned as follows.\nr Any variable is a term.\nr If c ∈F is a nullary function, then c is a term.\nr If t1, t2, . . . , tn are terms and f ∈F has arity n > 0, then f(t1, t2, . . . , tn) is a\nterm.\nr Nothing else is a term.\nIn Backus Naur form we may write\nt ::= x | c | f(t, . . . , t)\nwhere x ranges over a set of variables var, c over nullary function symbols\nin F, and f over those elements of F with arity n > 0.\nIt is important to note that\nr the ﬁrst building blocks of terms are constants (nullary functions) and variables;\nr more complex terms are built from function symbols using as many previously\nbuilt terms as required by such function symbols; and\nr the notion of terms is dependent on the set F. If you change it, you change the\nset of terms.\n100\npath in its parse tree, as in Deﬁnition 1.32. List all variable-free terms over\nF of height less than 4.\n2. Draw the parse tree of the term (2 −s(x)) + (y ∗x), considering that −, +, and\n∗are used in inﬁx in this term. Compare your solution with the parse tree in\nFigure 2.14.\n3. Which of the following strings are formulas in predicate logic? Specify a reason\nfor failure for strings which aren’t, draw parse trees of all strings which are.\n(a)\n*\nLet m be a constant, f a function symbol with one argument and S and B\ntwo predicate symbols, each with two arguments:\ni. S(m, x)\nii. B(m, f(m))\niii. f(m)\niv. B(B(m, x), y)\nv. S(B(m), z)\nvi. (B(x, y) →(∃z S(z, y)))\nvii. (S(x, y) →S(y, f(f(x))))\nviii. (B(x) →B(B(x))).\n(b) Let c and d be constants, f a function symbol with one argument, g a function\nsymbol with two arguments and h a function symbol with three arguments.\nFurther, P and Q are predicate symbols with three arguments:\n160\n2 Predicate logic\ni. ∀x P(f(d), h(g(c, x), d, y))\nii. ∀x P(f(d), h(P(x, y), d, y))\niii. ∀x Q(g(h(x, f(d), x), g(x, x)), h(x, x, x), c)\niv. ∃z (Q(z, z, z) →P(z))\nv. ∀x ∀y (g(x, y) →P(x, y, x))\nvi. Q(c, d, c).\n4. Let φ be ∃x (P(y, z) ∧(∀y (¬Q(y, x) ∨P(y, z)))), where P and Q are predicate\nsymbols with two arguments.\n(a)\n*\nDraw the parse tree of φ.\n(b)\n*\nIdentify all bound and free variable leaves in φ.\n(c) Is there a variable in φ which has free and bound occurrences?\n(d)\n*\nConsider the terms w (w is a variable), f(x) and g(y, z), where f and g are\nfunction symbols with arity 1 and 2, respectively.\ni. Compute φ[w/x], φ[w/y], φ[f(x)/y] and φ[g(y, z)/z].\nii. Which of w, f(x) and g(y, z) are free for x in φ?\niii. Which of w, f(x) and g(y, z) are free for y in φ?\n(e) What is the scope of ∃x in φ?\n(f)\n*\nSuppose that we change φ to ∃x (P(y, z) ∧(∀x (¬Q(x, x) ∨P(x, z)))). What\nis the scope of ∃x now?\n5. (a) Let P be a predicate symbol with arity 3. Draw the parse tree of ψ\ndef\n=\n¬(∀x ((∃y P(x, y, z)) ∧(∀z P(x, y, z)))).\nreplaced by every student’s name in turn. Similarly, when trying to codify\na sentence having to do with the execution of a program, it would be rather\nlaborious to have to write down every state of the computer. Therefore,\nwe employ the concept of a variable. Variables are written u, v, w, x, y, z, . . .\nor x1, y3, u5, . . . and can be thought of as place holders for concrete values\n(like a student, or a program state). Using variables, we can now specify the\nmeanings of S, I and Y more formally:\nS(x) :\nx is a student\nI(x) :\nx is an instructor\nY (x, y) :\nx is younger than y.\nNote that the names of the variables are not important, provided that we\nuse them consistently. We can state the intended meaning of I by writing\nI(y) :\ny is an instructor\nor, equivalently, by writing\nI(z) :\nz is an instructor.\nVariables are mere place holders for objects. The availability of variables is\nstill not suﬃcient for capturing the essence of the example sentence above.\nWe need to convey the meaning of ‘Every student x is younger than some\ninstructor y.’ This is where we need to introduce quantiﬁers ∀(read: ‘for\nall’) and ∃(read: ‘there exists’ or ‘for some’) which always come attached\nto a variable, as in ∀x (‘for all x’) or in ∃z (‘there exists z’, or ‘there is some\nz’). Now we can write the example sentence in an entirely symbolic way as\n∀x (S(x) →(∃y (I(y) ∧Y (x, y)))).\n2.1 The need for a richer language\n95\nActually, this encoding is rather a paraphrase of the original sentence. In\nour example, the re-translation results in\nFor every x, if x is a student, then there is some y which is an\ninstructor such that x is younger than y.\nDiﬀerent predicates can have a diﬀerent number of arguments. The predi-\ncates S and I have just one (they are called unary predicates), but predicate\nY requires two arguments (it is called a binary predicate). Predicates with\nany ﬁnite number of arguments are possible in predicate logic.\nAnother example is the sentence\nNot all birds can ﬂy.\nf0 and f1 each of which requires one argument. We think of e as the empty\nstring, or word, and f0 and f1 symbolically stand for concatenation with 0,\nrespectively 1. So if b1b2 . . . bl is a binary string of bits, we can code that up\nas the term fbl(fbl−1 . . . (fb2(fb1(e))) . . . ). Note that this coding spells that\nword backwards. To facilitate reading those formulas, we abbreviate terms\nlike fbl(fbl−1 . . . (fb2(fb1(t))) . . . ) by fb1b2...bl(t).\nWe also require a predicate symbol P which expects two arguments.\nThe intended meaning of P(s, t) is that there is some sequence of indices\n(i1, i2, . . . , im) such that s is the term representing si1si2 . . . sim and t rep-\nresents ti1ti2 . . . tim. Thus, s constructs a string using the same sequence of\nindices as does t; only s uses the si whereas t uses the ti.\n134\n2 Predicate logic\nOur sentence φ has the coarse structure φ1 ∧φ2 →φ3 where we set\nφ1\ndef\n=\nk\u0001\ni=1\nP(fsi(e), fti(e))\nφ2\ndef\n= ∀v ∀w\n\u0002\nP(v, w) →\nk\u0001\ni=1\nP(fsi(v), fti(w))\n\u0003\nφ3\ndef\n= ∃z P(z, z) .\nOur claim is ⊨φ holds iﬀthe Post correspondence problem C has a solution.\nFirst, let us assume that ⊨φ holds. Our strategy is to ﬁnd a model for\nφ which tells us there is a solution to the correspondence problem C simply\nby inspecting what it means for φ to satisfy that particular model. The\nuniverse of concrete values A of that model is the set of all ﬁnite, binary\nstrings (including the empty string denoted by ϵ).\nThe interpretation eM of the constant e is just that empty string ϵ. The\ninterpretation of f0 is the unary function fM\n0\nwhich appends a 0 to a given\nstring, fM\n0 (s)\ndef\n= s0; similarly, fM\n1 (s)\ndef\n= s1 appends a 1 to a given string.\nThe interpretation of P on M is just what we expect it to be:\nP M def\n= {(s, t) | there is a sequence of indices (i1, i2, . . . , im) such that\ns equals si1si2 . . . sim and t equals ti1ti2 . . . tim}\nwhere s and t are binary strings and the si and ti are the data of the",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-2",
                            "title": "Formulas",
                            "content": "since R(x, y). The latter and R(y, z) then render z ⊩p, a contradiction. Thus,\nwe must have R(x, z).\n2\nThis picture is completed in Table 5.12, which shows, for a collection of\nformulas, the corresponding property of R. What this table means mathe-\nmatically is the following:\nTheorem 5.14 A frame F = (W, R) satisﬁes a formula scheme in Table\n5.12 iﬀR has the corresponding property in that table.\nThe names of the formulas in the left-hand column are historical, but have\nstuck and are still used widely in books.\n326\n5 Modal logics and agents\n5.3.4 Some modal logics\nThe logic engineering approach of this section encourages us to design logics\nby picking and choosing a set L of formula schemes, according to the ap-\nplication at hand. Some examples of formula schemes that we may wish to\nconsider for a given application are those in Tables 5.7 and 5.12.\nDeﬁnition 5.15 Let L be a set of formula schemes of modal logic and\nΓ ∪{ψ} a set of formulas of basic modal logic.\n1.\nThe set Γ is closed under substitution instances iﬀwhenever φ ∈Γ, then any\nsubstitution instance of φ is also in Γ.\n2.\nLet Lc be the smallest set containing all instances of L.\n3.\nΓ semantically entails ψ in L iﬀΓ ∪Lc semantically entails ψ in basic modal\nlogic. In that case, we say that Γ ⊨L ψ holds.\nThus, we have Γ ⊨L ψ if every Kripke model and every world x satisfying\nΓ ∪Lc therein also satisﬁes ψ. Note that for L = ∅this deﬁnition is consistent\nwith the one of Deﬁnition 5.7, since we then have Γ ∪Lc = Γ. For logic\nengineering, we require that L be\nr closed under substitution instances; otherwise, we won’t be able to characterize\nLc in terms of properties of the accessibility relation; and\nr consistent in that there is a frame F such that F ⊨φ holds for all φ ∈L; oth-\nerwise, Γ ⊨L ψ holds for all Γ and ψ! In most applications of logic engineering,\nconsistency is easy to establish.\nWe now study a few important modal logics that extend basic modal logic\nwith a consistent set of formula schemes L.\nThis activity is essentially the construction of one line in the truth table of\n(p ∨¬q) →(q →p). How can we evaluate formulas in predicate logic, e.g.\n∀x ∃y ((P(x) ∨¬Q(y)) →(Q(x) →P(y)))\nwhich ‘enriches’ the formula of propositional logic above? Could we simply\nassume truth values for P(x), Q(y), Q(x) and P(y) and compute a truth\nvalue as before? Not quite, since we have to reﬂect the meaning of the\nquantiﬁers ∀x and ∃y, their dependences and the actual parameters of P\nand Q – a formula ∀x ∃y R(x, y) generally means something else other than\n∃y ∀x R(x, y); why? The problem is that variables are place holders for any,\nor some, unspeciﬁed concrete values. Such values can be of almost any kind:\nstudents, birds, numbers, data structures, programs and so on.\n124\n2 Predicate logic\nThus, if we encounter a formula ∃y ψ, we try to ﬁnd some instance of\ny (some concrete value) such that ψ holds for that particular instance of\ny. If this succeeds (i.e. there is such a value of y for which ψ holds), then\n∃y ψ evaluates to T; otherwise (i.e. there is no concrete value of y which\nrealises ψ) it returns F. Dually, evaluating ∀x ψ amounts to showing that\nψ evaluates to T for all possible values of x; if this is successful, we know\nthat ∀x ψ evaluates to T; otherwise (i.e. there is some value of x such that\nψ computes F) it returns F. Of course, such evaluations of formulas require\na ﬁxed universe of concrete values, the things we are, so to speak, talking\nabout. Thus, the truth value of a formula in predicate logic depends on, and\nvaries with, the actual choice of values and the meaning of the predicate and\nfunction symbols involved.\nIf variables can take on only ﬁnitely many values, we can write a program\nthat evaluates formulas in a compositional way. If the root node of φ is ∧,\n∨, →or ¬, we can compute the truth value of φ by using the truth table of\nthe respective logical connective and by computing the truth values of the\nr If φ is a formula and x is a variable, then (∀x φ) and (∃x φ) are formulas.\nr Nothing else is a formula.\nNote how the arguments given to predicates are always terms. This can also\nbe seen in the Backus Naur form (BNF) for predicate logic:\nφ ::= P(t1, t2, . . . , tn) | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (∀x φ) | (∃x φ)\n(2.2)\nwhere P ∈P is a predicate symbol of arity n ≥1, ti are terms over F and x\nis a variable. Recall that each occurrence of φ on the right-hand side of the\n::= stands for any formula already constructed by these rules. (What role\ncould predicate symbols of arity 0 play?)\n2.2 Predicate logic as a formal language\n101\n∀x\n∧\n→\nS\nP\nQ\nx\ny\nx\nx\nFigure 2.1. A parse tree of a predicate logic formula.\nConvention 2.4 For convenience, we retain the usual binding priorities\nagreed upon in Convention 1.3 and add that ∀y and ∃y bind like ¬. Thus,\nthe order is:\nr ¬, ∀y and ∃y bind most tightly;\nr then ∨and ∧;\nr then →, which is right-associative.\nWe also often omit brackets around quantiﬁers, provided that doing so in-\ntroduces no ambiguities.\nPredicate logic formulas can be represented by parse trees. For example,\nthe parse tree in Figure 2.1 represents the formula ∀x ((P(x) →Q(x)) ∧\nS(x, y)).\nExample 2.5 Consider translating the sentence\nEvery son of my father is my brother.\ninto predicate logic. As before, the design choice is whether we represent\n‘father’ as a predicate or as a function symbol.\n1.\nAs a predicate. We choose a constant m for ‘me’ or ‘I,’ so m is a term, and we\nchoose further {S, F, B} as the set of predicates with meanings\n102\n2 Predicate logic\nS(x, y) :\nx is a son of y\nF(x, y) :\nx is the father of y\nB(x, y) :\nx is a brother of y.\nThen the symbolic encoding of the sentence above is\n∀x ∀y (F(x, m) ∧S(y, x) →B(y, m))\n(2.3)\nsaying: ‘For all x and all y, if x is a father of m and if y is a son of x, then y is\na brother of m.’\n2.\nAs a function. We keep m, S and B as above and write f for the function which,\nIf variables can take on only ﬁnitely many values, we can write a program\nthat evaluates formulas in a compositional way. If the root node of φ is ∧,\n∨, →or ¬, we can compute the truth value of φ by using the truth table of\nthe respective logical connective and by computing the truth values of the\nsubtree(s) of that root, as discussed in Chapter 1. If the root is a quantiﬁer,\nwe have sketched above how to proceed. This leaves us with the case of the\nroot node being a predicate symbol P (in propositional logic this was an\natom and we were done already). Such a predicate requires n arguments\nwhich have to be terms t1, t2, . . . , tn. Therefore, we need to be able to assign\ntruth values to formulas of the form P(t1, t2, . . . , tn).\nFor formulas P(t1, t2, . . . , tn), there is more going on than in the case of\npropositional logic. For n = 2, the predicate P could stand for something\nlike ‘the number computed by t1 is less than, or equal to, the number com-\nputed by t2.’ Therefore, we cannot just assign truth values to P directly\nwithout knowing the meaning of terms. We require a model of all function\nand predicate symbols involved. For example, terms could denote real num-\nbers and P could denote the relation ‘less than or equal to’ on the set of real\nnumbers.\nDeﬁnition 2.14 Let F be a set of function symbols and P a set of predicate\nsymbols, each symbol with a ﬁxed number of required arguments. A model\nM of the pair (F, P) consists of the following set of data:\n1.\nA non-empty set A, the universe of concrete values;\n2.\nfor each nullary function symbol f ∈F, a concrete element f M of A\n3.\nfor each f ∈F with arity n > 0, a concrete function f M : An →A from An, the\nset of n-tuples over A, to A; and\n4.\nfor each P ∈P with arity n > 0, a subset P M ⊆An of n-tuples over A.\n2.4 Semantics of predicate logic\n125\nThe distinction between f and fM and between P and P M is most im-\nportant. The symbols f and P are just that: symbols, whereas fM and\nciding their satisﬁability. One such example is the class of Horn formu-\nlas; the name ‘Horn’ is derived from the logician A. Horn’s last name.\nWe shortly deﬁne them and give an algorithm for checking their satisﬁ-\nability.\nRecall that the logical constants ⊥(‘bottom’) and ⊤(‘top’) denote an\nunsatisﬁable formula, respectively, a tautology.\nDeﬁnition 1.46 A Horn formula is a formula φ of propositional logic if it\ncan be generated as an instance of H in this grammar:\nP ::= ⊥| ⊤| p\nA ::= P | P ∧A\nC ::= A →P\nH ::= C | C ∧H.\n(1.7)\nWe call each instance of C a Horn clause.\n66\n1 Propositional logic\nHorn formulas are conjunctions of Horn clauses. A Horn clause is an impli-\ncation whose assumption A is a conjunction of propositions of type P and\nwhose conclusion is also of type P. Examples of Horn formulas are\n(p ∧q ∧s →p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13) ∧(⊤→p5) ∧(p5 ∧p11 →⊥).\nExamples of formulas which are not Horn formulas are\n(p ∧q ∧s →¬p) ∧(q ∧r →p) ∧(p ∧s →s)\n(p ∧q ∧s →⊥) ∧(¬q ∧r →p) ∧(⊤→s)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 →⊥)\n(p2 ∧p3 ∧p5 →p13 ∧p27) ∧(⊤→p5) ∧(p5 ∧p11 ∨⊥).\nThe ﬁrst formula is not a Horn formula since ¬p, the conclusion of the\nimplication of the ﬁrst conjunct, is not of type P. The second formula does\nnot qualify since the premise of the implication of the second conjunct,\n¬q ∧r, is not a conjunction of atoms, ⊥, or ⊤. The third formula is not a\nHorn formula since the conclusion of the implication of the ﬁrst conjunct,\np13 ∧p27, is not of type P. The fourth formula clearly is not a Horn formula\nsince it is not a conjunction of implications.\nThe algorithm we propose for deciding the satisﬁability of a Horn for-\nmula φ maintains a list of all occurrences of type P in φ and proceeds like\nthis:\n1.\nIt marks ⊤if it occurs in that list.\n2.\nIf there is a conjunct P1 ∧P2 ∧· · · ∧Pki →P ′ of φ such that all Pj with 1 ≤j ≤\nki are marked, mark P ′ as well and go to 2. Otherwise (= there is no conjunct",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-3",
                            "title": "Free and Bound Variables",
                            "content": "bound since they are in the scope of ∀x, but the leaf x in the right subtree of\n→is free since it is not in the scope of any quantiﬁer ∀x or ∃x. Note, however,\nthat a single leaf either is under the scope of a quantiﬁer, or it isn’t. Hence\nindividual occurrences of variables are either free or bound, never both at\nthe same time.\n2.2.4 Substitution\nVariables are place holders so we must have some means of replacing them\nwith more concrete information. On the syntactic side, we often need to\nreplace a leaf node x by the parse tree of an entire term t. Recall from the\ndeﬁnition of formulas that any replacement of x may only be a term; it\ncould not be a predicate expression, or a more complex formula, for x serves\nas a term to a predicate symbol one step higher up in the parse tree (see\nDeﬁnition 2.1 and the grammar in (2.2)). In substituting t for x we have to\n2.2 Predicate logic as a formal language\n105\nleave untouched the bound leaves x since they are in the scope of some ∃x\nor ∀x, i.e. they stand for some unspeciﬁed or all values respectively.\nDeﬁnition 2.7 Given a variable x, a term t and a formula φ we deﬁne φ[t/x]\nto be the formula obtained by replacing each free occurrence of variable x\nin φ with t.\nSubstitutions are easily understood by looking at some examples. Let f be a\nfunction symbol with two arguments and φ the formula with the parse tree\nin Figure 2.1. Then f(x, y) is a term and φ[f(x, y)/x] is just φ again. This\nis true because all occurrences of x are bound in φ, so none of them gets\nsubstituted.\nNow consider φ to be the formula with the parse tree in Figure 2.2. Here\nwe have one free occurrence of x in φ, so we substitute the parse tree of\nf(x, y) for that free leaf node x and obtain the parse tree in Figure 2.3.\nNote that the bound x leaves are unaﬀected by this operation. You can see\nthat the process of substitution is straightforward, but requires that it be\napplied only to the free occurrences of the variable to be substituted.\n(e) What is the scope of ∃x in φ?\n(f)\n*\nSuppose that we change φ to ∃x (P(y, z) ∧(∀x (¬Q(x, x) ∨P(x, z)))). What\nis the scope of ∃x now?\n5. (a) Let P be a predicate symbol with arity 3. Draw the parse tree of ψ\ndef\n=\n¬(∀x ((∃y P(x, y, z)) ∧(∀z P(x, y, z)))).\n(b) Indicate the free and bound variables in that parse tree.\n(c) List all variables which occur free and bound therein.\n(d) Compute ψ[t/x], ψ[t/y] and ψ[t/z], where t\ndef\n= g(f(g(y, y)), y). Is t free for x\nin ψ; free for y in ψ; free for z in ψ?\n6. Rename the variables for φ in Example 2.9 (page 106) such that the resulting\nformula ψ has the same meaning as φ, but f(y, y) is free for x in ψ.\nExercises 2.3\n1. Prove the validity of the following sequents using, among others, the rules =i\nand =e. Make sure that you indicate for each application of =e what the rule\ninstances φ, t1 and t2 are.\n(a) (y = 0) ∧(y = x) ⊢0 = x\n(b) t1 = t2 ⊢(t + t2) = (t + t1)\n(c) (x = 0) ∨((x + x) > 0) ⊢(y = (x + x)) →((y > 0) ∨(y = (0 + x))).\n2. Recall that we use = to express the equality of elements in our models. Consider\nthe formula ∃x ∃y (¬(x = y) ∧(∀z ((z = x) ∨(z = y)))). Can you say, in plain\nEnglish, what this formula speciﬁes?\n3. Try to write down a sentence of predicate logic which intuitively holds in a\nmodel iﬀthe model has (respectively)\n(a)\n*\nexactly three distinct elements\n(b) at most three distinct elements\n(c)\n*\nonly ﬁnitely many distinct elements.\n2.8 Exercises\n161\nWhat ‘limitation’ of predicate logic causes problems in ﬁnding such a sentence\nfor the last item?\n4. (a) Find a (propositional) proof for φ →(q1 ∧q2) |−(φ →q1) ∧(φ →q2).\n(b) Find a (predicate) proof for φ →∀x Q(x) |−∀x (φ →Q(x)), provided that\nx is not free in φ.\n(Hint: whenever you used ∧rules in the (propositional) proof of the previous\nitem, use ∀rules in the (predicate) proof.)\n(c) Find a proof for ∀x (P(x) →Q(x)) |−∀x P(x) →∀x Q(x).\n(Hint: try (p1 →q1) ∧(p2 →q2) |−p1 ∧p2 →q1 ∧q2 ﬁrst.)\nparse tree where all free x leaves of the parse tree of φ are replaced by the\nparse tree of t. What ‘t is free for x in φ’ means is that the variable leaves of\nthe parse tree of t won’t become bound if placed into the bigger parse tree\nof φ[t/x]. For example, if we consider x, t and φ in Figure 2.3, then t is free\nfor x in φ since the new leaf variables x and y of t are not under the scope\nof any quantiﬁers involving x or y.\nExample 2.9 Consider the φ with parse tree in Figure 2.4 and let t be\nf(y, y). All two occurrences of x in φ are free. The leftmost occurrence of\nx could be substituted since it is not in the scope of any quantiﬁer, but\nsubstituting the rightmost x leaf introduces a new variable y in t which\nbecomes bound by ∀y. Therefore, f(y, y) is not free for x in φ.\nWhat if there are no free occurrences of x in φ? Inspecting the deﬁnition\nof ‘t is free for x in φ,’ we see that every term t is free for x in φ in that\ncase, since no free variable x of φ is below some quantiﬁer in the parse tree\nof φ. So the problematic situation of variable capture in performing φ[t/x]\ncannot occur. Of course, in that case φ[t/x] is just φ again.\nIt might be helpful to compare ‘t is free for x in φ’ with a precondition of\ncalling a procedure for substitution. If you are asked to compute φ[t/x] in\nyour exercises or exams, then that is what you should do; but any reasonable\nimplementation of substitution used in a theorem prover would have to check\nwhether t is free for x in φ and, if not, rename some variables with fresh\nones to avoid the undesirable capture of variables.\n2.3 Proof theory of predicate logic\n107\nthe term f(y, y) is\nnot free for x in\nthis formula\n∀y\nx\n→\nP\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nmade concrete. There are two principal such occurrences:\n1.\nIn our example in Figure 2.1, we have three leaf nodes x. If we walk up the\ntree beginning at any one of these x leaves, we run into the quantiﬁer ∀x. This\nmeans that those occurrences of x are actually bound to ∀x so they represent,\nor stand for, any possible value of x.\n2.\nIn walking upwards, the only quantiﬁer that the leaf node y runs into is ∀x but\nthat x has nothing to do with y; x and y are diﬀerent place holders. So y is free\nin this formula. This means that its value has to be speciﬁed by some additional\ninformation, for example, the contents of a location in memory.\nDeﬁnition 2.6 Let φ be a formula in predicate logic. An occurrence of x\nin φ is free in φ if it is a leaf node in the parse tree of φ such that there\nis no path upwards from that node x to a node ∀x or ∃x. Otherwise, that\noccurrence of x is called bound. For ∀x φ, or ∃x φ, we say that φ – minus\nany of φ’s subformulas ∃x ψ, or ∀x ψ – is the scope of ∀x, respectively ∃x.\nThus, if x occurs in φ, then it is bound if, and only if, it is in the scope of\nsome ∃x or some ∀x; otherwise it is free. In terms of parse trees, the scope\nof a quantiﬁer is just its subtree, minus any subtrees which re-introduce a\n104\n2 Predicate logic\n→\n∀x\n∨\n∧\n¬\nQ\nP\nQ\nP\ny\nx\nx\nx\nfree\nfree\nbound\nbound\nFigure 2.2. A parse tree of a predicate logic formula illustrating free\nand bound occurrences of variables.\nquantiﬁer for x; e.g. the scope of ∀x in ∀x (P(x) →∃x Q(x)) is P(x). It is\nquite possible, and common, that a variable is bound and free in a formula.\nConsider the formula\n(∀x (P(x) ∧Q(x))) →(¬P(x) ∨Q(y))\nand its parse tree in Figure 2.2. The two x leaves in the subtree of ∀x are\nbound since they are in the scope of ∀x, but the leaf x in the right subtree of\n→is free since it is not in the scope of any quantiﬁer ∀x or ∃x. Note, however,\nthat a single leaf either is under the scope of a quantiﬁer, or it isn’t. Hence\nf(x, y) for that free leaf node x and obtain the parse tree in Figure 2.3.\nNote that the bound x leaves are unaﬀected by this operation. You can see\nthat the process of substitution is straightforward, but requires that it be\napplied only to the free occurrences of the variable to be substituted.\nA word on notation: in writing φ[t/x], we really mean this to be the\nformula obtained by performing the operation [t/x] on φ. Strictly speaking,\nthe chain of symbols φ[t/x] is not a logical formula, but its result will be a\nformula, provided that φ was one in the ﬁrst place.\nx replaced by the term f(x, y)\nx\ny\nf\nP\n¬\n∨\nQ\ny\n→\n∀x\n∧\nP\nQ\nx\nx\nFigure 2.3. A parse tree of a formula resulting from substitution.\n106\n2 Predicate logic\nUnfortunately, substitutions can give rise to undesired side eﬀects. In\nperforming a substitution φ[t/x], the term t may contain a variable y, where\nfree occurrences of x in φ are under the scope of ∃y or ∀y in φ. By carrying\nout this substitution φ[t/x], the value y, which might have been ﬁxed by a\nconcrete context, gets caught in the scope of ∃y or ∀y. This binding capture\noverrides the context speciﬁcation of the concrete value of y, for it will now\nstand for ‘some unspeciﬁed’ or ‘all ,’ respectively. Such undesired variable\ncaptures are to be avoided at all costs.\nDeﬁnition 2.8 Given a term t, a variable x and a formula φ, we say that\nt is free for x in φ if no free x leaf in φ occurs in the scope of ∀y or ∃y for\nany variable y occurring in t.\nThis deﬁnition is maybe hard to swallow. Let us think of it in terms of\nparse trees. Given the parse tree of φ and the parse tree of t, we can perform\nthe substitution [t/x] on φ to obtain the formula φ[t/x]. The latter has a\nparse tree where all free x leaves of the parse tree of φ are replaced by the\nparse tree of t. What ‘t is free for x in φ’ means is that the variable leaves of\nthe parse tree of t won’t become bound if placed into the bigger parse tree",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-4",
                            "title": "Substitution",
                            "content": "bound since they are in the scope of ∀x, but the leaf x in the right subtree of\n→is free since it is not in the scope of any quantiﬁer ∀x or ∃x. Note, however,\nthat a single leaf either is under the scope of a quantiﬁer, or it isn’t. Hence\nindividual occurrences of variables are either free or bound, never both at\nthe same time.\n2.2.4 Substitution\nVariables are place holders so we must have some means of replacing them\nwith more concrete information. On the syntactic side, we often need to\nreplace a leaf node x by the parse tree of an entire term t. Recall from the\ndeﬁnition of formulas that any replacement of x may only be a term; it\ncould not be a predicate expression, or a more complex formula, for x serves\nas a term to a predicate symbol one step higher up in the parse tree (see\nDeﬁnition 2.1 and the grammar in (2.2)). In substituting t for x we have to\n2.2 Predicate logic as a formal language\n105\nleave untouched the bound leaves x since they are in the scope of some ∃x\nor ∀x, i.e. they stand for some unspeciﬁed or all values respectively.\nDeﬁnition 2.7 Given a variable x, a term t and a formula φ we deﬁne φ[t/x]\nto be the formula obtained by replacing each free occurrence of variable x\nin φ with t.\nSubstitutions are easily understood by looking at some examples. Let f be a\nfunction symbol with two arguments and φ the formula with the parse tree\nin Figure 2.1. Then f(x, y) is a term and φ[f(x, y)/x] is just φ again. This\nis true because all occurrences of x are bound in φ, so none of them gets\nsubstituted.\nNow consider φ to be the formula with the parse tree in Figure 2.2. Here\nwe have one free occurrence of x in φ, so we substitute the parse tree of\nf(x, y) for that free leaf node x and obtain the parse tree in Figure 2.3.\nNote that the bound x leaves are unaﬀected by this operation. You can see\nthat the process of substitution is straightforward, but requires that it be\napplied only to the free occurrences of the variable to be substituted.\nf(x, y) for that free leaf node x and obtain the parse tree in Figure 2.3.\nNote that the bound x leaves are unaﬀected by this operation. You can see\nthat the process of substitution is straightforward, but requires that it be\napplied only to the free occurrences of the variable to be substituted.\nA word on notation: in writing φ[t/x], we really mean this to be the\nformula obtained by performing the operation [t/x] on φ. Strictly speaking,\nthe chain of symbols φ[t/x] is not a logical formula, but its result will be a\nformula, provided that φ was one in the ﬁrst place.\nx replaced by the term f(x, y)\nx\ny\nf\nP\n¬\n∨\nQ\ny\n→\n∀x\n∧\nP\nQ\nx\nx\nFigure 2.3. A parse tree of a formula resulting from substitution.\n106\n2 Predicate logic\nUnfortunately, substitutions can give rise to undesired side eﬀects. In\nperforming a substitution φ[t/x], the term t may contain a variable y, where\nfree occurrences of x in φ are under the scope of ∃y or ∀y in φ. By carrying\nout this substitution φ[t/x], the value y, which might have been ﬁxed by a\nconcrete context, gets caught in the scope of ∃y or ∀y. This binding capture\noverrides the context speciﬁcation of the concrete value of y, for it will now\nstand for ‘some unspeciﬁed’ or ‘all ,’ respectively. Such undesired variable\ncaptures are to be avoided at all costs.\nDeﬁnition 2.8 Given a term t, a variable x and a formula φ, we say that\nt is free for x in φ if no free x leaf in φ occurs in the scope of ∀y or ∃y for\nany variable y occurring in t.\nThis deﬁnition is maybe hard to swallow. Let us think of it in terms of\nparse trees. Given the parse tree of φ and the parse tree of t, we can perform\nthe substitution [t/x] on φ to obtain the formula φ[t/x]. The latter has a\nparse tree where all free x leaves of the parse tree of φ are replaced by the\nparse tree of t. What ‘t is free for x in φ’ means is that the variable leaves of\nthe parse tree of t won’t become bound if placed into the bigger parse tree\neach term t (free for x in φ), and we should make our choice on the basis of\nconsistent pattern matching. Further, note that we have rules ∀x i and ∀x e\nfor each variable x. In particular, there are rules ∀y i, ∀y e and so on. We\n112\n2 Predicate logic\nwill write ∀i and ∀e when we speak about such rules without concern for the\nactual quantiﬁer variable.\nNotice also that, although the square brackets representing substitution\nappear in the rules ∀i and ∀e, they do not appear when we use those rules.\nThe reason for this is that we actually carry out the substitution that is asked\nfor. In the rules, the expression φ[t/x] means: ‘φ, but with free occurrences\nof x replaced by t.’ Thus, if φ is P(x, y) →Q(y, z) and the rule refers to\nφ[a/y], we carry out the substitution and write P(x, a) →Q(a, z) in the\nproof.\nA helpful way of understanding the universal quantiﬁer rules is to com-\npare the rules for ∀with those for ∧. The rules for ∀are in some sense\ngeneralisations of those for ∧; whereas ∧has just two conjuncts, ∀acts like\nit conjoins lots of formulas (one for each substitution instance of its vari-\nable). Thus, whereas ∧i has two premises, ∀x i has a premise φ[x0/x] for\neach possible ‘value’ of x0. Similarly, where and-elimination allows you to\ndeduce from φ ∧ψ whichever of φ and ψ you like, forall-elimination allows\nyou to deduce φ[t/x] from ∀x φ, for whichever t you (and the side condition)\nlike. To say the same thing another way: think of ∀x i as saying: to prove\n∀x φ, you have to prove φ[x0/x] for every possible value x0; while ∧i says\nthat to prove φ1 ∧φ2 you have to prove φi for every i = 1, 2.\nThe proof rules for existential quantification\nThe analogy between\n∀and ∧extends also to ∃and ∨; and you could even try to guess the rules\nfor ∃by starting from the rules for ∨and applying the same ideas as those\nthat related ∧to ∀. For example, we saw that the rules for or-introduction\nwere a sort of dual of those for and-elimination; to emphasise this point, we\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution\nin the form φ[t/x], we implicitly assume that t is free for x in φ; for, as we\nsaw in the last section, a substitution doesn’t make sense otherwise.\nWe obtain proof\n1\n(x + 1) = (1 + x)\npremise\n2\n(x + 1 > 1) →(x + 1 > 0)\npremise\n3\n(1 + x > 1) →(1 + x > 0)\n=e 1, 2\nestablishing the validity of the sequent\nx + 1 = 1 + x, (x + 1 > 1) →(x + 1 > 0) ⊢(1 + x) > 1 →(1 + x) > 0.\nIn this particular proof t1 is (x + 1), t2 is (1 + x) and φ is (x > 1) →\n(x > 0). We used the name =e since it reﬂects what this rule is doing to\ndata: it eliminates the equality in t1 = t2 by replacing all t1 in φ[t1/x]\nwith t2. This is a sound substitution principle, since the assumption that\nt1 equals t2 guarantees that the logical meanings of φ[t1/x] and φ[t2/x]\nmatch.\nThe principle of substitution, in the guise of the rule =e, is quite powerful.\nTogether with the rule =i, it allows us to show the sequents\nt1 = t2 ⊢t2 = t1\n(2.6)\nt1 = t2, t2 = t3 ⊢t1 = t3.\n(2.7)\n2.3 Proof theory of predicate logic\n109\nA proof for (2.6) is:\n1\nt1 = t2\npremise\n2\nt1 = t1\n=i\n3\nt2 = t1\n=e 1, 2\nwhere φ is x = t1. A proof for (2.7) is:\n1\nt2 = t3\npremise\n2\nt1 = t2\npremise\n3\nt1 = t3\n=e 1, 2\nwhere φ is t1 = x, so in line 2 we have φ[t2/x] and in line 3 we obtain φ[t3/x],\nas given by the rule =e applied to lines 1 and 2. Notice how we applied the\nscheme =e with several diﬀerent instantiations.\nOur discussion of the rules =i and =e has shown that they force equality\nto be reﬂexive (2.5), symmetric (2.6) and transitive (2.7). These are minimal\nand necessary requirements for any sane concept of (extensional) equality.\nWe leave the topic of equality for now to move on to the proof rules for\nquantiﬁers.\nThe proof rules for universal quantification\nThe rule for eliminat-\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nrules for dealing with the quantiﬁers and with the equality symbol. Strictly\nspeaking, we are overloading the previously established proof rules for the\npropositional connectives ∧, ∨etc. That simply means that any proof rule\nof Chapter 1 is still valid for logical formulas of predicate logic (we origi-\nnally deﬁned those rules for logical formulas of propositional logic). As in\nthe natural deduction calculus for propositional logic, the additional rules\nfor the quantiﬁers and equality will come in two ﬂavours: introduction and\nelimination rules.\nThe proof rules for equality\nFirst, let us state the proof rules for\nequality. Here equality does not mean syntactic, or intensional, equality,\nbut equality in terms of computation results. In either of these senses, any\nterm t has to be equal to itself. This is expressed by the introduction rule\nfor equality:\nt = t\n=i\n(2.5)\nwhich is an axiom (as it does not depend on any premises). Notice that it\n108\n2 Predicate logic\nmay be invoked only if t is a term, our language doesn’t permit us to talk\nabout equality between formulas.\nThis rule is quite evidently sound, but it is not very useful on its own.\nWhat we need is a principle that allows us to substitute equals for equals\nrepeatedly. For example, suppose that y ∗(w + 2) equals y ∗w + y ∗2; then\nit certainly must be the case that z ≥y ∗(w + 2) implies z ≥y ∗w + y ∗2\nand vice versa. We may now express this substitution principle as the rule\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-3",
                    "title": "Proof Theory of Predicate Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-3-subsection-1",
                            "title": "Natural Deduction Rules",
                            "content": "1\np →q\npremise\n2\n¬p ∨p\nLEM\n3\n¬p\nassumption\n4\n¬p ∨q\n∨i1 3\n5\np\nassumption\n6\nq\n→e 1, 5\n7\n¬p ∨q\n∨i2 6\n8\n¬p ∨q\n∨e 2, 3−4, 5−7\nIt can be diﬃcult to decide which instance of LEM would beneﬁt the progress\nof a proof. Can you re-do the example above with q ∨¬q as LEM?\n1.2.3 Natural deduction in summary\nThe proof rules for natural deduction are summarised in Figure 1.2. The\nexplanation of the rules we have given so far in this chapter is declarative;\nwe have presented each rule and justiﬁed it in terms of our intuition about\nthe logical connectives. However, when you try to use the rules yourself,\nyou’ll ﬁnd yourself looking for a more procedural interpretation; what does\na rule do and how do you use it? For example,\nr ∧i says: to prove φ ∧ψ, you must ﬁrst prove φ and ψ separately and then use\nthe rule ∧i.\nr ∧e1 says: to prove φ, try proving φ ∧ψ and then use the rule ∧e1. Actually,\nthis doesn’t sound like very good advice because probably proving φ ∧ψ will\nbe harder than proving φ alone. However, you might ﬁnd that you already have\nφ ∧ψ lying around, so that’s when this rule is useful. Compare this with the\nexample sequent in Example 1.15.\nr ∨i1 says: to prove φ ∨ψ, try proving φ. Again, in general it is harder to prove\nφ than it is to prove φ ∨ψ, so this will usually be useful only if you’ve already\nmanaged to prove φ. For example, if you want to prove q |−p ∨q, you certainly\nwon’t be able simply to use the rule ∨i1, but ∨i2 will work.\nr ∨e has an excellent procedural interpretation. It says: if you have φ ∨ψ, and you\nwant to prove some χ, then try to prove χ from φ and from ψ in turn. (In those\nsubproofs, of course you can use the other prevailing premises as well.)\nr Similarly, →i says, if you want to prove φ →ψ, try proving ψ from φ (and the\nother prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\nother prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ\nφ ∨ψ\n∨i1\nψ\nφ ∨ψ\n∨i2\nφ ∨ψ\nφ\n...\nχ\nψ\n...\nχ\nχ\n∨e\n→\nφ\n...\nψ\nφ →ψ\n→i\nφ\nφ →ψ\nψ\n→e\n¬\nφ\n...\n⊥\n¬φ\n¬i\nφ\n¬φ\n⊥\n¬e\n⊥\n(no introduction rule for ⊥)\n⊥\nφ\n⊥e\n¬¬\n¬¬φ\nφ\n¬¬e\nSome useful derived rules:\nφ →ψ\n¬ψ\n¬φ\nMT\nφ\n¬¬φ\n¬¬i\n¬φ\n...\n⊥\nφ\nPBC\nφ ∨¬φ\nLEM\nFigure 1.2. Natural deduction rules for propositional logic.\n28\n1 Propositional logic\nAt any stage of a proof, it is permitted to introduce any formula as as-\nsumption, by choosing a proof rule that opens a box. As we saw, natural\ndeduction employs boxes to control the scope of assumptions. When an as-\nsumption is introduced, a box is opened. Discharging assumptions is achieved\nby closing a box according to the pattern of its particular proof rule. It’s\nuseful to make assumptions by opening boxes. But don’t forget you have to\nclose them in the manner prescribed by their proof rule.\nOK, but how do we actually go about constructing a proof?\nGiven a sequent, you write its premises at the top of your page and\nits conclusion at the bottom. Now, you’re trying to ﬁll in the gap,\nwhich involves working simultaneously on the premises (to bring them to-\nwards the conclusion) and on the conclusion (to massage it towards the\npremises).\nLook ﬁrst at the conclusion. If it is of the form φ →ψ, then apply6 the\nrule →i. This means drawing a box with φ at the top and ψ at the bottom.\nSo your proof, which started out like this:\n...\npremises\n...\nφ →ψ\nnow looks like this:\n...\npremises\n...\nφ\nassumption\nψ\nφ →ψ\n→i\nYou still have to ﬁnd a way of ﬁlling in the gap between the φ and the ψ.\nBut you now have an extra formula to work with and you have simpliﬁed\nthe conclusion you are trying to reach.\n6 Except in situations such as p →(q →¬r), p ⊢q →¬r where →e produces a simpler proof.\n1.2 Natural deduction\n29\nthe summary of natural deduction rules in Figure 1.2 on page 27 to see which\ncases are still missing. Do you need to include derived rules?\n12. Show that the following sequents are not valid by ﬁnding a valuation in which\nthe truth values of the formulas to the left of ⊢are T and the truth value of\nthe formula to the right of ⊢is F.\n(a) ¬p ∨(q →p) ⊢¬p ∧q\n(b) ¬r →(p ∨q), r ∧¬q ⊢r →q\n(c)\n*\np →(q →r) ⊢p →(r →q)\n(d) ¬p, p ∨q ⊢¬q\n(e) p →(¬q ∨r), ¬r ⊢¬q →¬p.\n13. For each of the following invalid sequents, give examples of natural language\ndeclarative sentences for the atoms p, q and r such that the premises are true,\nbut the conclusion false.\n(a)\n*\np ∨q ⊢p ∧q\n(b)\n*\n¬p →¬q ⊢¬q →¬p\n(c) p →q ⊢p ∨q\n(d) p →(q ∨r) ⊢(p →q) ∧(p →r).\n14. Find a formula of propositional logic φ which contains only the atoms p, q\nand r and which is true only when p and q are false, or when ¬q ∧(p ∨r) is\ntrue.\n1.7 Exercises\n87\n15. Use mathematical induction on n to prove the theorem ((φ1 ∧(φ2 ∧(· · · ∧\nφn) . . . ) →ψ) →(φ1 →(φ2 →(. . . (φn →ψ) . . . )))).\n16. Prove the validity of the following sequents needed to secure the completeness\nresult for propositional logic:\n(a) φ1 ∧¬φ2 ⊢¬(φ1 →φ2)\n(b) ¬φ1 ∧¬φ2 ⊢φ1 →φ2\n(c) ¬φ1 ∧φ2 ⊢φ1 →φ2\n(d) φ1 ∧φ2 ⊢φ1 →φ2\n(e) ¬φ1 ∧φ2 ⊢¬(φ1 ∧φ2)\n(f) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(g) φ1 ∧¬φ2 ⊢¬(φ1 ∧φ2)\n(h) ¬φ1 ∧¬φ2 ⊢¬(φ1 ∨φ2)\n(i) φ1 ∧φ2 ⊢φ1 ∨φ2\n(j) ¬φ1 ∧φ2 ⊢φ1 ∨φ2\n(k) φ1 ∧¬φ2 ⊢φ1 ∨φ2.\n17. Does ⊨φ hold for the φ below? Please justify your answer.\n(a) (p →q) ∨(q →r)\n(b)\n*\n((q →(p ∨(q →p))) ∨¬(p →q)) →p.\nExercises 1.5\n1. Show that a formula φ is valid iﬀ⊤≡φ, where ⊤is an abbreviation for an\ninstance p ∨¬p of LEM.\n2. Which of these formulas are semantically equivalent to p →(q ∨r)?\n(a) q ∨(¬p ∨r)\n(b)\n*\nq ∧¬r →p\n(c) p ∧¬r →q\n(d)\n*\n¬q ∧¬r →¬p.\n3. An adequate set of connectives for propositional logic is a set such that for every\nformula of propositional logic there is an equivalent formula with only connectives\nfrom that set. For example, the set {¬, ∨} is adequate for propositional logic,\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nrules for dealing with the quantiﬁers and with the equality symbol. Strictly\nspeaking, we are overloading the previously established proof rules for the\npropositional connectives ∧, ∨etc. That simply means that any proof rule\nof Chapter 1 is still valid for logical formulas of predicate logic (we origi-\nnally deﬁned those rules for logical formulas of propositional logic). As in\nthe natural deduction calculus for propositional logic, the additional rules\nfor the quantiﬁers and equality will come in two ﬂavours: introduction and\nelimination rules.\nThe proof rules for equality\nFirst, let us state the proof rules for\nequality. Here equality does not mean syntactic, or intensional, equality,\nbut equality in terms of computation results. In either of these senses, any\nterm t has to be equal to itself. This is expressed by the introduction rule\nfor equality:\nt = t\n=i\n(2.5)\nwhich is an axiom (as it does not depend on any premises). Notice that it\n108\n2 Predicate logic\nmay be invoked only if t is a term, our language doesn’t permit us to talk\nabout equality between formulas.\nThis rule is quite evidently sound, but it is not very useful on its own.\nWhat we need is a principle that allows us to substitute equals for equals\nrepeatedly. For example, suppose that y ∗(w + 2) equals y ∗w + y ∗2; then\nit certainly must be the case that z ≥y ∗(w + 2) implies z ≥y ∗w + y ∗2\nand vice versa. We may now express this substitution principle as the rule\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution\n1\np →(q →r)\npremise\n2\np\npremise\n3\n¬r\npremise\n4\nq\nassumption\n5\nq →r\n→e 1, 2\n6\nr\n→e 5, 4\n7\n⊥\n¬e 6, 3\n8\n¬q\n¬i 4−7\nExample 1.23 Finally, we return to the argument of Examples 1.1 and 1.2,\nwhich can be coded up by the sequent p ∧¬q →r, ¬r, p |−q whose validity\nwe now prove:\n1\np ∧¬q →r\npremise\n2\n¬r\npremise\n3\np\npremise\n4\n¬q\nassumption\n5\np ∧¬q\n∧i 3, 4\n6\nr\n→e 1, 5\n7\n⊥\n¬e 6, 2\n8\n¬¬q\n¬i 4−7\n9\nq\n¬¬e 8\n1.2.2 Derived rules\nWhen describing the proof rule modus tollens (MT), we mentioned that it\nis not a primitive rule of natural deduction, but can be derived from some\nof the other rules. Here is the derivation of\nφ →ψ\n¬ψ\n¬φ\nMT\n24\n1 Propositional logic\nfrom →e, ¬e and ¬i:\n1\nφ →ψ\npremise\n2\n¬ψ\npremise\n3\nφ\nassumption\n4\nψ\n→e 1, 3\n5\n⊥\n¬e 4, 2\n6\n¬φ\n¬i 3−5\nWe could now go back through the proofs in this chapter and replace applica-\ntions of MT by this combination of →e, ¬e and ¬i. However, it is convenient\nto think of MT as a shorthand (or a macro).\nThe same holds for the rule\nφ\n¬¬φ\n¬¬i.\nIt can be derived from the rules ¬i and ¬e, as follows:\n1\nφ\npremise\n2\n¬φ\nassumption\n3\n⊥\n¬e 1, 2\n4\n¬¬φ\n¬i 2−3\nThere are (unboundedly) many such derived rules which we could write\ndown. However, there is no point in making our calculus fat and unwieldy;\nand some purists would say that we should stick to a minimum set of rules,\nall of which are independent of each other. We don’t take such a purist view.\nIndeed, the two derived rules we now introduce are extremely useful. You will\nﬁnd that they crop up frequently when doing exercises in natural deduction,\nso it is worth giving them names as derived rules. In the case of the second\none, its derivation from the primitive proof rules is not very obvious.\nThe ﬁrst one has the Latin name reductio ad absurdum. It means ‘reduc-\ntion to absurdity’ and we will simply call it proof by contradiction (PBC\nfor short). The rule says: if from ¬φ we obtain a contradiction, then we are\nentitled to deduce φ:\n¬φ\n...\n⊥\nφ\nPBC.\n1.2 Natural deduction\n25",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-2",
                            "title": "Quantifier Equivalences",
                            "content": "quantiﬁcation. Now we want to provide formal proofs for some of the most\ncommonly used quantiﬁer equivalences. Quite a few of them involve several\nquantiﬁcations over more than just one variable. Thus, this topic is also\ngood practice for using the proof rules for quantiﬁers in a nested fashion.\nFor example, the formula ∀x ∀y φ should be equivalent to ∀y ∀x φ since\nboth say that φ should hold for all values of x and y. What about (∀x φ) ∧\n(∀x ψ) versus ∀x (φ ∧ψ)? A moment’s thought reveals that they should have\nthe same meaning as well. But what if the second conjunct does not start\nwith ∀x? So what if we are looking at (∀x φ) ∧ψ in general and want to\ncompare it with ∀x (φ ∧ψ)? Here we need to be careful, since x might be\nfree in ψ and would then become bound in the formula ∀x (φ ∧ψ).\nExample 2.12 We may specify ‘Not all birds can ﬂy.’ as ¬∀x (B(x) →\nF(x)) or as ∃x (B(x) ∧¬F(x)). The former formal speciﬁcation is closer\nto the structure of the English speciﬁcation, but the latter is logically equiv-\nalent to the former. Quantiﬁer equivalences help us in establishing that\nspeciﬁcations that ‘look’ diﬀerent are really saying the same thing.\nHere are some quantiﬁer equivalences which you should become familiar\nwith. As in Chapter 1, we write φ1 ⊣⊢φ2 as an abbreviation for the validity\nof φ1 ⊢φ2 and φ2 ⊢φ1.\nTheorem 2.13 Let φ and ψ be formulas of predicate logic. Then we have\nthe following equivalences:\n1.\n(a) ¬∀x φ ⊣⊢∃x ¬φ\n(b) ¬∃x φ ⊣⊢∀x ¬φ.\n2.\nAssuming that x is not free in ψ:\n118\n2 Predicate logic\n(a) ∀x φ ∧ψ ⊣⊢∀x (φ ∧ψ)3\n(b) ∀x φ ∨ψ ⊣⊢∀x (φ ∨ψ)\n(c) ∃x φ ∧ψ ⊣⊢∃x (φ ∧ψ)\n(d) ∃x φ ∨ψ ⊣⊢∃x (φ ∨ψ)\n(e) ∀x (ψ →φ) ⊣⊢ψ →∀x φ\n(f) ∃x (φ →ψ) ⊣⊢∀x φ →ψ\n(g) ∀x (φ →ψ) ⊣⊢∃x φ →ψ\n(h) ∃x (ψ →φ) ⊣⊢ψ →∃x φ.\n3.\n(a) ∀x φ ∧∀x ψ ⊣⊢∀x (φ ∧ψ)\n(b) ∃x φ ∨∃x ψ ⊣⊢∃x (φ ∨ψ).\n4.\n(a) ∀x ∀y φ ⊣⊢∀y ∀x φ\n(b) ∃x ∃y φ ⊣⊢∃y ∃x φ.\nPROOF: We will prove most of these sequents; the proofs for the remaining\nones are straightforward adaptations and are left as exercises. Recall that\nand r ∨¬r? At ﬁrst glance, they have little in common, having diﬀerent\natomic formulas and diﬀerent connectives. Moreover, the truth table for\np ∧q →p is four lines long, whereas the one for r ∨¬r consists of only two\nlines. However, both formulas are always true. This suggests that we deﬁne\nthe equivalence of formulas φ and ψ via ⊨: if φ semantically entails ψ and\nvice versa, then these formulas should be the same as far as our truth-table\nsemantics is concerned.\nDeﬁnition 1.40 Let φ and ψ be formulas of propositional logic. We say\nthat φ and ψ are semantically equivalent iﬀφ ⊨ψ and ψ ⊨φ hold. In that\ncase we write φ ≡ψ. Further, we call φ valid if ⊨φ holds.\nNote that we could also have deﬁned φ ≡ψ to mean that ⊨(φ →ψ) ∧\n(ψ →φ) holds; it amounts to the same concept. Indeed, because of soundness\nand completeness, semantic equivalence is identical to provable equivalence\n1.5 Normal forms\n55\n(Deﬁnition 1.25). Examples of equivalent formulas are\np →q ≡¬q →¬p\np →q ≡¬p ∨q\np ∧q →p ≡r ∨¬r\np ∧q →r ≡p →(q →r).\nRecall that a formula η is called a tautology if ⊨η holds, so the tautologies\nare exactly the valid formulas. The following lemma says that any decision\nprocedure for tautologies is in fact a decision procedure for the validity of\nsequents as well.\nLemma 1.41 Given formulas φ1, φ2, . . . , φn and ψ of propositional logic,\nφ1, φ2, . . . , φn ⊨ψ holds iﬀ⊨φ1 →(φ2 →(φ3 →· · · →(φn →ψ))) holds.\nProof: First, suppose that ⊨φ1 →(φ2 →(φ3 →· · · →(φn →ψ))) holds.\nIf φ1, φ2, . . . , φn are all true under some valuation, then ψ has to be true\nas well for that same valuation. Otherwise,\n⊨φ1 →(φ2 →(φ3 →· · · →\n(φn →ψ))) would not hold (compare this with Figure 1.11). Second, if\nφ1, φ2, . . . , φn ⊨ψ holds, we have already shown that ⊨φ1 →(φ2 →(φ3 →\n· · · →(φn →ψ))) follows in step 1 of our completeness proof.\n2\nFor our current purposes, we want to transform formulas into ones which\ndon’t contain →at all and the occurrences of ∧and ∨are conﬁned to\n2(φ ∧ψ) ≡2φ ∧2ψ and 3(φ ∨ψ) ≡3φ ∨3ψ.\nThese equivalences correspond closely to the quantiﬁer equivalences dis-\ncussed in Section 2.3.2. It is also not surprising to ﬁnd that 2 does not\ndistribute over ∨and 3 does not distribute over ∧, i.e. we do not have equiv-\nalences between 2(φ ∨ψ) and 2φ ∨2ψ, or between 3(φ ∧ψ) and 3φ ∧3ψ.\nFor example, in the fourth item of Example 5.6 we had x5 ⊩2(p ∨q) and\nx5 ̸⊩2p ∨2q.\nNote that 2⊤is equivalent to ⊤, but not to 3⊤, as we saw earlier.\nSimilarly, 3⊥≡⊥but they are not equivalent to 2⊥.\nAnother equivalence is 3⊤≡2p →3p. For suppose x ⊩3⊤– i.e. x has\nan accessible world, say y – and suppose x ⊩2p; then y ⊩p, so x ⊩3p.\nConversely, suppose x ⊩2p →3p; we must show it satisﬁes 3⊤. Let us\ndistinguish between the cases x ⊩2p and x ̸⊩2p; in the former, we get\nx ⊩3p from x ⊩2p →3p and so x must have an accessible world; and in\nthe latter, x must again have an accessible world in order to avoid satisfying\n2p. Either way, x has an accessible world, i.e. satisﬁes 3⊤. Naturally, this\nargument works for any formula φ, not just an atom p.\nValid formulas\nDeﬁnition 5.8 A formula φ of basic modal logic is said to be valid if it is\ntrue in every world of every model, i.e. iﬀ⊨φ holds.\nAny propositional tautology is a valid formula and so is any substitution\ninstance of it. A substitution instance of a formula is the result of uniformly\nsubstituting the atoms of the formula by other formulas as done in (5.2).\nFor example, since p ∨¬p is a tautology, performing the substitution p \u000e→\n2p ∧(q →p) gives us a valid formula (2p ∧(q →p)) ∨¬(2p ∧(q →p)).\nAs we may expect from equivalences above, these formulas are valid:\n¬2φ ↔3¬φ\n2(φ ∧ψ) ↔2φ ∧2ψ\n(5.3)\n3(φ ∨ψ) ↔3φ ∨3ψ.\nTo prove that the ﬁrst of these is valid, we reason as follows. Suppose x is\na world in a model M = (W, R, L). We want to show x ⊩¬2φ ↔3¬φ, i.e.\nthat x ⊩¬2φ iﬀx ⊩3¬φ. Well, using Deﬁnition 5.4,\n5.2 Basic modal logic\n315\nb\nc\nd\na\ne\np, q\np, q\nq\np\nFigure 5.5. Another Kripke model.\nx ⊩¬2φ\n9. Let φ and ψ and η be sentences of predicate logic.\n(a) If ψ is semantically entailed by φ, is it necessarily the case that ψ is not\nsemantically entailed by ¬φ?\n(b)\n*\nIf ψ is semantically entailed by φ ∧η, is it necessarily the case that ψ is\nsemantically entailed by φ and semantically entailed by η?\n(c) If ψ is semantically entailed by φ or by η, is it necessarily the case that ψ\nis semantically entailed by φ ∨η?\n(d) Explain why ψ is semantically entailed by φ iﬀφ →ψ is valid.\n10. Is ∀x (P(x) ∨Q(x)) ⊨∀x P(x) ∨∀x Q(x) a semantic entailment? Justify your\nanswer.\n11. For each set of formulas below show that they are consistent:\n(a) ∀x ¬S(x, x), ∃x P(x), ∀x ∃y S(x, y), ∀x (P(x) →∃y S(y, x))\n(b)\n*\n∀x ¬S(x, x), ∀x ∃y S(x, y),\n∀x ∀y ∀z ((S(x, y) ∧S(y, z)) →S(x, z))\n(c) (∀x (P(x) ∨Q(x))) →∃y R(y), ∀x (R(x) →Q(x)), ∃y (¬Q(y) ∧P(y))\n(d)\n*\n∃x S(x, x), ∀x ∀y (S(x, y) →(x = y)).\n12. For each of the formulas of predicate logic below, either ﬁnd a model which\ndoes not satisfy it, or prove it is valid:\n(a) (∀x ∀y (S(x, y) →S(y, x))) →(∀x ¬S(x, x))\n(b)\n*\n∃y ((∀x P(x)) →P(y))\n(c) (∀x (P(x) →∃y Q(y))) →(∀x ∃y (P(x) →Q(y)))\n(d) (∀x ∃y (P(x) →Q(y))) →(∀x (P(x) →∃y Q(y)))\n(e) ∀x ∀y (S(x, y) →(∃z (S(x, z) ∧S(z, y))))\n(f) (∀x ∀y (S(x, y) →(x = y))) →(∀z ¬S(z, z))\n(g)\n*\n(∀x ∃y (S(x, y) ∧((S(x, y) ∧S(y, x)) →(x = y)))) →\n(¬∃z ∀w (S(z, w))).\n(h) ∀x ∀y ((P(x) →P(y)) ∧(P(y) →P(x)))\n(i) (∀x ((P(x) →Q(x)) ∧(Q(x) →P(x)))) →((∀x P(x)) →(∀x Q(x)))\n(j) ((∀x P(x)) →(∀x Q(x))) →(∀x ((P(x) →Q(x)) ∧(Q(x) →P(x))))\n(k) Diﬃcult: (∀x ∃y (P(x) →Q(y))) →(∃y ∀x (P(x) →Q(y))).\nExercises 2.5\n1. Assuming that our proof calculus for predicate logic is sound (see exercise 3\nbelow), show that the validity of the following sequents cannot be proved by\nﬁnding for each sequent a model such that all formulas to the left of ⊢evaluate\nto T and the sole formula to the right of ⊢evaluates to F (explain why this\nguarantees the non-existence of a proof):\n2.8 Exercises\n165\n(a) ∀x (P(x) ∨Q(x)) ⊢∀x P(x) ∨∀x Q(x)\n(b)\n*\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nrules for dealing with the quantiﬁers and with the equality symbol. Strictly\nspeaking, we are overloading the previously established proof rules for the\npropositional connectives ∧, ∨etc. That simply means that any proof rule\nof Chapter 1 is still valid for logical formulas of predicate logic (we origi-\nnally deﬁned those rules for logical formulas of propositional logic). As in\nthe natural deduction calculus for propositional logic, the additional rules\nfor the quantiﬁers and equality will come in two ﬂavours: introduction and\nelimination rules.\nThe proof rules for equality\nFirst, let us state the proof rules for\nequality. Here equality does not mean syntactic, or intensional, equality,\nbut equality in terms of computation results. In either of these senses, any\nterm t has to be equal to itself. This is expressed by the introduction rule\nfor equality:\nt = t\n=i\n(2.5)\nwhich is an axiom (as it does not depend on any premises). Notice that it\n108\n2 Predicate logic\nmay be invoked only if t is a term, our language doesn’t permit us to talk\nabout equality between formulas.\nThis rule is quite evidently sound, but it is not very useful on its own.\nWhat we need is a principle that allows us to substitute equals for equals\nrepeatedly. For example, suppose that y ∗(w + 2) equals y ∗w + y ∗2; then\nit certainly must be the case that z ≥y ∗(w + 2) implies z ≥y ∗w + y ∗2\nand vice versa. We may now express this substitution principle as the rule\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-4",
                    "title": "Semantics of Predicate Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-4-subsection-1",
                            "title": "Models",
                            "content": "3.\nA function L : W →P(Atoms), called the labelling function.\nWe write R(x, y) to denote that (x, y) is in R.\nThese models are often called Kripke models, in honour of S. Kripke who\ninvented them and worked extensively in modal logic in the 1950s and 1960s.\nIntuitively, w ∈W stands for a possible world and R(w, w′) means that w′\nis a world accessible from world w. The actual nature of that relationship\ndepends on what we intend to model. Although the deﬁnition of models\nlooks quite complicated, we can use an easy graphical notation to depict\nﬁnite models. We illustrate the graphical notation by an example. Suppose\nW equals {x1, x2, x3, x4, x5, x6} and the relation R is given as follows:\nr R(x1, x2), R(x1, x3), R(x2, x2), R(x2, x3), R(x3, x2), R(x4, x5), R(x5, x4),\nR(x5, x6); and no other pairs are related by R.\nSuppose further that the labelling function behaves as follows:\nx\nx1 x2\nx3\nx4 x5 x6\nL(x) {q} {p, q} {p} {q} ∅{p}\n310\n5 Modal logics and agents\nThen, the Kripke model is illustrated in Figure 5.3. The set W is drawn as\na set of circles, with arrows between them showing the relation R. Within\neach circle is the value of the labelling function in that world. If you have\nread Chapter 3, then you might have noticed that Kripke structures are also\nthe models for CTL, where W is S, the set of states; R is →, the relation\nof state transitions; and L is the labelling function.\nDeﬁnition 5.4 Let M = (W, R, L) be a model of basic modal logic. Sup-\npose x ∈W and φ is a formula of (5.1). We will deﬁne when formula φ is true\nin the world x. This is done via a satisfaction relation x ⊩φ by structural\ninduction on φ:\nx ⊩⊤\nx ̸⊩⊥\nx ⊩p iﬀp ∈L(x)\nx ⊩¬φ iﬀx ̸⊩φ\nx ⊩φ ∧ψ\niﬀx ⊩φ and x ⊩ψ\nx ⊩φ ∨ψ\niﬀx ⊩φ , or x ⊩ψ\nx ⊩φ →ψ\niﬀx ⊩ψ , whenever we have x ⊩φ\nx ⊩φ ↔ψ\niﬀ(x ⊩φ iﬀx ⊩ψ)\nx ⊩2ψ\niﬀ, for each y ∈W with R(x, y), we have y ⊩ψ\nx ⊩3ψ\niﬀthere is a y ∈W such that R(x, y) and y ⊩ψ.\nWhen x ⊩φ holds, we say ‘x satisﬁes φ,’ or ‘φ is true in world x.’ We write\n(c) For each formula of the previous item, ﬁnd a world which does not satisfy\nthe formula.\n2. Find a Kripke model M and a formula scheme which is not satisﬁed in M, but\nwhich has true instances in M.\n5.6 Exercises\n351\n3. Consider the Kripke model M = (W, R, L) where W = {a, b, c, d, e}; R =\n{(a, c), (a, e), (b, a), (b, c), (d, e), (e, a)}; and L(a) = {p}, L(b) = {p, q}, L(c) =\n{p, q}, L(d) = {q} and L(e) = ∅.\n(a) Draw a graph for M.\n(b) Investigate which of the formulas in exercise 1(b) on page 350 have a world\nwhich satisﬁes it.\n4. (a) Think about what you have to do to decide whether p →23q is true in a\nmodel.\n(b)\n*\nFind a model in which it is true and one in which it is false.\n5. For each of the following pairs of formulas, can you ﬁnd a model and a world in\nit which distinguishes them, i.e. makes one of them true and one false? In that\ncase, you are showing that they do not entail each other. If you cannot, it might\nmean that the formulas are equivalent. Justify your answer.\n(a) 2p and 22p\n(b) 2¬p and ¬3p\n(c) 2(p ∧q) and 2p ∧2q\n(d)\n*\n3(p ∧q) and 3p ∧3q\n(e) 2(p ∨q) and 2p ∨2q\n(f)\n*\n3(p ∨q) and 3p ∨3q\n(g) 2(p →q) and 2p →2q\n(h) 3⊤and ⊤\n(i) 2⊤and ⊤\n(j) 3⊥and ⊥.\n6. Show that the following formulas of basic modal logic are valid:\n(a)\n*\n2(φ ∧ψ) ↔(2φ ∧2ψ)\n(b) 3(φ ∨ψ) ↔(3φ ∨3ψ)\n(c)\n*\n2⊤↔⊤\n(d) 3⊥↔⊥\n(e) 3⊤→(2φ →3φ)\n7. Inspect Deﬁnition 5.4. We said that we deﬁned x ⊩φ by structural induction on\nφ. Is this really correct? Note the implicit deﬁnition of a second relation x ̸⊩φ.\nWhy is this deﬁnition still correct and in what sense does it still rely on structural\ninduction?\nExercises 5.3\n1. For which of the readings of 2 in Table 5.7 are the formulas below valid?\n(a)\n*\n(φ →2φ) →(φ →3φ)\n(b) (2φ →(φ ∧22φ ∧3φ)) →((2φ →(φ ∧22φ)) ∧(3φ →23φ)).\n2. Dynamic logic: Let P range over the programs of our core language in Chapter 4.\nConsider a modal logic whose modal operators are ⟨P⟩and [P] for all such\nprograms P. Evaluate such formulas in stores l as in Deﬁnition 4.3 (page 264).\n352\nquite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nThe subformulas of p W (q U r), e.g., are p, q, r, q U r and p W (q U r).\n3.2.2 Semantics of LTL\nThe kinds of systems we are interested in verifying using LTL may be\nmodelled as transition systems. A transition system models a system by\nmeans of states (static structure) and transitions (dynamic structure). More\nformally:\nDeﬁnition 3.4 A transition system M = (S, →, L) is a set of states S\nendowed with a transition relation\n→(a binary relation on S), such\nthat every s ∈S has some s′ ∈S with s →s′, and a labelling function\nL: S →P(Atoms).\nTransition systems are also simply called models in this chapter. So a model\nhas a collection of states S, a relation →, saying how the system can move\nfrom state to state, and, associated with each state s, one has the set of\natomic propositions L(s) which are true at that particular state. We write\nP(Atoms) for the power set of Atoms, a collection of atomic descriptions.\nFor example, the power set of {p, q} is {∅, {p}, {q}, {p, q}}. A good way of\nthinking about L is that it is just an assignment of truth values to all the\npropositional atoms, as it was the case for propositional logic (we called\nthat a valuation). The diﬀerence now is that we have more than one state,\nso this assignment depends on which state s the system is in: L(s) contains\nall atoms which are true in state s.\nWe may conveniently express all the information about a (ﬁnite) tran-\nsition system M using directed graphs whose nodes (which we call states)\ncontain all propositional atoms that are true in that state. For example, if\nour system has only three states s0, s1 and s2; if the only possible transi-\ntions between states are s0 →s1, s0 →s2, s1 →s0, s1 →s2 and s2 →s2;\nLTL in which the future excludes the present. A consequence of adopting\nthe convention that the future shall include the present is that the formulas\nG p →p, p →q U p and p →F p are true in every state of every model.\nSo far we have deﬁned a satisfaction relation between paths and LTL for-\nmulas. However, to verify systems, we would like to say that a model as\na whole satisﬁes an LTL formula. This is deﬁned to hold whenever every\npossible execution path of the model satisﬁes the formula.\nDeﬁnition 3.8 Suppose M = (S, →, L) is a model, s ∈S, and φ an LTL\nformula. We write M, s ⊨φ if, for every execution path π of M starting at\ns, we have π ⊨φ.\nIf M is clear from the context, we may abbreviate M, s ⊨φ by s ⊨φ.\nIt should be clear that we have outlined the formal foundations of a pro-\ncedure that, given φ, M and s, can check whether M, s ⊨φ holds. Later\nin this chapter, we will examine algorithms which implement this calcula-\ntion. Let us now look at some example checks for the system in Figures 3.3\nand 3.5.\n1.\nM, s0 ⊨p ∧q holds since the atomic symbols p and q are contained in the node\nof s0: π ⊨p ∧q for every path π beginning in s0.\n3.2 Linear-time temporal logic\n183\n2.\nM, s0 ⊨¬r holds since the atomic symbol r is not contained in node s0.\n3.\nM, s0 ⊨⊤holds by deﬁnition.\n4.\nM, s0 ⊨X r holds since all paths from s0 have either s1 or s2 as their next\nstate, and each of those states satisﬁes r.\n5.\nM, s0 ⊨X (q ∧r) does not hold since we have the rightmost computation path\ns0 →s2 →s2 →s2 →. . . in Figure 3.5, whose second node s2 contains r, but\nnot q.\n6.\nM, s0 ⊨G ¬(p ∧r) holds since all computation paths beginning in s0 satisfy\nG ¬(p ∧r), i.e. they satisfy ¬(p ∧r) in each state along the path. Notice that\nG φ holds in a state if, and only if, φ holds in all states reachable from the\ngiven state.\n7.\nFor similar reasons, M, s2 ⊨G r holds (note the s2 instead of s0).\n8.\nFor any state s of M, we have M, s ⊨F (¬q ∧r) →F G r. This says that if\nin plain English.\n3. Consider the set of LTL/CTL formulas F = {F p →F q, AF p →AF q, AG (p →\nAF q)}.\n(a) Is there a model such that all formulas hold in it?\n(b) For each φ ∈F, is there a model such that φ is the only formula in F satisﬁed\nin that model?\n(c) Find a model in which no formula of F holds.\n4. Consider the CTL formula AG (p →AF (s ∧AX (AF t))). Explain what exactly\nit expresses in terms of the order of occurrence of events p, s and t.\n5. Extend the algorithm NNF from page 62 which computes the negation normal\nform of propositional logic formulas to CTL*. Since CTL* is deﬁned in terms\nof two syntactic categories (state formulas and path formulas), this requires two\nseparate versions of NNF which call each other in a way that is reﬂected by the\nsyntax of CTL* given on page 218.\n6. Find a transition system which distinguishes the following pairs of CTL* formu-\nlas, i.e., show that they are not equivalent:\n(a) AF G p and AF AG p\n(b)\n*\nAG F p and AG EF p\n(c) A[(p U r) ∨(q U r)] and A[(p ∨q) U r)]\n3.8 Exercises\n251\n(d)\n*\nA[X p ∨X X p] and AX p ∨AX AX p\n(e) E[G F p] and EG EF p.\n7. The translation from CTL with boolean combinations of path formulas to plain\nCTL introduced in Section 3.5.1 is not complete. Invent CTL equivalents for:\n(a)\n*\nE[F p ∧(q U r)]\n(b)\n*\nE[F p ∧G q].\nIn this way, we have dealt with all formulas of the form E[φ ∧ψ]. Formulas of the\nform E[φ ∨ψ] can be rewritten as E[φ] ∨E[ψ] and A[φ] can be written ¬E[¬φ].\nUse this translation to write the following in CTL:\n(c) E[(p U q) ∧F p]\n(d)\n*\nA[(p U q) ∧G p]\n(e)\n*\nA[F p →F q].\n8. The aim of this exercise is to demonstrate the expansion given for AW at the\nend of the last section, i.e., A[p W q] ≡¬E[¬q U ¬(p ∨q)].\n(a) Show that the following LTL formulas are valid (i.e., true in any state of any\nmodel):\n(i) ¬q U (¬p ∧¬q) →¬G p\n(ii) G ¬q ∧F ¬p →¬q U (¬p ∧¬q).\n(b) Expand ¬((p U q) ∨G p) using de Morgan rules and the LTL equivalence\n¬(φ U ψ) ≡(¬ψ U (¬φ ∧¬ψ)) ∨¬F ψ.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-2",
                            "title": "Semantic Entailment",
                            "content": "However, we can sometimes reason that certain semantic entailments are\nvalid. We do this by providing an argument that does not depend on the\nactual model at hand. Of course, this works only for a very limited number\nof cases. The most prominent ones are the quantiﬁer equivalences which we\nalready encountered in the section on natural deduction. Let us look at a\ncouple of examples of semantic entailment.\nExample 2.21 The justiﬁcation of the semantic entailment\n∀x (P(x) →Q(x)) ⊨∀x P(x) →∀x Q(x)\nis as follows. Let M be a model satisfying ∀x (P(x) →Q(x)). We need to\nshow that M satisﬁes ∀x P(x) →∀x Q(x) as well. On inspecting the deﬁni-\ntion of M ⊨ψ1 →ψ2, we see that we are done if not every element of our\nmodel satisﬁes P. Otherwise, every element does satisfy P. But since M\nsatisﬁes ∀x (P(x) →Q(x)), the latter fact forces every element of our model\nto satisfy Q as well. By combining these two cases (i.e. either all elements of\nM satisfy P, or not) we have shown that M satisﬁes ∀x P(x) →∀x Q(x).\nWhat about the converse of the above? Is\n∀x P(x) →∀x Q(x) ⊨∀x (P(x) →Q(x))\nvalid as well? Hardly! Suppose that M′ is a model satisfying ∀x P(x) →\n∀x Q(x). If A′ is its underlying set and P M′ and QM′ are the corresponding\ninterpretations of P and Q, then M′ ⊨∀x P(x) →∀x Q(x) simply says that,\nif P M′ equals A′, then QM′ must equal A′ as well. However, if P M′ does not\nequal A′, then this implication is vacuously true (remember that F →· = T\nno matter what · actually is). In this case we do not get any additional\nconstraints on our model M′. After these observations, it is now easy to\nconstruct a counter-example model. Let A′ def\n= {a, b}, P M′ def\n= {a} and QM′ def\n=\n{b}. Then M′ ⊨∀x P(x) →∀x Q(x) holds, but M′ ⊨∀x (P(x) →Q(x)) does\nnot.\n2.4.3 The semantics of equality\nWe have already pointed out the open-ended nature of the semantics of\npredicate logic. Given a predicate logic over a set of function symbols F and\n9. Let φ and ψ and η be sentences of predicate logic.\n(a) If ψ is semantically entailed by φ, is it necessarily the case that ψ is not\nsemantically entailed by ¬φ?\n(b)\n*\nIf ψ is semantically entailed by φ ∧η, is it necessarily the case that ψ is\nsemantically entailed by φ and semantically entailed by η?\n(c) If ψ is semantically entailed by φ or by η, is it necessarily the case that ψ\nis semantically entailed by φ ∨η?\n(d) Explain why ψ is semantically entailed by φ iﬀφ →ψ is valid.\n10. Is ∀x (P(x) ∨Q(x)) ⊨∀x P(x) ∨∀x Q(x) a semantic entailment? Justify your\nanswer.\n11. For each set of formulas below show that they are consistent:\n(a) ∀x ¬S(x, x), ∃x P(x), ∀x ∃y S(x, y), ∀x (P(x) →∃y S(y, x))\n(b)\n*\n∀x ¬S(x, x), ∀x ∃y S(x, y),\n∀x ∀y ∀z ((S(x, y) ∧S(y, z)) →S(x, z))\n(c) (∀x (P(x) ∨Q(x))) →∃y R(y), ∀x (R(x) →Q(x)), ∃y (¬Q(y) ∧P(y))\n(d)\n*\n∃x S(x, x), ∀x ∀y (S(x, y) →(x = y)).\n12. For each of the formulas of predicate logic below, either ﬁnd a model which\ndoes not satisfy it, or prove it is valid:\n(a) (∀x ∀y (S(x, y) →S(y, x))) →(∀x ¬S(x, x))\n(b)\n*\n∃y ((∀x P(x)) →P(y))\n(c) (∀x (P(x) →∃y Q(y))) →(∀x ∃y (P(x) →Q(y)))\n(d) (∀x ∃y (P(x) →Q(y))) →(∀x (P(x) →∃y Q(y)))\n(e) ∀x ∀y (S(x, y) →(∃z (S(x, z) ∧S(z, y))))\n(f) (∀x ∀y (S(x, y) →(x = y))) →(∀z ¬S(z, z))\n(g)\n*\n(∀x ∃y (S(x, y) ∧((S(x, y) ∧S(y, x)) →(x = y)))) →\n(¬∃z ∀w (S(z, w))).\n(h) ∀x ∀y ((P(x) →P(y)) ∧(P(y) →P(x)))\n(i) (∀x ((P(x) →Q(x)) ∧(Q(x) →P(x)))) →((∀x P(x)) →(∀x Q(x)))\n(j) ((∀x P(x)) →(∀x Q(x))) →(∀x ((P(x) →Q(x)) ∧(Q(x) →P(x))))\n(k) Diﬃcult: (∀x ∃y (P(x) →Q(y))) →(∃y ∀x (P(x) →Q(y))).\nExercises 2.5\n1. Assuming that our proof calculus for predicate logic is sound (see exercise 3\nbelow), show that the validity of the following sequents cannot be proved by\nﬁnding for each sequent a model such that all formulas to the left of ⊢evaluate\nto T and the sole formula to the right of ⊢evaluates to F (explain why this\nguarantees the non-existence of a proof):\n2.8 Exercises\n165\n(a) ∀x (P(x) ∨Q(x)) ⊢∀x P(x) ∨∀x Q(x)\n(b)\n*\nway to that in the ﬁrst chapter.\n96\n2 Predicate logic\nIn Section 2.4, we generalize the valuations of Chapter 1 to a proper\nnotion of models, real or artiﬁcial worlds in which formulas of predicate\nlogic can be true or false, which allows us to deﬁne semantic entailment\nφ1, φ2, . . . , φn ⊨ψ.\nThe latter expresses that, given any such model in which all φ1, φ2, . . . , φn\nhold, it is the case that ψ holds in that model as well. In that case, one\nalso says that ψ is semantically entailed by φ1, φ2, . . . , φn. Although this\ndeﬁnition of semantic entailment closely matches the one for propositional\nlogic in Deﬁnition 1.34, the process of evaluating a predicate formula diﬀers\nfrom the computation of truth values for propositional logic in the treatment\nof predicates (and functions). We discuss it in detail in Section 2.4.\nIt is outside the scope of this book to show that the natural deduction\ncalculus for predicate logic is sound and complete with respect to semantic\nentailment; but it is indeed the case that\nφ1, φ2, . . . , φn ⊢ψ\niﬀ\nφ1, φ2, . . . , φn ⊨ψ\nfor formulas of the predicate calculus. The ﬁrst proof of this was done by\nthe mathematician K. G¨odel.\nWhat kind of reasoning must predicate logic be able to support? To get\na feel for that, let us consider the following argument:\nNo books are gaseous. Dictionaries are books. Therefore, no dictio-\nnary is gaseous.\nThe predicates we choose are\nB(x) :\nx is a book\nG(x) :\nx is gaseous\nD(x) :\nx is a dictionary.\nEvidently, we need to build a proof theory and semantics that allow us to\nderive the validity and semantic entailment, respectively, of\n¬∃x (B(x) ∧G(x)), ∀x (D(x) →B(x)) ⊢¬∃x (D(x) ∧G(x))\n¬∃x (B(x) ∧G(x)), ∀x (D(x) →B(x)) ⊨¬∃x (D(x) ∧G(x)).\nVerify that these sequents express the argument above in a symbolic form.\nPredicate logic extends propositional logic not only with quantiﬁers but\nwith one more concept, that of function symbols. Consider the declarative\nsentence\nEvery child is younger than its mother.\ntrue? Fortunately, this is not the case and in this subsection we demonstrate\nwhy this is so. Let us suppose that some proof in our natural deduction cal-\nculus has established that the sequent φ1, φ2, . . . , φn ⊢ψ is valid. We need\nto show: for all valuations in which all propositions φ1, φ2, . . . , φn evaluate\nto T, ψ evaluates to T as well.\n46\n1 Propositional logic\nDeﬁnition 1.34 If, for all valuations in which all φ1, φ2, . . . , φn evaluate to\nT, ψ evaluates to T as well, we say that\nφ1, φ2, . . . , φn ⊨ψ\nholds and call ⊨the semantic entailment relation.\nLet us look at some examples of this notion.\n1.\nDoes p ∧q ⊨p hold? Well, we have to inspect all assignments of truth values to\np and q; there are four of these. Whenever such an assignment computes T for\np ∧q we need to make sure that p is true as well. But p ∧q computes T only if\np and q are true, so p ∧q ⊨p is indeed the case.\n2.\nWhat about the relationship p ∨q ⊨p? There are three assignments for which\np ∨q computes T, so p would have to be true for all of these. However, if we\nassign T to q and F to p, then p ∨q computes T, but p is false. Thus, p ∨q ⊨p\ndoes not hold.\n3.\nWhat if we modify the above to ¬q, p ∨q ⊨p? Notice that we have to be con-\ncerned only about valuations in which ¬q and p ∨q evaluate to T. This forces q\nto be false, which in turn forces p to be true. Hence ¬q, p ∨q ⊨p is the case.\n4.\nNote that p ⊨q ∨¬q holds, despite the fact that no atomic proposition on the\nright of ⊨occurs on the left of ⊨.\nFrom the discussion above we realize that a soundness argument has to show:\nif φ1, φ2, . . . , φn ⊢ψ is valid, then φ1, φ2, . . . , φn ⊨ψ holds.\nTheorem 1.35 (Soundness) Let φ1, φ2, . . . , φn and ψ be propositional\nlogic formulas. If φ1, φ2, . . . , φn ⊢ψ is valid, then φ1, φ2, . . . , φn ⊨ψ holds.\nProof:\nSince φ1, φ2, . . . , φn ⊢ψ is valid we know there is a proof of ψ\nfrom the premises φ1, φ2, . . . , φn. We now do a pretty slick thing, namely,\nthe truth-table semantics. In the exercises, we apply this to show that a se-\nquent does not have a proof: simply show that φ1, φ2, . . . , φ2 does not seman-\ntically entail ψ; then soundness implies that the sequent φ1, φ2, . . . , φ2 ⊢ψ\ndoes not have a proof. Completeness comprised a much more powerful state-\nment: no matter what (semantically) valid sequents there are, they all have\nsyntactic proofs in the proof system of natural deduction. This tight cor-\nrespondence allows us to freely switch between working with the notion of\nproofs (⊢) and that of semantic entailment (⊨).\nUsing natural deduction to decide the validity of instances of ⊢is only\none of many possibilities. In Exercise 1.2.6 we sketch a non-linear, tree-like,\nnotion of proofs for sequents. Likewise, checking an instance of ⊨by apply-\ning Deﬁnition 1.34 literally is only one of many ways of deciding whether\nφ1, φ2, . . . , φn ⊨ψ holds. We now investigate various alternatives for deciding\nφ1, φ2, . . . , φn ⊨ψ which are based on transforming these formulas syntac-\ntically into ‘equivalent’ ones upon which we can then settle the matter by\npurely syntactic or algorithmic means. This requires that we ﬁrst clarify\nwhat exactly we mean by equivalent formulas.\n1.5.1 Semantic equivalence, satisfiability and validity\nTwo formulas φ and ψ are said to be equivalent if they have the same\n‘meaning.’ This suggestion is vague and needs to be reﬁned. For example,\np →q and ¬p ∨q have the same truth table; all four combinations of T and F\nfor p and q return the same result. ’Coincidence of truth tables’ is not good\nenough for what we have in mind, for what about the formulas p ∧q →p\nand r ∨¬r? At ﬁrst glance, they have little in common, having diﬀerent\natomic formulas and diﬀerent connectives. Moreover, the truth table for\np ∧q →p is four lines long, whereas the one for r ∨¬r consists of only two\nlines. However, both formulas are always true. This suggests that we deﬁne",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-3",
                            "title": "The Semantics of Equality",
                            "content": "= {a, b}, P M′ def\n= {a} and QM′ def\n=\n{b}. Then M′ ⊨∀x P(x) →∀x Q(x) holds, but M′ ⊨∀x (P(x) →Q(x)) does\nnot.\n2.4.3 The semantics of equality\nWe have already pointed out the open-ended nature of the semantics of\npredicate logic. Given a predicate logic over a set of function symbols F and\na set of predicate symbols P, we need only a non-empty set A equipped with\nconcrete functions or elements fM (for f ∈F) and concrete predicates P M\n(for P ∈P) in A which have the right arities agreed upon in our speciﬁcation.\nOf course, we also stressed that most models have natural interpretations of\n2.5 Undecidability of predicate logic\n131\nfunctions and predicates, but central notions like that of semantic entailment\n(φ1, φ2, . . . , φn ⊨ψ) really depend on all possible models, even the ones that\ndon’t seem to make any sense.\nApparently there is no way out of this peculiarity. For example, where\nwould you draw the line between a model that makes sense and one that\ndoesn’t? And would any such choice, or set of criteria, not be subjective? Such\nconstraints could also forbid a modiﬁcation of your model if this alteration\nwere caused by a slight adjustment of the problem domain you intended to\nmodel. You see that there are a lot of good reasons for maintaining such a\nliberal stance towards the notion of models in predicate logic.\nHowever, there is one famous exception. Often one presents predicate logic\nsuch that there is always a special predicate = available to denote equality\n(recall Section 2.3.1); it has two arguments and t1 = t2 has the intended\nmeaning that the terms t1 and t2 compute the same thing. We discussed its\nproof rule in natural deduction already in Section 2.3.1.\nSemantically, one recognises the special role of equality by imposing on\nan interpretation function =M to be actual equality on the set A of M.\nThus, (a, b) is in the set =M iﬀa and b are the same elements in the set A.\nFor example, given A\ndef\n= {a, b, c}, the interpretation =M of equality is forced\nan interpretation function =M to be actual equality on the set A of M.\nThus, (a, b) is in the set =M iﬀa and b are the same elements in the set A.\nFor example, given A\ndef\n= {a, b, c}, the interpretation =M of equality is forced\nto be {(a, a), (b, b), (c, c)}. Hence the semantics of equality is easy, for it is\nalways modelled extensionally.\n2.5 Undecidability of predicate logic\nWe continue our introduction to predicate logic with some negative results.\nGiven a formula φ in propositional logic we can, at least in principle, de-\ntermine whether ⊨φ holds: if φ has n propositional atoms, then the truth\ntable of φ contains 2n lines; and ⊨φ holds if, and only if, the column for φ\n(of length 2n) contains only T entries.\nThe bad news is that such a mechanical procedure, working for all for-\nmulas φ, cannot be provided in predicate logic. We will give a formal proof\nof this negative result, though we rely on an informal (yet intuitive) notion\nof computability.\nThe problem of determining whether a predicate logic formula is valid is\nknown as a decision problem. A solution to a decision problem is a program\n(written in Java, C, or any other common language) that takes problem\ninstances as input and always terminates, producing a correct ‘yes’ or ‘no’\noutput. In the case of the decision problem for predicate logic, the input to\nthe program is an arbitrary formula φ of predicate logic and the program\n132\n2 Predicate logic\nis correct if it produces ‘yes’ whenever the input formula is valid and ‘no’\nwhenever it is not. Note that the program which solves a decision problem\nmust terminate for all well-formed input: a program which goes on thinking\nabout it for ever is not allowed. The decision problem at hand is this:\nValidity in predicate logic.\nGiven a logical formula φ in predicate logic, does\n⊨φ hold, yes or no?\nWe now show that this problem is not solvable; we cannot write a correct\nC or Java program that works for all φ. It is important to be clear about\nx\ny\nS\nQ\n∧\nFigure 2.4. A parse tree for which a substitution has dire consequences.\n2.3 Proof theory of predicate logic\n2.3.1 Natural deduction rules\nProofs in the natural deduction calculus for predicate logic are similar to\nthose for propositional logic in Chapter 1, except that we have new proof\nrules for dealing with the quantiﬁers and with the equality symbol. Strictly\nspeaking, we are overloading the previously established proof rules for the\npropositional connectives ∧, ∨etc. That simply means that any proof rule\nof Chapter 1 is still valid for logical formulas of predicate logic (we origi-\nnally deﬁned those rules for logical formulas of propositional logic). As in\nthe natural deduction calculus for propositional logic, the additional rules\nfor the quantiﬁers and equality will come in two ﬂavours: introduction and\nelimination rules.\nThe proof rules for equality\nFirst, let us state the proof rules for\nequality. Here equality does not mean syntactic, or intensional, equality,\nbut equality in terms of computation results. In either of these senses, any\nterm t has to be equal to itself. This is expressed by the introduction rule\nfor equality:\nt = t\n=i\n(2.5)\nwhich is an axiom (as it does not depend on any premises). Notice that it\n108\n2 Predicate logic\nmay be invoked only if t is a term, our language doesn’t permit us to talk\nabout equality between formulas.\nThis rule is quite evidently sound, but it is not very useful on its own.\nWhat we need is a principle that allows us to substitute equals for equals\nrepeatedly. For example, suppose that y ∗(w + 2) equals y ∗w + y ∗2; then\nit certainly must be the case that z ≥y ∗(w + 2) implies z ≥y ∗w + y ∗2\nand vice versa. We may now express this substitution principle as the rule\n=e:\nt1 = t2\nφ[t1/x]\nφ[t2/x]\n=e.\nNote that t1 and t2 have to be free for x in φ, whenever we want to apply\nthe rule =e; this is an example of a side condition of a proof rule.\nConvention 2.10 Throughout this section, when we write a substitution\nset of n-tuples over A, to A; and\n4.\nfor each P ∈P with arity n > 0, a subset P M ⊆An of n-tuples over A.\n2.4 Semantics of predicate logic\n125\nThe distinction between f and fM and between P and P M is most im-\nportant. The symbols f and P are just that: symbols, whereas fM and\nP M denote a concrete function (or element) and relation in a model M,\nrespectively.\nExample 2.15 Let F\ndef\n= {i} and P\ndef\n= {R, F}; where i is a constant, F a\npredicate symbol with one argument and R a predicate symbol with two\narguments. A model M contains a set of concrete elements A – which may be\na set of states of a computer program. The interpretations iM, RM, and F M\nmay then be a designated initial state, a state transition relation, and a set\nof ﬁnal (accepting) states, respectively. For example, let A\ndef\n= {a, b, c}, iM def\n=\na, RM def\n= {(a, a), (a, b), (a, c), (b, c), (c, c)}, and F M def\n= {b, c}. We informally\ncheck some formulas of predicate logic for this model:\n1.\nThe formula\n∃y R(i, y)\nsays that there is a transition from the initial state to some state; this is true\nin our model, as there are transitions from the initial state a to a, b, and c.\n2.\nThe formula\n¬F(i)\nstates that the initial state is not a ﬁnal, accepting state. This is true in our\nmodel as b and c are the only ﬁnal states and a is the intitial one.\n3.\nThe formula\n∀x∀y∀z (R(x, y) ∧R(x, z) →y = z)\nmakes use of the equality predicate and states that the transition relation is\ndeterministic: all transitions from any state can go to at most one state (there\nmay be no transitions from a state as well). This is false in our model since\nstate a has transitions to b and c.\n4.\nThe formula\n∀x∃y R(x, y)\nstates that the model is free of states that deadlock: all states have a transition\nto some state. This is true in our model: a can move to a, b or c; and b and c\ncan move to c.\nExample 2.16 Let F\ndef\n= {e, ·} and P\ndef\n= {≤}, where e is a constant, · is a\nthat this follows from the given precondition ⊤. This means checking that any\nstate that satisﬁes ⊤also satisﬁes x + y = x + y. Well, ⊤is satisﬁed in all states,\nbut so is x + y = x + y, so the sequent ⊢AR ⊤→(x + y = x + y) is valid.\nThe ﬁnal completed proof therefore looks like this:\n\u0001\n⊤\n\u0002\n\u0001\nx + y = x + y\n\u0002\nImplied\nz = x;\n\u0001\nz + y = x + y\n\u0002\nAssignment\nz = z + y;\n\u0001\nz = x + y\n\u0002\nAssignment\nu = z;\n\u0001\nu = x + y\n\u0002\nAssignment\nand we can now read it from the top down.\nThe application of the axiom Assignment requires some care. We describe\ntwo pitfalls which the unwary may fall into, if the rule is not applied correctly.\nr Consider the example ‘proof’\n\u0001\nx + 1 = x + 1\n\u0002\nx = x + 1;\n\u0001\nx = x + 1\n\u0002\nAssignment\nwhich uses the rule for assignment incorrectly. Pattern matching with the assign-\nment axiom means that ψ has to be x = x + 1, the expression E is x + 1 and\nψ[E/x] is x + 1 = x + 1. However, ψ[E/x] is obtained by replacing all occur-\nrences of x in ψ by E, thus, ψ[E/x] would have to be equal to x + 1 = x + 1 + 1.\nTherefore, the corrected proof\n280\n4 Program verification\n\u0001\nx + 1 = x + 1 + 1\n\u0002\nx = x + 1;\n\u0001\nx = x + 1\n\u0002\nAssignment\nshows that ⊢par\n\u0001\nx + 1 = x + 1 + 1\n\u0002\nx = x + 1\n\u0001\nx = x + 1\n\u0002\nis valid.\nAs an aside, this corrected proof is not very useful. The triple says that, if\nx + 1 = (x + 1) + 1 holds in a state and the assignment x = x + 1 is executed\nand terminates, then the resulting state satisﬁes x = x + 1; but, since the precon-\ndition x + 1 = x + 1 + 1 can never be true, this triple tells us nothing informative\nabout the assignment.\nr Another way of using the proof rule for assignment incorrectly is by allowing ad-\nditional assignments to happen in between ψ[E/x] and x = E, as in the ‘proof’\n\u0001\nx + 2 = y + 1\n\u0002\ny = y + 1000001;\nx = x + 2;\n\u0001\nx = y + 1\n\u0002\nAssignment\nThis is not a correct application of the assignment rule, since an additional\nassignment happens in line 2 right before the actual assignment to which the",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-5",
                    "title": "Undecidability of Predicate Logic",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-6",
                    "title": "Expressiveness of Predicate Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-6-subsection-1",
                            "title": "Existential Second-Order Logic",
                            "content": "To prove that the ﬁrst of these is valid, we reason as follows. Suppose x is\na world in a model M = (W, R, L). We want to show x ⊩¬2φ ↔3¬φ, i.e.\nthat x ⊩¬2φ iﬀx ⊩3¬φ. Well, using Deﬁnition 5.4,\n5.2 Basic modal logic\n315\nb\nc\nd\na\ne\np, q\np, q\nq\np\nFigure 5.5. Another Kripke model.\nx ⊩¬2φ\niﬀit isn’t the case that x ⊩2φ\niﬀit isn’t the case that, for all y such that R(x, y), y ⊩φ\niﬀthere is some y such that R(x, y) and not y ⊩φ\niﬀthere is some y such that R(x, y) and y ⊩¬φ\niﬀx ⊩3¬φ.\nProofs that the other two are valid are similarly routine and left as exercises.\nAnother important formula which can be seen to be valid is the following:\n2(φ →ψ) ∧2φ →2ψ.\nIt is sometimes written in the equivalent, but slightly less intuitive, form\n2(φ →ψ) →(2φ →2ψ). This formula scheme is called K in most books\nabout modal logic, honouring the logician S. Kripke who, as we mentioned\nearlier, invented the so-called ‘possible worlds semantics’ of Deﬁnition 5.4.\nTo see that K is valid, again suppose we have some world x in some\nmodel M = (W, R, L). We have to show that x ⊩2(φ →ψ) ∧2φ →2ψ.\nAgain referring to Deﬁnition 5.4, we assume that x ⊩2(φ →ψ) ∧2φ and\ntry to prove that x ⊩2ψ:\nx ⊩2(φ →ψ) ∧2φ\niﬀx ⊩2(φ →ψ) and x ⊩2φ\niﬀfor all y with R(x, y), we have y ⊩φ →ψ and y ⊩φ\nimplies that, for all y with R(x, y), we have y ⊩ψ\niﬀx ⊩2ψ.\nThere aren’t any other interesting valid formulas in basic modal logic. Later,\nwe will see additional valid formulas in extended modal logics of interest.\n316\n5 Modal logics and agents\n5.3 Logic engineering\nHaving looked at the framework for basic modal logic, we turn now to how\none may formalise the diﬀerent modes of truth discussed at the beginning\nof this chapter. The basic framework is quite general and can be reﬁned\nin various ways to give us the properties appropriate for the intended ap-\nplications. Logic engineering is the subject of engineering logics to ﬁt new\napplications. It is potentially a very broad subject, drawing on all branches\nThis activity is essentially the construction of one line in the truth table of\n(p ∨¬q) →(q →p). How can we evaluate formulas in predicate logic, e.g.\n∀x ∃y ((P(x) ∨¬Q(y)) →(Q(x) →P(y)))\nwhich ‘enriches’ the formula of propositional logic above? Could we simply\nassume truth values for P(x), Q(y), Q(x) and P(y) and compute a truth\nvalue as before? Not quite, since we have to reﬂect the meaning of the\nquantiﬁers ∀x and ∃y, their dependences and the actual parameters of P\nand Q – a formula ∀x ∃y R(x, y) generally means something else other than\n∃y ∀x R(x, y); why? The problem is that variables are place holders for any,\nor some, unspeciﬁed concrete values. Such values can be of almost any kind:\nstudents, birds, numbers, data structures, programs and so on.\n124\n2 Predicate logic\nThus, if we encounter a formula ∃y ψ, we try to ﬁnd some instance of\ny (some concrete value) such that ψ holds for that particular instance of\ny. If this succeeds (i.e. there is such a value of y for which ψ holds), then\n∃y ψ evaluates to T; otherwise (i.e. there is no concrete value of y which\nrealises ψ) it returns F. Dually, evaluating ∀x ψ amounts to showing that\nψ evaluates to T for all possible values of x; if this is successful, we know\nthat ∀x ψ evaluates to T; otherwise (i.e. there is some value of x such that\nψ computes F) it returns F. Of course, such evaluations of formulas require\na ﬁxed universe of concrete values, the things we are, so to speak, talking\nabout. Thus, the truth value of a formula in predicate logic depends on, and\nvaries with, the actual choice of values and the meaning of the predicate and\nfunction symbols involved.\nIf variables can take on only ﬁnitely many values, we can write a program\nthat evaluates formulas in a compositional way. If the root node of φ is ∧,\n∨, →or ¬, we can compute the truth value of φ by using the truth table of\nthe respective logical connective and by computing the truth values of the\nbols in the same formula, we arrive at fully-ﬂedged second-order logic, e.g.\n∃P∀Q (∀x∀y (Q(x, y) →Q(y, x)) →∀u∀v (Q(u, v) →P(u, v))).\n(2.15)\nWe have ∃P∀Q (∀x∀y (Q(x, y) →Q(y, x)) →∀u∀v (Q(u, v) →P(u, v))) iﬀ\nthere is some T such that for all U we have (MT )U ⊨∀x∀y (Q(x, y) →\nQ(y, x)) →∀u∀v (Q(u, v) →P(u, v)), the latter being a model check in ﬁrst-\norder logic.\nIf one wants to quantify over relations of relations, one gets third-order\nlogic etc. Higher-order logics require great care in their design. Typical re-\nsults such as completeness and compactness may quickly fail to hold. Even\nworse, a naive higher-order logic may be inconsistent at the meta-level. Re-\nlated problems were discovered in naive set theory, e.g. in the attempt to\ndeﬁne the ‘set’ A that contains as elements those sets X that do not contain\nthemselves as an element:\nA\ndef\n= {X | X ̸∈X}.\n(2.16)\nWe won’t study higher-order logics in this text, but remark that many the-\norem provers or deductive frameworks rely on higher-order logical frame-\nworks.\n2.7 Micromodels of software\nTwo of the central concepts developed so far are\nr model checking: given a formula φ of predicate logic and a matching model M\ndetermine whether M ⊨φ holds; and\nr semantic entailment: given a set of formulas Γ of predicate logic, is Γ ⊨φ valid?\n142\n2 Predicate logic\nHow can we put these concepts to use in the modelling and reasoning about\nsoftware? In the case of semantic entailment, Γ should contain all the re-\nquirements we impose on a software design and φ may be a property we\nthink should hold in any implementation that meets the requirements Γ.\nSemantic entailment therefore matches well with software speciﬁcation and\nvalidation; alas, it is undecidable in general. Since model checking is de-\ncidable, why not put all the requirements into a model M and then check\nM ⊨φ? The diﬃculty with this approach is that, by comitting to a particu-\nlar model M, we are comitting to a lot of detail which doesn’t form part of\nVerify that these sequents express the argument above in a symbolic form.\nPredicate logic extends propositional logic not only with quantiﬁers but\nwith one more concept, that of function symbols. Consider the declarative\nsentence\nEvery child is younger than its mother.\n2.1 The need for a richer language\n97\nUsing predicates, we could express this sentence as\n∀x ∀y (C(x) ∧M(y, x) →Y (x, y))\nwhere C(x) means that x is a child, M(x, y) means that x is y’s mother\nand Y (x, y) means that x is younger than y. (Note that we actually used\nM(y, x) (y is x’s mother), not M(x, y).) As we have coded it, the sentence\nsays that, for all children x and any mother y of theirs, x is younger than y.\nIt is not very elegant to say ‘any of x’s mothers’, since we know that every\nindividual has one and only one mother1. The inelegance of coding ‘mother’\nas a predicate is even more apparent if we consider the sentence\nAndy and Paul have the same maternal grandmother.\nwhich, using ‘variables’ a and p for Andy and Paul and a binary predicate\nM for mother as before, becomes\n∀x ∀y ∀u ∀v (M(x, y) ∧M(y, a) ∧M(u, v) ∧M(v, p) →x = u).\nThis formula says that, if y and v are Andy’s and Paul’s mothers, respec-\ntively, and x and u are their mothers (i.e. Andy’s and Paul’s maternal grand-\nmothers, respectively), then x and u are the same person. Notice that we\nused a special predicate in predicate logic, equality; it is a binary predicate,\ni.e. it takes two arguments, and is written =. Unlike other predicates, it is\nusually written in between its arguments rather than before them; that is,\nwe write x = y instead of = (x, y) to say that x and y are equal.\nThe function symbols of predicate logic give us a way of avoiding this\nugly encoding, for they allow us to represent y’s mother in a more direct\nway. Instead of writing M(x, y) to mean that x is y’s mother, we simply\nwrite m(y) to mean y’s mother. The symbol m is a function symbol: it takes\nwe conclude that M ⊨l φ holds, or does not hold, regardless of the choice of\nl. Thus, for sentences φ we often elide l and write M ⊨φ since the choice of\nan environment l is then irrelevant.\nExample 2.19 Let us illustrate the deﬁnitions above by means of an-\nother simple example. Let F\ndef\n= {alma} and P\ndef\n= {loves} where alma is a\nconstant and loves a predicate with two arguments. The model M we\nchoose here consists of the privacy-respecting set A\ndef\n= {a, b, c}, the constant\nfunction almaM def\n= a and the predicate lovesM def\n= {(a, a), (b, a), (c, a)}, which\nhas two arguments as required. We want to check whether the model M\nsatisﬁes\nNone of Alma’s lovers’ lovers love her.\nFirst, we need to express the, morally worrying, sentence in predicate logic.\nHere is such an encoding (as we already discussed, diﬀerent but logically\nequivalent encodings are possible):\n∀x ∀y (loves(x, alma) ∧loves(y, x) →¬loves(y, alma)) .\n(2.8)\n2.4 Semantics of predicate logic\n129\nDoes the model M satisfy this formula? Well, it does not; for we may choose\na for x and b for y. Since (a, a) is in the set lovesM and (b, a) is in the\nset lovesM, we would need that the latter does not hold since it is the\ninterpretation of loves(y, alma); this cannot be.\nAnd what changes if we modify M to M′, where we keep A and almaM,\nbut redeﬁne the interpretation of loves as lovesM′ def\n= {(b, a), (c, b)}? Well,\nnow there is exactly one lover of Alma’s lovers, namely c; but c is not one\nof Alma’s lovers. Thus, the formula in (2.8) holds in the model M′.\n2.4.2 Semantic entailment\nIn propositional logic, the semantic entailment φ1, φ2, . . . , φn ⊨ψ holds iﬀ:\nwhenever all φ1, φ2, . . . , φn evaluate to T, the formula ψ evaluates to T as well.\nHow can we deﬁne such a notion for formulas in predicate logic, considering\nthat M ⊨l φ is indexed with an environment?\nDeﬁnition 2.20 Let Γ be a (possibly inﬁnite) set of formulas in predicate\nlogic and ψ a formula of predicate logic.\n1.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-6-subsection-2",
                            "title": "Universal Second-Order Logic",
                            "content": "bols in the same formula, we arrive at fully-ﬂedged second-order logic, e.g.\n∃P∀Q (∀x∀y (Q(x, y) →Q(y, x)) →∀u∀v (Q(u, v) →P(u, v))).\n(2.15)\nWe have ∃P∀Q (∀x∀y (Q(x, y) →Q(y, x)) →∀u∀v (Q(u, v) →P(u, v))) iﬀ\nthere is some T such that for all U we have (MT )U ⊨∀x∀y (Q(x, y) →\nQ(y, x)) →∀u∀v (Q(u, v) →P(u, v)), the latter being a model check in ﬁrst-\norder logic.\nIf one wants to quantify over relations of relations, one gets third-order\nlogic etc. Higher-order logics require great care in their design. Typical re-\nsults such as completeness and compactness may quickly fail to hold. Even\nworse, a naive higher-order logic may be inconsistent at the meta-level. Re-\nlated problems were discovered in naive set theory, e.g. in the attempt to\ndeﬁne the ‘set’ A that contains as elements those sets X that do not contain\nthemselves as an element:\nA\ndef\n= {X | X ̸∈X}.\n(2.16)\nWe won’t study higher-order logics in this text, but remark that many the-\norem provers or deductive frameworks rely on higher-order logical frame-\nworks.\n2.7 Micromodels of software\nTwo of the central concepts developed so far are\nr model checking: given a formula φ of predicate logic and a matching model M\ndetermine whether M ⊨φ holds; and\nr semantic entailment: given a set of formulas Γ of predicate logic, is Γ ⊨φ valid?\n142\n2 Predicate logic\nHow can we put these concepts to use in the modelling and reasoning about\nsoftware? In the case of semantic entailment, Γ should contain all the re-\nquirements we impose on a software design and φ may be a property we\nthink should hold in any implementation that meets the requirements Γ.\nSemantic entailment therefore matches well with software speciﬁcation and\nvalidation; alas, it is undecidable in general. Since model checking is de-\ncidable, why not put all the requirements into a model M and then check\nM ⊨φ? The diﬃculty with this approach is that, by comitting to a particu-\nlar model M, we are comitting to a lot of detail which doesn’t form part of\n5 In most object-oriented languages, e.g. Java, extends creates a new type. In Alloy 2.0 and 2.1, it\ncreates a subset of a type and not a new type as such, where the subset has additional structure\nand may need to satisfy additional constraints.\n170\n2 Predicate logic\ndetermine whether they can be expressed in ﬁrst-order logic, existential second-\norder logic or universal second-order logic.\n9. Recalling the comment on page 142 that Alloy combines model checking M ⊨φ\nand validity checking Γ ⊨φ, can you discuss to what extent this is so?\n2.9 Bibliographic notes\nMany design decisions have been taken in the development of predicate\nlogic in the form known today. The Greeks and the medievals had systems\nin which many of the examples and exercises in this book could be rep-\nresented, but nothing that we would recognise as predicate logic emerged\nuntil the work of Gottlob Frege in 1879, printed in [Fre03]. An account of\nthe contributions of the many other people involved in the development of\nlogic can be found in the ﬁrst few pages of W. Hodges’ chapter in [Hod83].\nThere are many books covering classical logic and its use in computer sci-\nence; we give a few incomplete pointers to the literature. The books [SA91],\n[vD89] and [Gal87] cover more theoretical applications than those in this\nbook, including type theory, logic programming, algebraic speciﬁcation and\nterm-rewriting systems. An approach focusing on automatic theorem prov-\ning is taken by [Fit96]. Books which study the mathematical aspects of\npredicate logic in greater detail, such as completeness of the proof systems\nand incompleteness of ﬁrst-order arithmetic, include [Ham78] and [Hod83].\nMost of these books present other proof systems besides natural deduction\nsuch as axiomatic systems and tableau systems. Although natural deduction\nhas the advantages of elegance and simplicity over axiomatic methods, there\nare few expositions of it in logic books aimed at a computer science audi-\nr If φ is a formula and x is a variable, then (∀x φ) and (∃x φ) are formulas.\nr Nothing else is a formula.\nNote how the arguments given to predicates are always terms. This can also\nbe seen in the Backus Naur form (BNF) for predicate logic:\nφ ::= P(t1, t2, . . . , tn) | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (∀x φ) | (∃x φ)\n(2.2)\nwhere P ∈P is a predicate symbol of arity n ≥1, ti are terms over F and x\nis a variable. Recall that each occurrence of φ on the right-hand side of the\n::= stands for any formula already constructed by these rules. (What role\ncould predicate symbols of arity 0 play?)\n2.2 Predicate logic as a formal language\n101\n∀x\n∧\n→\nS\nP\nQ\nx\ny\nx\nx\nFigure 2.1. A parse tree of a predicate logic formula.\nConvention 2.4 For convenience, we retain the usual binding priorities\nagreed upon in Convention 1.3 and add that ∀y and ∃y bind like ¬. Thus,\nthe order is:\nr ¬, ∀y and ∃y bind most tightly;\nr then ∨and ∧;\nr then →, which is right-associative.\nWe also often omit brackets around quantiﬁers, provided that doing so in-\ntroduces no ambiguities.\nPredicate logic formulas can be represented by parse trees. For example,\nthe parse tree in Figure 2.1 represents the formula ∀x ((P(x) →Q(x)) ∧\nS(x, y)).\nExample 2.5 Consider translating the sentence\nEvery son of my father is my brother.\ninto predicate logic. As before, the design choice is whether we represent\n‘father’ as a predicate or as a function symbol.\n1.\nAs a predicate. We choose a constant m for ‘me’ or ‘I,’ so m is a term, and we\nchoose further {S, F, B} as the set of predicates with meanings\n102\n2 Predicate logic\nS(x, y) :\nx is a son of y\nF(x, y) :\nx is the father of y\nB(x, y) :\nx is a brother of y.\nThen the symbolic encoding of the sentence above is\n∀x ∀y (F(x, m) ∧S(y, x) →B(y, m))\n(2.3)\nsaying: ‘For all x and all y, if x is a father of m and if y is a son of x, then y is\na brother of m.’\n2.\nAs a function. We keep m, S and B as above and write f for the function which,\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nConvention 3.13 We assume similar binding priorities for the CTL con-\nnectives to what we did for propositional and predicate logic. The unary\nconnectives (consisting of ¬ and the temporal connectives AG, EG, AF, EF,\nAX and EX) bind most tightly. Next in the order come ∧and ∨; and after\nthat come →, AU and EU .\nNaturally, we can use brackets in order to override these priorities. Let\nus see some examples of well-formed CTL formulas and some examples\nwhich are not well-formed, in order to understand the syntax. Suppose\nthat p, q and r are atomic formulas. The following are well-formed CTL\nformulas:\nr AG (q →EG r), note that this is not the same as AG q →EG r, for according to\nConvention 3.13, the latter formula means (AG q) →(EG r)\nr EF E[r U q]\nr A[p U EF r]\nr EF EG p →AF r, again, note that this binds as (EF EG p) →AF r, not\nEF (EG p →AF r) or EF EG (p →AF r)\nr A[p1 U A[p2 U p3]]\nr E[A[p1 U p2] U p3]\nr AG (p →A[p U (¬p ∧A[¬p U q])]).\nIt is worth spending some time seeing how the syntax rules allow us to\nconstruct each of these. The following are not well-formed formulas:\nr EF G r\nr A¬G ¬p\nr F [r U q]\nr EF (r U q)\nr AEF r\nr A[(r U q) ∧(p U r)].\nIt is especially worth understanding why the syntax rules don’t allow us to\nconstruct these. For example, take EF (r U q). The problem with this string\nis that U can occur only when paired with an A or an E. The E we have is\npaired with the F. To make this into a well-formed CTL formula, we would\nhave to write EF E[r U q] or EF A[r U q].\n210\n3 Verification by model checking\nAU\nEU\nAX\n¬\n¬\nEX\np\np\n∧\nq\np\nFigure 3.18. The parse tree of a CTL formula without infix notation.\nNotice that we use square brackets after the A or E, when the paired\neach term t (free for x in φ), and we should make our choice on the basis of\nconsistent pattern matching. Further, note that we have rules ∀x i and ∀x e\nfor each variable x. In particular, there are rules ∀y i, ∀y e and so on. We\n112\n2 Predicate logic\nwill write ∀i and ∀e when we speak about such rules without concern for the\nactual quantiﬁer variable.\nNotice also that, although the square brackets representing substitution\nappear in the rules ∀i and ∀e, they do not appear when we use those rules.\nThe reason for this is that we actually carry out the substitution that is asked\nfor. In the rules, the expression φ[t/x] means: ‘φ, but with free occurrences\nof x replaced by t.’ Thus, if φ is P(x, y) →Q(y, z) and the rule refers to\nφ[a/y], we carry out the substitution and write P(x, a) →Q(a, z) in the\nproof.\nA helpful way of understanding the universal quantiﬁer rules is to com-\npare the rules for ∀with those for ∧. The rules for ∀are in some sense\ngeneralisations of those for ∧; whereas ∧has just two conjuncts, ∀acts like\nit conjoins lots of formulas (one for each substitution instance of its vari-\nable). Thus, whereas ∧i has two premises, ∀x i has a premise φ[x0/x] for\neach possible ‘value’ of x0. Similarly, where and-elimination allows you to\ndeduce from φ ∧ψ whichever of φ and ψ you like, forall-elimination allows\nyou to deduce φ[t/x] from ∀x φ, for whichever t you (and the side condition)\nlike. To say the same thing another way: think of ∀x i as saying: to prove\n∀x φ, you have to prove φ[x0/x] for every possible value x0; while ∧i says\nthat to prove φ1 ∧φ2 you have to prove φi for every i = 1, 2.\nThe proof rules for existential quantification\nThe analogy between\n∀and ∧extends also to ∃and ∨; and you could even try to guess the rules\nfor ∃by starting from the rules for ∨and applying the same ideas as those\nthat related ∧to ∀. For example, we saw that the rules for or-introduction\nwere a sort of dual of those for and-elimination; to emphasise this point, we",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-7",
                    "title": "Micromodels of Software",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-7-subsection-1",
                            "title": "State Machines",
                            "content": "2.7 Micromodels of software\n145\nmodule AboutStateMachines\nsig State {}\n-- simple states\nsig StateMachine { -- composite state machines\nA : set State,\n-- set of states of a state machine\ni : A,\n-- initial state of a state machine\nF : set A,\n-- set of final states of a state machine\nR : A -> A\n-- transition relation of a state machine\n}\n-- Claim that final states are never initial: false.\nassert FinalNotInitial {\nall M : StateMachine | no M.i & M.F\n} check FinalNotInitial for 3 but 1 StateMachine\n-- Is there a three-state machine with a non-final deadlock? True.\nfun AGuidedSimulation(M : StateMachine, s : M.A) {\nno s.(M.R)\nnot s in M.F\n# M.A = 3\n} run AGuidedSimulation for 3 but 1 StateMachine\nFigure 2.6. The complete Alloy module for models of state machines,\nwith one assertion and one consistency check. The lexeme -- enables\ncomments on the same line.\nState_0\nR\nState_1\n(F)\nState_2\n(i, F)\nFigure 2.7. Alloy’s analyzer finds a state machine model (with one\ntransition only) within the specified scope such that the assertion\nFinalNotInitial is false: the initial state State 2 is also final.\nThis consistency check is named AGuidedSimulation and followed by an\nordered ﬁnite list of parameter/type pairs; the ﬁrst parameter is M of type\nStateMachine, the second one is s of type M.A – i.e. s is a state of M. The\nbody of a consistency check is a ﬁnite list of constraints (here three), which\nare conjoined implicitly. In this case, we want to ﬁnd a model with instances\nof the parameters M and s such that s is a non-ﬁnal state of M, the second\nconstraint not s in M.F plus the type information s : M.A; and there is\nno transition out of s, the ﬁrst constraint no s.(M.R).\nThe latter requires further explanation. The keyword no denotes ‘there\nis no;’ here it is applied to the set s.(M.R), expressing that there are no\n146\n2 Predicate logic\nState_0\nState_2\n(i)\nR\nState_1\nR\nFigure 2.8. Alloy’s analyzer finds a state machine model within the\nveriﬁcation in the early 1990s, because they have allowed systems with much\nlarger state spaces to be veriﬁed. In this section, we describe in detail how\nthe model-checking algorithm presented in Chapter 3 can be implemented\nusing OBDDs as the basic data structure.\nThe pseudo-code presented in Figure 3.28 on page 227 takes as input a\nCTL formula φ and returns the set of states of the given model which satisfy\nφ. Inspection of the code shows that the algorithm consists of manipulating\nintermediate sets of states. We show in this section how the model and the\nintermediate sets of states can be stored as OBDDs; and how the operations\nrequired in that pseudo-code can be implemented in terms of the operations\non OBDDs which we have seen in this chapter.\nWe start by showing how sets of states are represented with OBDDs,\ntogether with some of the operations required. Then, we extend that to\nthe representation of the transition system; and ﬁnally, we show how the\nremainder of the required operations is implemented.\n6.3 Symbolic model checking\n383\nModel checking using OBDDs is called symbolic model checking. The term\nemphasises that individual states are not represented; rather, sets of states\nare represented symbolically, namely, those which satisfy the formula being\nchecked.\n6.3.1 Representing subsets of the set of states\nLet S be a ﬁnite set (we forget for the moment that it is a set of states). The\ntask is to represent the various subsets of S as OBDDs. Since OBDDs encode\nboolean functions, we need somehow to code the elements of S as boolean\nvalues. The way to do this in general is to assign to each element s ∈S a\nunique vector of boolean values (v1, v2, . . . , vn), each vi ∈{0, 1}. Then, we\nrepresent a subset T by the boolean function fT which maps (v1, v2, . . . , vn)\nonto 1 if s ∈T and maps it onto 0 otherwise.\nThere are 2n boolean vectors (v1, v2, . . . , vn) of length n. Therefore, n\nshould be chosen such that 2n−1 < |S| ≤2n, where |S| is the number of\ntion [MP91, MP95, Ros97, Hol90]. The SMV code contained in this chapter\ncan be downloaded from www.cs.bham.ac.uk/research/lics/.\n12 www.dcs.ed.ac.uk/home/cwb\n13 www.cs.sunysb.edu/~cwb\n14 http://bogor.projects.cis.ksu.edu/\n4\nProgram verification\nThe methods of the previous chapter are suitable for verifying systems of\ncommunicating processes, where control is the main issue, but there are no\ncomplex data. We relied on the fact that those (abstracted) systems are\nin a ﬁnite state. These assumptions are not valid for sequential programs\nrunning on a single processor, the topic of this chapter. In those cases, the\nprograms may manipulate non-trivial data and – once we admit variables of\ntype integer, list, or tree – we are in the domain of machines with inﬁnite\nstate space.\nIn terms of the classiﬁcation of veriﬁcation methods given at the beginning\nof the last chapter, the methods of this chapter are\nProof-based. We do not exhaustively check every state that the system\ncan get in to, as one does with model checking; this would be impossi-\nble, given that program variables can have inﬁnitely many interacting\nvalues. Instead, we construct a proof that the system satisﬁes the prop-\nerty at hand, using a proof calculus. This is analogous to the situation\nin Chapter 2, where using a suitable proof calculus avoided the prob-\nlem of having to check inﬁnitely many models of a set of predicate logic\nformulas in order to establish the validity of a sequent.\nSemi-automatic. Although many of the steps involved in proving that\na program satisﬁes its speciﬁcation are mechanical, there are some steps\nthat involve some intelligence and that cannot be carried out algorith-\nmically by a computer. As we will see, there are often good heuristics\nto help the programmer complete these tasks. This contrasts with the\nsituation of the last chapter, which was fully automatic.\nProperty-oriented. Just like in the previous chapter, we verify proper-\nbegin\nW := SAT (φ);\nX := S;\nY := SAT (ψ);\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∪(W ∩pre∃(Y ))\nend\nreturn Y\nend\nFigure 3.31. The function SATEU. It computes the states satisfying φ by\ncalling SAT. Then, it accumulates states satisfying E[φ U ψ] in the manner\ndescribed in the labelling algorithm.\nThe ‘state explosion’ problem\nAlthough the labelling algorithm (with\nthe clever way of handling EG) is linear in the size of the model, unfortu-\nnately the size of the model is itself more often than not exponential in the\nnumber of variables and the number of components of the system which\nexecute in parallel. This means that, for example, adding a boolean variable\nto your program will double the complexity of verifying a property of it.\nThe tendency of state spaces to become very large is known as the state\nexplosion problem. A lot of research has gone into ﬁnding ways of overcoming\nit, including the use of:\nr Eﬃcient data structures, called ordered binary decision diagrams (OBDDs),\nwhich represent sets of states instead of individual states. We study these in\nChapter 6 in detail. SMV is implemented using OBDDs.\nr Abstraction: one may interpret a model abstractly, uniformly or for a speciﬁc\nproperty.\nr Partial order reduction: for asynchronous systems, several interleavings of com-\nponent traces may be equivalent as far as satisfaction of the formula to be checked\nis concerned. This can often substantially reduce the size of the model-checking\nproblem.\nr Induction: model-checking systems with (e.g.) large numbers of identical, or sim-\nilar, components can often be implemented by ‘induction’ on this number.\n230\n3 Verification by model checking\nr Composition: break the veriﬁcation problem down into several simpler veriﬁca-\ntion problems.\nThe last four issues are beyond the scope of this book, but references may\nbe found at the end of this chapter.\n3.6.2 CTL model checking with fairness\nThe veriﬁcation of M, s0 ⊨φ might fail because the model M may contain\nr If we get a positive answer, we are somewhat conﬁdent that the property holds\nin all models. In this case, the answer is not conclusive, because there could be\na larger model which fails the property, but nevertheless a positive answer gives\nus some conﬁdence.\nr If we get a negative answer, then we have found a model in M which violates\nthe property. In that case, we have a conclusive answer, and can inspect the\nmodel in question.\nD. Jackson’s small scope hypothesis states that negative answers tend to\noccur in small models already, boosting the conﬁdence we may have in a\npositive answer. Here is how one could write the requirements for M for\nstate machines in Alloy:\nsig State {}\nsig StateMachine {\nA : set State,\ni : A,\nF : set A,\nR : A -> A\n}\nThe model speciﬁes two signatures. Signature State is simple in that it has\nno internal structure, denoted by {}. Although the states of real systems may\n144\n2 Predicate logic\nwell have internal structure, our Alloy declaration abstracts it away. The\nsecond signature StateMachine has internal, composite structure, saying\nthat every state machine has a set of states A, an initial state i from A, a set\nof ﬁnal states F from A, and a transition relation R of type A -> A. If we read\n-> as the cartesian product ×, we see that this internal structure is simply\nthe structural information needed for models of Example 2.15 (page 125).\nConcrete models of state machines are instances of signature StateMachine.\nIt is useful to think of signatures as sets whose elements are the instances of\nthat signature. Elements possess all the structure declared in their signature.\nGiven these signatures, we can code and check an assertion:\nassert FinalNotInitial {\nall M : StateMachine | no M.i & M.F\n} check FinalNotIntial for 3 but 1 StateMachine\ndeclares an assertion named FinalNotInitial whose body speciﬁes that\nfor all models M of type StateMachine the property no M.i & M.F is true.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-7-subsection-2",
                            "title": "Alma – Revisited",
                            "content": "052154310x\nAcknowledgements\nMany people have, directly or indirectly, assisted us in writing this book.\nDavid Schmidt kindly provided serveral exercises for Chapter 4. Krysia\nBroda has pointed out some typographical errors and she and the other\nauthors of [BEKV94] have allowed us to use some exercises from that book.\nWe have also borrowed exercises or examples from [Hod77] and [FHMV95].\nSusan Eisenbach provided a ﬁrst description of the Package Dependency\nSystem that we model in Alloy in Chapter 2. Daniel Jackson make very\nhelpful comments on versions of that section. Zena Matilde Ariola, Josh\nHodas, Jan Komorowski, Sergey Kotov, Scott A. Smolka and Steve Vickers\nhave corresponded with us about this text; their comments are appreciated.\nMatt Dwyer and John Hatcliﬀmade useful comments on drafts of Chap-\nter 3. Kevin Lucas provided insightful comments on the content of Chapter\n6, and notiﬁed us of numerous typographical errors in several drafts of the\nbook. Achim Jung read several chapters and gave useful feedback.\nAdditionally, a number of people read and provided useful comments on\nseveral chapters, including Moti Ben-Ari, Graham Clark, Christian Haack,\nAnthony Hook, Roberto Segala, Alan Sexton and Allen Stoughton. Numer-\nous students at Kansas State University and the University of Birmingham\nhave given us feedback of various kinds, which has inﬂuenced our choice and\npresentation of the topics. We acknowledge Paul Taylor’s LATEX package for\nproof boxes. About half a dozen anonymous referees made critical, but con-\nstructive, comments which helped to improve this text in various ways. In\nspite of these contributions, there may still be errors in the book, and we\nalone must take responsibility for those.\nAdded for second edition\nMany people have helped improve this text by pointing out typos and\nmaking other useful comments after the publication date. Among them,\nxiii\nxiv\nAcknowledgements\nwe mention Wolfgang Ahrendt, Yasuhiro Ajiro, Torben Amtoft, Stephan\n=\nn√\nak where\nn√x is the real number y such that yn = x. From\nreal analysis one knows that any real number b can be approximated by a\nsequence of rational numbers k0/n0, k1/n1, . . . Then we deﬁne ab to be the\nreal number approximated by the sequence ak0/n0, ak1/n1, . . . (In calculus,\none can show that this ‘limit’ ab is unique and independent of the choice of\napproximating sequence.) Also, one calls a real number irrational if it can’t\nbe written in the form k/n for some integers k and n ̸= 0. In the exercises\nyou will be asked to ﬁnd a semi-formal proof showing that\n√\n2 is irrational.\nWe now present a proof of a fact about real numbers in the informal style\nused by mathematicians (this proof can be formalised as a natural deduction\nproof in the logic presented in Chapter 2). The fact we prove is:\nTheorem 1.26 There exist irrational numbers a and b such that ab is ra-\ntional.\nProof: We choose b to be\n√\n2 and proceed by a case analysis. Either bb is\nirrational, or it is not. (Thus, our proof uses ∨e on an instance of LEM.)\n1.3 Propositional logic as a formal language\n31\n(i)\nAssume that bb is rational. Then this proof is easy since we can choose irra-\ntional numbers a and b to be\n√\n2 and see that ab is just bb which was assumed\nto be rational.\n(ii)\nAssume that bb is irrational. Then we change our strategy slightly and choose\na to be\n√\n2\n√\n2. Clearly, a is irrational by the assumption of case (ii). But we\nknow that b is irrational (this was known by the ancient Greeks; see the proof\noutline in the exercises). So a and b are both irrational numbers and\nab = (\n√\n2\n√\n2)\n√\n2\n=\n√\n2\n(\n√\n2·\n√\n2) = (\n√\n2)\n2 = 2\nis rational, where we used the law (xy)z = x(y·z).\nSince the two cases above are exhaustive (either bb is irrational, or it isn’t)\nwe have proven the theorem.\n2\nThis proof is perfectly legitimate and mathematicians use arguments like\nthat all the time. The exhaustive nature of the case analysis above rests on\nFigure 2.9. It names the module AboutAlma and deﬁnes a simple signature of\ntype Person. Then it declares a signature SoapOpera which has a cast – a\nset of type Person – a designated cast member alma, and a relation loves\nof type cast -> cast. We check the assertion OfLovers in a scope of at\nmost two persons and at most one soap opera. The body of that assertion\nis the typed version of (2.8) and deserves a closer look:\n1.\nExpressions of the form all x : T | F state that formula F is true for all\ninstances x of type T. So the assertion states that with S {...} is true for all\nsoap operas S.\n2.7 Micromodels of software\n147\nmodule AboutAlma\nsig Person {}\nsig SoapOpera {\ncast : set Person,\nalma : cast,\nloves : cast -> cast\n}\nassert OfLovers {\nall S : SoapOpera |\nwith S {\nall x, y : cast |\nalma in x.loves && x in y.loves => not alma in y.loves\n}\n}\ncheck OfLovers for 2 but 1 SoapOpera\nFigure 2.9. In this module, the analysis of OfLovers checks whether\nthere is a model of ≤2 persons and ≤1 soap operas for which the\nquery in (2.8), page 128, is false.\nPerson_1\n(cast, alma)\nloves\nPerson_0\nFigure 2.10. Alloy’s analyzer finds a counterexample to the formula in\n(2.8): Alma is the only cast member and loves herself.\n2.\nThe expression with S {...} is a convenient notation that allows us to write\nloves and cast instead of the needed S.loves and S.cast (respectively) within\nits curly brackets.\n3.\nIts body ... states that for all x, and y in the cast of S, if alma is loved by x\nand x is loved by y, then – the symbol => expresses implication – alma is not\nloved by y.\nAlloy’s analysis ﬁnds a counterexample to this assertion, shown in Fig-\nure 2.10. It is a counterexample since alma is her own lover, and therefore\nalso one of her lover’s lovers’. Apparently, we have underspeciﬁed our model:\nwe implicitly made the domain-speciﬁc assumption that self-love makes for\n148\n2 Predicate logic\nPerson_1\n(cast)\nPerson_0\n(cast, alma)\nloves\nPerson_2\n(cast)\nloves\nloves\nalso one of her lover’s lovers’. Apparently, we have underspeciﬁed our model:\nwe implicitly made the domain-speciﬁc assumption that self-love makes for\n148\n2 Predicate logic\nPerson_1\n(cast)\nPerson_0\n(cast, alma)\nloves\nPerson_2\n(cast)\nloves\nloves\nFigure 2.11. Alloy’s analyzer finds a counterexample to the formula in\n(2.8) that meets the constraint of NoSelfLove with three cast members.\nThe bidirectional arrow indicates that Person 1 loves Person 2 and vice\nversa.\na poor script of jealousy and intrigue, but did not rule out self-love in our\nAlloy module. To remedy this, we can add a fact to the module; facts may\nhave names and restrict the set of possible models: assertions and consis-\ntency checks are conducted only over concrete models that satisfy all facts\nof the module. Adding the declaration\nfact NoSelfLove {\nall S : SoapOpera, p : S.cast | not p in p.(S.loves)\n}\nto the module AboutAlma enforces that no member of any soap-opera cast\nloves him or herself. We re-check the assertion and the analyzer informs us\nthat no solution was found. This suggests that our model from Example 2.19\nis indeed a minimal one in the presence of that domain assumption. If we\nretain that fact, but change the occurrence of 2 in the check directive to 3,\nwe get a counterexample, depicted in Figure 2.11. Can you see why it is a\ncounterexample?\n2.7.3 A software micromodel\nSo far we used Alloy to generate instances of models of ﬁrst-order logic that\nsatisfy certain constraints expressed as formulas of ﬁrst-order logic. Now we\napply Alloy and its constraint analyzer to a more serious task: we model a\nsoftware system. The intended beneﬁts provided by a system model are\n1.\nit captures formally static and dynamic system structure and behaviour;\n2.\nit can verify consistency of the constrained design space;\n2.7 Micromodels of software\n149\n3.\nit is executable, so it allows guided simulations through a potentially very com-\nplex design space; and\n4.\nstabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\ncode in Figure 3.28, we see that most of these clauses just do the obvious\nand correct thing according to the semantics of CTL. For example, try out\nwhat SAT does when you call it with φ1 →φ2.\nOur aim in this section is to prove the termination and correctness\nof SATAF and SATEU. In fact, we will also write a procedure SATEG and\nprove its termination and correctness1. The procedure SATEG is given in\nFigure 3.37 and is based on the intuitions given in Section 3.6.1: note how\ndeleting the label if none of the successor states is labelled is coded as\nintersecting the labelled set with the set of states which have a labelled\nsuccessor.\nThe semantics of EG φ says that s0 ⊨EG φ holds iﬀthere exists a com-\nputation path s0 →s1 →s2 →. . . such that si ⊨φ holds for all i ≥0. We\ncould instead express it as follows: EG φ holds if φ holds and EG φ holds\nin one of the successor states to the current state. This suggests the equiv-\nalence EG φ ≡φ ∧EX EG φ which can easily be proved from the semantic\ndeﬁnitions of the connectives.\nObserving that [[EX ψ]] = pre∃([[ψ]]) we see that the equivalence above\ncan be written as [[EG φ]] = [[φ]] ∩pre∃([[EG φ]]). This does not look like a\nvery promising way of calculating EG φ, because we need to know EG φ in\norder to work out the right-hand side. Fortunately, there is a way around\nthis apparent circularity, known as computing ﬁxed points, and that is the\nsubject of this section.\n1 Section 3.6.1 handles EG φ by translating it into ¬AF ¬φ, but we already noted in Section 3.6.1\nthat EG could be handled directly.\n240\n3 Verification by model checking\nfunction SATEG (φ)\n/* determines the set of states satisfying EG φ */\nlocal var X, Y\nbegin\nY := SAT (φ);\nX := ∅;\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∩pre∃(Y )",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-7-subsection-3",
                            "title": "A Software Micromodel",
                            "content": "1.\nit captures formally static and dynamic system structure and behaviour;\n2.\nit can verify consistency of the constrained design space;\n2.7 Micromodels of software\n149\n3.\nit is executable, so it allows guided simulations through a potentially very com-\nplex design space; and\n4.\nit can boost our conﬁdence into the correctness of claims about static and\ndynamic aspects of all its compliant implementations.\nMoreover, formal models attached to software products can be seen as a\nreliability contract; a promise that the software implements the structure and\nbehaviour of the model and is expected to meet all of the assertions certiﬁed\ntherein. (However, this may not be very useful for extremely under-speciﬁed\nmodels.)\nWe will model a software package dependency system. This system is used\nwhen software packages are installed or upgraded. The system checks to see\nif prerequisites in the form of libraries or other packages are present. The\nrequirements on a software package dependency system are not straightfor-\nward. As most computer users know, the upgrading process can go wrong\nin various ways. For example, upgrading a package can involve replacing\nshared libraries with newer versions. But other packages which rely on the\nolder versions of the shared libraries may then cease to work.\nSoftware package dependency systems are used in several computer sys-\ntems, such as Red Hat Linux, .NET’s Global Assembly Cache and others.\nUsers often have to guess how technical questions get resolved within the de-\npendency system. To the best of our knowledge, there is no publicly available\nformal and executable model of any particular dependency system to which\napplication programmers could turn if they had such non-trivial technical\nquestions about its inner workings.\nIn our model, applications are built out of components. Components oﬀer\nservices to other components. A service can be a number of things. Typically,\nsociety depends on it increase, the beneﬁts are becoming more important.\nThus, we can expect that the importance of veriﬁcation to industry will\ncontinue to increase over the next decades. Microsoft’s emergent technology\nA# combines program veriﬁcation, testing, and model-checking techniques\nin an integrated in-house development environment.\nCurrently, many companies struggle with a legacy of ancient code with-\nout proper documentation which has to be adapted to new hardware and\nnetwork environments, as well as ever-changing requirements. Often, the\noriginal programmers who might still remember what certain pieces of code\nare for have moved, or died. Software systems now often have a longer\nlife-expectancy than humans, which necessitates a durable, transparent and\nportable design and implementation process; the year-2000 problem was just\none such example. Software veriﬁcation provides some of this.\n4.2 A framework for software verification\nSuppose you are working for a software company and your task is to write\nprograms which are meant to solve sophisticated problems, or computations.\nTypically, such a project involves an outside customer – a utility company,\nfor example – who has written up an informal description, in plain English,\nof the real-world task that is at hand. In this case, it could be the devel-\nopment and maintenance of a database of electricity accounts with all the\npossible applications of that – automated billing, customer service etc. Since\nthe informality of such descriptions may cause ambiguities which eventually\ncould result in serious and expensive design ﬂaws, it is desirable to condense\nall the requirements of such a project into formal speciﬁcations. These formal\nspeciﬁcations are usually symbolic encodings of real-world constraints into\nsome sort of logic. Thus, a framework for producing the software could be:\nr Convert the informal description R of requirements for an application domain\nspeciﬁcations are usually symbolic encodings of real-world constraints into\nsome sort of logic. Thus, a framework for producing the software could be:\nr Convert the informal description R of requirements for an application domain\ninto an ‘equivalent’ formula φR of some symbolic logic;\nr Write a program P which is meant to realise φR in the programming environment\nsupplied by your company, or wanted by the particular customer;\nr Prove that the program P satisﬁes the formula φR.\nThis scheme is quite crude – for example, constraints may be actual design\ndecisions for interfaces and data types, or the speciﬁcation may ‘evolve’\n4.2 A framework for software verification\n259\nand may partly be ‘unknown’ in big projects – but it serves well as a ﬁrst\napproximation to trying to deﬁne good programming methodology. Several\nvariations of such a sequence of activities are conceivable. For example,\nyou, as a programmer, might have been given only the formula φR, so you\nmight have little if any insight into the real-world problem which you are\nsupposed to solve. Technically, this poses no problem, but often it is handy\nto have both informal and formal descriptions available. Moreover, crafting\nthe informal requirements R is often a mutual process between the client\nand the programmer, whereby the attempt at formalising R can uncover\nambiguities or undesired consequences and hence lead to revisions of R.\nThis ‘going back and forth’ between the realms of informal and formal\nspeciﬁcations is necessary since it is impossible to ‘verify’ whether an infor-\nmal requirement R is equivalent to a formal description φR. The meaning\nof R as a piece of natural language is grounded in common sense and gen-\neral knowledge about the real-world domain and often based on heuristics\nor quantitative reasoning. The meaning of a logic formula φR, on the other\nhand, is deﬁned in a precise mathematical, qualitative and compositional\n‘New Symbolic Model Veriﬁer.’ NuSMV is an Open Source product, is ac-\ntively supported and has a substantial user community. For details on how\nto obtain it, see the bibliographic notes at the end of the chapter.\nNuSMV (sometimes called simply SMV) provides a language for describ-\ning the models we have been drawing as diagrams and it directly checks the\nvalidity of LTL (and also CTL) formulas on those models. SMV takes as\ninput a text consisting of a program describing a model and some speciﬁca-\ntions (temporal logic formulas). It produces as output either the word ‘true’\nif the speciﬁcations hold, or a trace showing why the speciﬁcation is false\nfor the model represented by our program.\nSMV programs consist of one or more modules. As in the programming\nlanguage C, or Java, one of the modules must be called main. Modules can\ndeclare variables and assign to them. Assignments usually give the initial\nvalue of a variable and its next value as an expression in terms of the current\nvalues of variables. This expression can be non-deterministic (denoted by\nseveral expressions in braces, or no assignment at all). Non-determinism is\nused to model the environment and for abstraction.\n192\n3 Verification by model checking\nThe following input to SMV:\nMODULE main\nVAR\nrequest : boolean;\nstatus : {ready,busy};\nASSIGN\ninit(status) := ready;\nnext(status) := case\nrequest : busy;\n1 : {ready,busy};\nesac;\nLTLSPEC\nG(request -> F status=busy)\nconsists of a program and a speciﬁcation. The program has two variables,\nrequest of type boolean and status of enumeration type {ready, busy}:\n0 denotes ‘false’ and 1 represents ‘true.’ The initial and subsequent values\nof variable request are not determined within this program; this conserva-\ntively models that these values are determined by an external environment.\nThis under-speciﬁcation of request implies that the value of variable status\nis partially determined: initially, it is ready; and it becomes busy whenever\nresolve important issues. The logical structure of the formal speciﬁcation, written\nas a formula in a suitable logic, typically serves as a guiding principle in trying\nto write an implementation in which it holds.\nr Time-to-market: Debugging big systems during the testing phase is costly and\ntime-consuming and local ‘ﬁxes’ often introduce new bugs at other places. Ex-\nperience has shown that verifying programs with respect to formal speciﬁcations\ncan signiﬁcantly cut down the duration of software development and maintenance\nby eliminating most errors in the planning phase and helping in the clariﬁcation\nof the roles and structural aspects of system components.\nr Refactoring: Properly speciﬁed and veriﬁed software is easier to reuse, since\nwe have a clear speciﬁcation of what it is meant to do.\nr Certiﬁcation audits: Safety-critical computer systems – such as the control\nof cooling systems in nuclear power stations, or cockpits of modern aircrafts –\ndemand that their software be speciﬁed and veriﬁed with as much rigour and\nformality as possible. Other programs may be commercially critical, such as ac-\ncountancy software used by banks, and they should be delivered with a warranty:\na guarantee for correct performance within proper use. The proof that a program\nmeets its speciﬁcations is indeed such a warranty.\n258\n4 Program verification\nThe degree to which the software industry accepts the beneﬁts of proper\nveriﬁcation of code depends on the perceived extra cost of producing it and\nthe perceived beneﬁts of having it. As veriﬁcation technology improves, the\ncosts are declining; and as the complexity of software and the extent to which\nsociety depends on it increase, the beneﬁts are becoming more important.\nThus, we can expect that the importance of veriﬁcation to industry will\ncontinue to increase over the next decades. Microsoft’s emergent technology\nA# combines program veriﬁcation, testing, and model-checking techniques",
                            "children": []
                        }
                    ]
                }
            ]
        },
        {
            "id": "chapter-1",
            "title": "Verification by Model Checking",
            "content": null,
            "children": [
                {
                    "id": "chapter-1-section-1",
                    "title": "Motivation for Verification",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-2",
                    "title": "Linear-Time Temporal Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-2-subsection-1",
                            "title": "Syntax of LTL",
                            "content": "all paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nR and W are called ‘Until,’ ‘Release’ and ‘Weak-until’ respectively. We will\nlook at the precise meaning of all these connectives in the next section; for\nnow, we concentrate on their syntax.\nHere are some examples of LTL formulas:\nr (((F p) ∧(G q)) →(p W r))\nr (F (p →(G r)) ∨((¬q) U p)), the parse tree of this formula is illustrated in\nFigure 3.1.\nr (p W (q W r))\nr ((G (F p)) →(F (q ∨s))).\nIt’s boring to write all those brackets, and makes the formulas hard to read.\nMany of them can be omitted without introducing ambiguities; for example,\n(p →(F q)) could be written p →F q without ambiguity. Others, however,\nare required to resolve ambiguities. In order to omit some of those, we assume\nsimilar binding priorities for the LTL connectives to those we assumed for\npropositional and predicate logic.\n3.2 Linear-time temporal logic\n177\nq\np\nG\nr\nF\n→\n∨\np\nU\n¬\nFigure 3.2. The parse tree of F p →G r ∨¬q U p, assuming binding pri-\norities of Convention 3.2.\nConvention 3.2 The unary connectives (consisting of ¬ and the temporal\nconnectives X, F and G) bind most tightly. Next in the order come U, R\nand W; then come ∧and ∨; and after that comes →.\nThese binding priorities allow us to drop some brackets without introduc-\ning ambiguity. The examples above can be written:\nr F p ∧G q →p W r\nr F (p →G r) ∨¬q U p\nr p W (q W r)\nr G F p →F (q ∨s).\nThe brackets we retained were in order to override the priorities of Conven-\ntion 3.2, or to disambiguate cases which the convention does not resolve.\nFor example, with no brackets at all, the second formula would become\nF p →G r ∨¬q U p, corresponding to the parse tree of Figure 3.2, which is\nquite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nLTL we also have quantiﬁers A and E which express ‘all paths’ and ‘exists\na path’, respectively. For example, we can write:\nr There is a reachable state satisfying q: this is written EF q.\nr From all reachable states satisfying p, it is possible to maintain p continuously\nuntil reaching a state satisfying q: this is written AG (p →E[p U q]).\nr Whenever a state satisfying p is reached, the system can exhibit q continuously\nforevermore: AG (p →EG q).\nr There is a reachable state from which all reachable states satisfy p: EF AG p.\n3.4.1 Syntax of CTL\nComputation Tree Logic, or CTL for short, is a branching-time logic, mean-\ning that its model of time is a tree-like structure in which the future is not\ndetermined; there are diﬀerent paths in the future, any one of which might\nbe the ‘actual’ path that is realised.\nAs before, we work with a ﬁxed set of atomic formulas/descriptions (such\nas p, q, r, . . . , or p1, p2, . . . ).\nDeﬁnition 3.12 We deﬁne CTL formulas inductively via a Backus Naur\nform as done for LTL:\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | AX φ | EX φ |\nAF φ | EF φ | AG φ | EG φ | A[φ U φ] | E[φ U φ]\nwhere p ranges over a set of atomic formulas.\nNotice that each of the CTL temporal connectives is a pair of symbols.\nThe ﬁrst of the pair is one of A and E. A means ‘along All paths’ (inevitably)\nand E means ‘along at least (there Exists) one path’ (possibly). The second\none of the pair is X, F, G, or U, meaning ‘neXt state,’ ‘some Future state,’\n‘all future states (Globally)’ and Until, respectively. The pair of symbols\nin E[φ1 U φ2], for example, is EU. In CTL, pairs of symbols like EU are\n3.4 Branching-time logic\n209\nindivisible. Notice that AU and EU are binary. The symbols X, F, G and\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\nthat φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-2",
                            "title": "Semantics of LTL",
                            "content": "all paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nLTL we also have quantiﬁers A and E which express ‘all paths’ and ‘exists\na path’, respectively. For example, we can write:\nr There is a reachable state satisfying q: this is written EF q.\nr From all reachable states satisfying p, it is possible to maintain p continuously\nuntil reaching a state satisfying q: this is written AG (p →E[p U q]).\nr Whenever a state satisfying p is reached, the system can exhibit q continuously\nforevermore: AG (p →EG q).\nr There is a reachable state from which all reachable states satisfy p: EF AG p.\n3.4.1 Syntax of CTL\nComputation Tree Logic, or CTL for short, is a branching-time logic, mean-\ning that its model of time is a tree-like structure in which the future is not\ndetermined; there are diﬀerent paths in the future, any one of which might\nbe the ‘actual’ path that is realised.\nAs before, we work with a ﬁxed set of atomic formulas/descriptions (such\nas p, q, r, . . . , or p1, p2, . . . ).\nDeﬁnition 3.12 We deﬁne CTL formulas inductively via a Backus Naur\nform as done for LTL:\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | AX φ | EX φ |\nAF φ | EF φ | AG φ | EG φ | A[φ U φ] | E[φ U φ]\nwhere p ranges over a set of atomic formulas.\nNotice that each of the CTL temporal connectives is a pair of symbols.\nThe ﬁrst of the pair is one of A and E. A means ‘along All paths’ (inevitably)\nand E means ‘along at least (there Exists) one path’ (possibly). The second\none of the pair is X, F, G, or U, meaning ‘neXt state,’ ‘some Future state,’\n‘all future states (Globally)’ and Until, respectively. The pair of symbols\nin E[φ1 U φ2], for example, is EU. In CTL, pairs of symbols like EU are\n3.4 Branching-time logic\n209\nindivisible. Notice that AU and EU are binary. The symbols X, F, G and\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\nLiveness: Messages get through eventually. Thus, for any state there is\ninevitably a future state in which the current message has got through. In\nthe module sender, we speciﬁed G F st=sent. (This speciﬁcation could\nequivalently have been written in the main module, as G F S.st=sent.)\nSimilarly, acknowledgements get through eventually. In the module\nreceiver, we write G F st=received.\n3.4 Branching-time logic\nIn our analysis of LTL (linear-time temporal logic) in the preceding sections,\nwe noted that LTL formulas are evaluated on paths. We deﬁned that a state\nof a system satisﬁes an LTL formula if all paths from the given state satisfy\nit. Thus, LTL implicitly quantiﬁes universally over paths. Therefore, prop-\nerties which assert the existence of a path cannot be expressed in LTL. This\nproblem can partly be alleviated by considering the negation of the property\nin question, and interpreting the result accordingly. To check whether there\n208\n3 Verification by model checking\nexists a path from s satisfying the LTL formula φ, we check whether all paths\nsatisfy ¬φ; a positive answer to this is a negative answer to our original ques-\ntion, and vice versa. We used this approach when analysing the ferryman\npuzzle in the previous section. However, as already noted, properties which\nmix universal and existential path quantiﬁers cannot in general be model\nchecked using this approach, because the complement formula still has a mix.\nBranching-time logics solve this problem by allowing us to quantify ex-\nplicitly over paths. We will examine a logic known as Computation Tree\nLogic, or CTL. In CTL, as well as the temporal operators U, F, G and X of\nLTL we also have quantiﬁers A and E which express ‘all paths’ and ‘exists\na path’, respectively. For example, we can write:\nr There is a reachable state satisfying q: this is written EF q.\nr From all reachable states satisfying p, it is possible to maintain p continuously\nquite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nThe subformulas of p W (q U r), e.g., are p, q, r, q U r and p W (q U r).\n3.2.2 Semantics of LTL\nThe kinds of systems we are interested in verifying using LTL may be\nmodelled as transition systems. A transition system models a system by\nmeans of states (static structure) and transitions (dynamic structure). More\nformally:\nDeﬁnition 3.4 A transition system M = (S, →, L) is a set of states S\nendowed with a transition relation\n→(a binary relation on S), such\nthat every s ∈S has some s′ ∈S with s →s′, and a labelling function\nL: S →P(Atoms).\nTransition systems are also simply called models in this chapter. So a model\nhas a collection of states S, a relation →, saying how the system can move\nfrom state to state, and, associated with each state s, one has the set of\natomic propositions L(s) which are true at that particular state. We write\nP(Atoms) for the power set of Atoms, a collection of atomic descriptions.\nFor example, the power set of {p, q} is {∅, {p}, {q}, {p, q}}. A good way of\nthinking about L is that it is just an assignment of truth values to all the\npropositional atoms, as it was the case for propositional logic (we called\nthat a valuation). The diﬀerence now is that we have more than one state,\nso this assignment depends on which state s the system is in: L(s) contains\nall atoms which are true in state s.\nWe may conveniently express all the information about a (ﬁnite) tran-\nsition system M using directed graphs whose nodes (which we call states)\ncontain all propositional atoms that are true in that state. For example, if\nour system has only three states s0, s1 and s2; if the only possible transi-\ntions between states are s0 →s1, s0 →s2, s1 →s0, s1 →s2 and s2 →s2;",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-3",
                            "title": "Practical Patterns of Specifications",
                            "content": "speciﬁcations are usually symbolic encodings of real-world constraints into\nsome sort of logic. Thus, a framework for producing the software could be:\nr Convert the informal description R of requirements for an application domain\ninto an ‘equivalent’ formula φR of some symbolic logic;\nr Write a program P which is meant to realise φR in the programming environment\nsupplied by your company, or wanted by the particular customer;\nr Prove that the program P satisﬁes the formula φR.\nThis scheme is quite crude – for example, constraints may be actual design\ndecisions for interfaces and data types, or the speciﬁcation may ‘evolve’\n4.2 A framework for software verification\n259\nand may partly be ‘unknown’ in big projects – but it serves well as a ﬁrst\napproximation to trying to deﬁne good programming methodology. Several\nvariations of such a sequence of activities are conceivable. For example,\nyou, as a programmer, might have been given only the formula φR, so you\nmight have little if any insight into the real-world problem which you are\nsupposed to solve. Technically, this poses no problem, but often it is handy\nto have both informal and formal descriptions available. Moreover, crafting\nthe informal requirements R is often a mutual process between the client\nand the programmer, whereby the attempt at formalising R can uncover\nambiguities or undesired consequences and hence lead to revisions of R.\nThis ‘going back and forth’ between the realms of informal and formal\nspeciﬁcations is necessary since it is impossible to ‘verify’ whether an infor-\nmal requirement R is equivalent to a formal description φR. The meaning\nof R as a piece of natural language is grounded in common sense and gen-\neral knowledge about the real-world domain and often based on heuristics\nor quantitative reasoning. The meaning of a logic formula φR, on the other\nhand, is deﬁned in a precise mathematical, qualitative and compositional\nresolve important issues. The logical structure of the formal speciﬁcation, written\nas a formula in a suitable logic, typically serves as a guiding principle in trying\nto write an implementation in which it holds.\nr Time-to-market: Debugging big systems during the testing phase is costly and\ntime-consuming and local ‘ﬁxes’ often introduce new bugs at other places. Ex-\nperience has shown that verifying programs with respect to formal speciﬁcations\ncan signiﬁcantly cut down the duration of software development and maintenance\nby eliminating most errors in the planning phase and helping in the clariﬁcation\nof the roles and structural aspects of system components.\nr Refactoring: Properly speciﬁed and veriﬁed software is easier to reuse, since\nwe have a clear speciﬁcation of what it is meant to do.\nr Certiﬁcation audits: Safety-critical computer systems – such as the control\nof cooling systems in nuclear power stations, or cockpits of modern aircrafts –\ndemand that their software be speciﬁed and veriﬁed with as much rigour and\nformality as possible. Other programs may be commercially critical, such as ac-\ncountancy software used by banks, and they should be delivered with a warranty:\na guarantee for correct performance within proper use. The proof that a program\nmeets its speciﬁcations is indeed such a warranty.\n258\n4 Program verification\nThe degree to which the software industry accepts the beneﬁts of proper\nveriﬁcation of code depends on the perceived extra cost of producing it and\nthe perceived beneﬁts of having it. As veriﬁcation technology improves, the\ncosts are declining; and as the complexity of software and the extent to which\nsociety depends on it increase, the beneﬁts are becoming more important.\nThus, we can expect that the importance of veriﬁcation to industry will\ncontinue to increase over the next decades. Microsoft’s emergent technology\nA# combines program veriﬁcation, testing, and model-checking techniques\n1.\nit captures formally static and dynamic system structure and behaviour;\n2.\nit can verify consistency of the constrained design space;\n2.7 Micromodels of software\n149\n3.\nit is executable, so it allows guided simulations through a potentially very com-\nplex design space; and\n4.\nit can boost our conﬁdence into the correctness of claims about static and\ndynamic aspects of all its compliant implementations.\nMoreover, formal models attached to software products can be seen as a\nreliability contract; a promise that the software implements the structure and\nbehaviour of the model and is expected to meet all of the assertions certiﬁed\ntherein. (However, this may not be very useful for extremely under-speciﬁed\nmodels.)\nWe will model a software package dependency system. This system is used\nwhen software packages are installed or upgraded. The system checks to see\nif prerequisites in the form of libraries or other packages are present. The\nrequirements on a software package dependency system are not straightfor-\nward. As most computer users know, the upgrading process can go wrong\nin various ways. For example, upgrading a package can involve replacing\nshared libraries with newer versions. But other packages which rely on the\nolder versions of the shared libraries may then cease to work.\nSoftware package dependency systems are used in several computer sys-\ntems, such as Red Hat Linux, .NET’s Global Assembly Cache and others.\nUsers often have to guess how technical questions get resolved within the de-\npendency system. To the best of our knowledge, there is no publicly available\nformal and executable model of any particular dependency system to which\napplication programmers could turn if they had such non-trivial technical\nquestions about its inner workings.\nIn our model, applications are built out of components. Components oﬀer\nservices to other components. A service can be a number of things. Typically,\nanalyzer [JSS01] have been developed by D. Jackson and his Software\nDesign Group at the Laboratory for Computer Science at the Massachusetts\nInstitute of Technology. The tool has a dedicated repository website at\nalloy.mit.edu.\nMore information on typed higher-order logics and their use in the\nmodelling and verifying of programming frameworks can be found on F.\nPfenning’s course homepage7 on Computation and Deduction.\n7 www-2.cs.cmu.edu/~fp/courses/comp-ded/\n3\nVerification by model checking\n3.1 Motivation for verification\nThere is a great advantage in being able to verify the correctness of computer\nsystems, whether they are hardware, software, or a combination. This is most\nobvious in the case of safety-critical systems, but also applies to those that\nare commercially critical, such as mass-produced chips, mission critical, etc.\nFormal veriﬁcation methods have quite recently become usable by industry\nand there is a growing demand for professionals able to apply them. In this\nchapter, and the next one, we examine two applications of logics to the\nquestion of verifying the correctness of computer systems, or programs.\nFormal veriﬁcation techniques can be thought of as comprising three\nparts:\nr a framework for modelling systems, typically a description language of some sort;\nr a speciﬁcation language for describing the properties to be veriﬁed;\nr a veriﬁcation method to establish whether the description of a system satisﬁes\nthe speciﬁcation.\nApproaches to veriﬁcation can be classiﬁed according to the following\ncriteria:\nProof-based vs. model-based. In a proof-based approach, the system\ndescription is a set of formulas Γ (in a suitable logic) and the speciﬁcation\nis another formula φ. The veriﬁcation method consists of trying to ﬁnd\na proof that Γ |−φ. This typically requires guidance and expertise from\nthe user.\nIn a model-based approach, the system is represented by a model M for\nan appropriate logic. The speciﬁcation is again represented by a formula\nsmall scope hypothesis, 143\nSMV, 254\nmain program for ABP, 207\nmodule, 193\nreceiver, 205\nsender, 204\nfor channel, 206\ninstantiation, 193\nprocess, 389\nprogram\nexample, 192\nfor Mutex, 195\nspeciﬁcation, 192\nsoftware\nlife-cycle, 142\nmicromodel, 142\nreliability, 149\nrequirements, 142\nspeciﬁcation, 142\nvalidation, 142\nsoundness\nof forall-elimination, 109\nof natural deduction\nbasic modal logic, 354\npredicate logic, 96, 122\npropositional logic, 45\nof program logics, 267\nof proof rule for while-statements,\n282\nof the substitution principle, 108\n426\nIndex\nspeciﬁcation\nfor ABP, 207\nformal, 259\ninformal, 259\nlanguage, 172\nof a predicate, 157\npatterns, 254\npractical pattern, 183, 215\ntruth table, 58\nspeciﬁcations, 191\nSpin, 254\nstate\ncritical, 188\nexplosion, 229\nexplosion problem, 254\nfair, 397\nﬁnal, 142\nformula, 218\nglobal, 188\ngraph, 180\ninitial, 142, 189, 222, 247, 252, 264\nnon-critical, 188\nof a system, 269\nof core program, 264\nreachable, 247\nresulting, 263, 299\nspace, 229\nsplitting states, 190\ntransition, 142\ntrying, 188\nstate machine, 142\nstorage\nlocation, 288\nstate, 261\nstore\nof core program, 264\nstring, 247, 307\nbinary, 126, 132\nempty, 126\nstrongly connected component, 225\nstructural equality, 153\nstructural induction, 44, 51\nsubformula, 178\nsubstitution\nin predicate logic, 105\ninstance, 323\ninstance of tautology, 314\nprinciple, 108\nsymbolic model checking, 383\nsyntactic\ndomain, 260, 261\nsyntax\nof basic modal logic, 307\nof boolean expressions, 261\nof boolean formulas, 398\nof CTL, 208\nof CTL*, 218\nof KT45n, 335\nof LTL, 175\nof predicate logic, 100\nof propositional logic, 33\nof relational mu-calculus, 390\nof terms, 99\nsystem\nasynchronous, 254\ninterleaving model, 389\nsimultaneous model, 389\naxiomatic, 91\ncommercially critical, 172, 257\ncomponent, 206\nconcurrent, 173\ndebugging, 174\ndescription, 193\ndesign, 174\ndevelopment, 173\nelevator, 184, 215\nﬁnite-state, 256\nhybrid, 277\ninﬁnite-state, 256\nmission-critical, 172\nmulti-agent, 331\nphysical, 175\nreactive, 173, 257, 358",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-4",
                            "title": "Important Equivalences Between LTL Formulas",
                            "content": "all paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\nR and W are called ‘Until,’ ‘Release’ and ‘Weak-until’ respectively. We will\nlook at the precise meaning of all these connectives in the next section; for\nnow, we concentrate on their syntax.\nHere are some examples of LTL formulas:\nr (((F p) ∧(G q)) →(p W r))\nr (F (p →(G r)) ∨((¬q) U p)), the parse tree of this formula is illustrated in\nFigure 3.1.\nr (p W (q W r))\nr ((G (F p)) →(F (q ∨s))).\nIt’s boring to write all those brackets, and makes the formulas hard to read.\nMany of them can be omitted without introducing ambiguities; for example,\n(p →(F q)) could be written p →F q without ambiguity. Others, however,\nare required to resolve ambiguities. In order to omit some of those, we assume\nsimilar binding priorities for the LTL connectives to those we assumed for\npropositional and predicate logic.\n3.2 Linear-time temporal logic\n177\nq\np\nG\nr\nF\n→\n∨\np\nU\n¬\nFigure 3.2. The parse tree of F p →G r ∨¬q U p, assuming binding pri-\norities of Convention 3.2.\nConvention 3.2 The unary connectives (consisting of ¬ and the temporal\nconnectives X, F and G) bind most tightly. Next in the order come U, R\nand W; then come ∧and ∨; and after that comes →.\nThese binding priorities allow us to drop some brackets without introduc-\ning ambiguity. The examples above can be written:\nr F p ∧G q →p W r\nr F (p →G r) ∨¬q U p\nr p W (q W r)\nr G F p →F (q ∨s).\nThe brackets we retained were in order to override the priorities of Conven-\ntion 3.2, or to disambiguate cases which the convention does not resolve.\nFor example, with no brackets at all, the second formula would become\nF p →G r ∨¬q U p, corresponding to the parse tree of Figure 3.2, which is\nquite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nthat φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.\nLTL in which the future excludes the present. A consequence of adopting\nthe convention that the future shall include the present is that the formulas\nG p →p, p →q U p and p →F p are true in every state of every model.\nSo far we have deﬁned a satisfaction relation between paths and LTL for-\nmulas. However, to verify systems, we would like to say that a model as\na whole satisﬁes an LTL formula. This is deﬁned to hold whenever every\npossible execution path of the model satisﬁes the formula.\nDeﬁnition 3.8 Suppose M = (S, →, L) is a model, s ∈S, and φ an LTL\nformula. We write M, s ⊨φ if, for every execution path π of M starting at\ns, we have π ⊨φ.\nIf M is clear from the context, we may abbreviate M, s ⊨φ by s ⊨φ.\nIt should be clear that we have outlined the formal foundations of a pro-\ncedure that, given φ, M and s, can check whether M, s ⊨φ holds. Later\nin this chapter, we will examine algorithms which implement this calcula-\ntion. Let us now look at some example checks for the system in Figures 3.3\nand 3.5.\n1.\nM, s0 ⊨p ∧q holds since the atomic symbols p and q are contained in the node\nof s0: π ⊨p ∧q for every path π beginning in s0.\n3.2 Linear-time temporal logic\n183\n2.\nM, s0 ⊨¬r holds since the atomic symbol r is not contained in node s0.\n3.\nM, s0 ⊨⊤holds by deﬁnition.\n4.\nM, s0 ⊨X r holds since all paths from s0 have either s1 or s2 as their next\nstate, and each of those states satisﬁes r.\n5.\nM, s0 ⊨X (q ∧r) does not hold since we have the rightmost computation path\ns0 →s2 →s2 →s2 →. . . in Figure 3.5, whose second node s2 contains r, but\nnot q.\n6.\nM, s0 ⊨G ¬(p ∧r) holds since all computation paths beginning in s0 satisfy\nG ¬(p ∧r), i.e. they satisfy ¬(p ∧r) in each state along the path. Notice that\nG φ holds in a state if, and only if, φ holds in all states reachable from the\ngiven state.\n7.\nFor similar reasons, M, s2 ⊨G r holds (note the s2 instead of s0).\n8.\nFor any state s of M, we have M, s ⊨F (¬q ∧r) →F G r. This says that if",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-5",
                            "title": "Adequate Sets of Connectives for LTL",
                            "content": "R and W are called ‘Until,’ ‘Release’ and ‘Weak-until’ respectively. We will\nlook at the precise meaning of all these connectives in the next section; for\nnow, we concentrate on their syntax.\nHere are some examples of LTL formulas:\nr (((F p) ∧(G q)) →(p W r))\nr (F (p →(G r)) ∨((¬q) U p)), the parse tree of this formula is illustrated in\nFigure 3.1.\nr (p W (q W r))\nr ((G (F p)) →(F (q ∨s))).\nIt’s boring to write all those brackets, and makes the formulas hard to read.\nMany of them can be omitted without introducing ambiguities; for example,\n(p →(F q)) could be written p →F q without ambiguity. Others, however,\nare required to resolve ambiguities. In order to omit some of those, we assume\nsimilar binding priorities for the LTL connectives to those we assumed for\npropositional and predicate logic.\n3.2 Linear-time temporal logic\n177\nq\np\nG\nr\nF\n→\n∨\np\nU\n¬\nFigure 3.2. The parse tree of F p →G r ∨¬q U p, assuming binding pri-\norities of Convention 3.2.\nConvention 3.2 The unary connectives (consisting of ¬ and the temporal\nconnectives X, F and G) bind most tightly. Next in the order come U, R\nand W; then come ∧and ∨; and after that comes →.\nThese binding priorities allow us to drop some brackets without introduc-\ning ambiguity. The examples above can be written:\nr F p ∧G q →p W r\nr F (p →G r) ∨¬q U p\nr p W (q W r)\nr G F p →F (q ∨s).\nThe brackets we retained were in order to override the priorities of Conven-\ntion 3.2, or to disambiguate cases which the convention does not resolve.\nFor example, with no brackets at all, the second formula would become\nF p →G r ∨¬q U p, corresponding to the parse tree of Figure 3.2, which is\nquite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nWriting W in terms of U is also possible: W is like U but also allows the\npossibility of the eventuality never occurring:\nφ W ψ ≡φ U ψ ∨G φ.\n(3.3)\nInspection of clauses 12 and 13 reveals that R and W are rather similar. The\ndiﬀerences are that they swap the roles of their arguments φ and ψ; and the\nclause for W has an i −1 where R has i. Therefore, it is not surprising that\nthey are expressible in terms of each other, as follows:\nφ W ψ ≡ψ R (φ ∨ψ)\n(3.4)\nφ R ψ ≡ψ W (φ ∧ψ).\n(3.5)\n3.2.5 Adequate sets of connectives for LTL\nRecall that φ ≡ψ holds iﬀany path in any transition system which sat-\nisﬁes φ also satisﬁes ψ, and vice versa. As in propositional logic, there is\nsome redundancy among the connectives. For example, in Chapter 1 we saw\nthat the set {⊥, ∧, ¬} forms an adequate set of connectives, since the other\nconnectives ∨, →, ⊤, etc., can be written in terms of those three.\nSmall adequate sets of connectives also exist in LTL. Here is a summary\nof the situation.\nr X is completely orthogonal to the other connectives. That is to say, its presence\ndoesn’t help in deﬁning any of the other ones in terms of each other. Moreover,\nX cannot be derived from any combination of the others.\nr Each of the sets {U, X}, {R, X}, {W, X} is adequate. To see this, we note that\n– R and W may be deﬁned from U, by the duality φ R ψ ≡¬(¬φ U ¬ψ) and\nequivalence (3.4) followed by the duality, respectively.\n– U and W may be deﬁned from R, by the duality φ U ψ ≡¬(¬φ R ¬ψ) and\nequivalence (3.4), respectively.\n– R and U may be deﬁned from W, by equivalence (3.5) and the duality φ U\nψ ≡¬(¬φ R ¬ψ) followed by equivalence (3.5).\nSometimes it is useful to look at adequate sets of connectives which do not\nrely on the availability of negation. That’s because it is often convenient to\nassume formulas are written in negation-normal form, where all the negation\nsymbols are applied to propositional atoms (i.e., they are near the leaves\n3.3 Model checking: systems, tools, properties\n187\nexist:\n¬AF φ ≡EG ¬φ\n¬EF φ ≡AG ¬φ\n(3.6)\n¬AX φ ≡EX ¬φ.\nWe also have the equivalences\nAF φ ≡A[⊤U φ]\nEF φ ≡E[⊤U φ]\nwhich are similar to the corresponding equivalences in LTL.\n3.4.5 Adequate sets of CTL connectives\nAs in propositional logic and in LTL, there is some redundancy among the\nCTL connectives. For example, the connective AX can be written ¬EX ¬;\nand AG, AF, EG and EF can be written in terms of AU and EU as follows:\nﬁrst, write AG φ as ¬EF ¬φ and EG φ as ¬AF ¬φ, using (3.6), and then use\nAF φ ≡A[⊤U φ] and EF φ ≡E[⊤U φ]. Therefore AU, EU and EX form\nan adequate set of temporal connectives.\nAlso EG, EU, and EX form an adequate set, for we have the equivalence\nA[φ U ψ] ≡¬(E[¬ψ U (¬φ ∧¬ψ)] ∨EG ¬ψ)\n(3.7)\nwhich can be proved as follows:\nA[φ U ψ] ≡A[¬(¬ψ U (¬φ ∧¬ψ)) ∧F ψ]\n≡¬E¬[¬(¬ψ U (¬φ ∧¬ψ)) ∧F ψ]\n≡¬E[(¬ψ U (¬φ ∧¬ψ)) ∨G ¬ψ]\n≡¬(E[¬ψ U (¬φ ∧¬ψ)] ∨EG ¬ψ).\nThe ﬁrst line is by Theorem 3.10, and the remainder by elementary manipu-\nlation. (This proof involves intermediate formulas which violate the syntactic\nformation rules of CTL; however, it is valid in the logic CTL* introduced in\nthe next section.) More generally, we have:\nTheorem 3.17 A set of temporal connectives in CTL is adequate if, and\nonly if, it contains at least one of {AX , EX }, at least one of {EG , AF , AU }\nand EU .\n3.5 CTL* and the expressive powers of LTL and CTL\n217\nThis theorem is proved in a paper referenced in the bibliographic notes\nat the end of the chapter. The connective EU plays a special role in that\ntheorem because neither weak-until W nor release R are primitive in CTL\n(Deﬁnition 3.12). The temporal connectives AR, ER, AW and EW are all\ndeﬁnable in CTL:\nr A[φ R ψ] = ¬E[¬φ U ¬ψ]\nr E[φ R ψ] = ¬A[¬φ U ¬ψ]\nr A[φ W ψ] = A[ψ R (φ ∨ψ)], and then use the ﬁrst equation above\nr E[φ W ψ] = E[ψ R (φ ∨ψ)], and then use the second one.\nThese deﬁnitions are justiﬁed by LTL equivalences in Sections 3.2.4\nand 3.2.5. Some other noteworthy equivalences in CTL are the following:\nAG φ ≡φ ∧AX AG φ\nall paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nroughly understood as follows:\nr If φ is atomic, satisfaction is determined by L.\nr If the top-level connective of φ (i.e., the connective occurring top-most in the\nparse tree of φ) is a boolean connective (∧, ∨, ¬, ⊤etc.) then the satisfaction\nquestion is answered by the usual truth-table deﬁnition and further recursion\ndown φ.\nr If the top level connective is an operator beginning A, then satisfaction holds if\nall paths from s satisfy the ‘LTL formula’ resulting from removing the A symbol.\nr Similarly, if the top level connective begins with E, then satisfaction holds if\nsome path from s satisfy the ‘LTL formula’ resulting from removing the E.\nIn the last two cases, the result of removing A or E is not strictly an LTL\nformula, for it may contain further As or Es below. However, these will be\ndealt with by the recursion.\nThe formal deﬁnition of M, s ⊨φ is a bit more verbose:\nDeﬁnition 3.15 Let M = (S, →, L) be a model for CTL, s in S, φ a CTL\nformula. The relation M, s ⊨φ is deﬁned by structural induction on φ:\n1.\nM, s ⊨⊤and M, s ̸⊨⊥\n2.\nM, s ⊨p iﬀp ∈L(s)\n3.\nM, s ⊨¬φ iﬀM, s ̸⊨φ\n4.\nM, s ⊨φ1 ∧φ2 iﬀM, s ⊨φ1 and M, s ⊨φ2\n5.\nM, s ⊨φ1 ∨φ2 iﬀM, s ⊨φ1 or M, s ⊨φ2\n6.\nM, s ⊨φ1 →φ2 iﬀM, s ̸⊨φ1 or M, s ⊨φ2.\n7.\nM, s ⊨AX φ iﬀfor all s1 such that s →s1 we have M, s1 ⊨φ. Thus, AX says:\n‘in every next state.’\n8.\nM, s ⊨EX φ iﬀfor some s1 such that s →s1 we have M, s1 ⊨φ. Thus, EX\nsays: ‘in some next state.’ E is dual to A – in exactly the same way that ∃is\ndual to ∀in predicate logic.\n9.\nM, s ⊨AG φ holds iﬀfor all paths s1 →s2 →s3 →. . ., where s1 equals s, and\nall si along the path, we have M, si ⊨φ. Mnemonically: for All computation\npaths beginning in s the property φ holds Globally. Note that ‘along the path’\nincludes the path’s initial state s.\n10.\nM, s ⊨EG φ holds iﬀthere is a path s1 →s2 →s3 →. . ., where s1 equals s,\nand for all si along the path, we have M, si ⊨φ. Mnemonically: there Exists\na path beginning in s such that φ holds Globally along the path.\n212",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-3",
                    "title": "Model Checking: Systems, Tools, Properties",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-3-subsection-1",
                            "title": "Example: Mutual Exclusion",
                            "content": "it.\nThe transition system corresponding to this program is shown in\nFigure 3.11. Each state shows the values of the variables; for example, ct1\nis the state in which process 1 and 2 are critical and trying, respectively,\nand turn=1. The labels on the transitions show which process was selected\nfor execution. In general, each state has several transitions, some in which\nprocess 1 moves and others in which process 2 moves.\nThis model is a bit diﬀerent from the previous model given for mutual\nexclusion in Figure 3.8, for these two reasons:\nr Because the boolean variable turn has been explicitly introduced to distinguish\nbetween states s3 and s9 of Figure 3.8, we now distinguish between certain states\n198\n3 Verification by model checking\ncn0\ntn0\ntc0\ntt0\nnn0\nct0\n1,2\n2\n1\n1\n1\n2\n1,2\n1\n2\n2\n2\n2\n1\n1\n2\n1\n1,2\n1\n1,2\n1,2\n1\n2\n2\n2\n1\n2\n1\n1\n1\n2\n1\n2\n2\nnn1\ntn1\ncn1\nct1\nnt1\ntt1\nnc1\ntc1\n1,2\n2\nnc0\nnt0\n1,2\n2\n1\n1,2\n1,2\n1\n1,2\nFigure 3.11. The transition system corresponding to the SMV code\nin Figure 3.10. The labels on the transitions denote the process which\nmakes the move. The label 1, 2 means that either process could make\nthat move.\n3.3 Model checking: systems, tools, properties\n199\n(for example, ct0 and ct1) which were identical before. However, these states\nare not distinguished if you look just at the transitions from them. Therefore,\nthey satisfy the same LTL formulas which don’t mention turn. Those states are\ndistinguished only by the way they can arise.\nr We have eliminated an over-simpliﬁcation made in the model of Figure 3.8. Recall\nthat we assumed the system would move to a diﬀerent state on every tick of the\nclock (there were no transitions from a state to itself). In Figure 3.11, we allow\ntransitions from each state to itself, representing that a process was chosen for\nexecution and did some private computation, but did not move in or out of its\ncritical section. Of course, by doing this we have introduced paths in which one\nsimilarly for the variables goat, cabbage and wolf.\nThe variable carry takes a value indicating whether the goat, cabbage,\nwolf or nothing is carried by the ferryman. The deﬁnition of next(carry)\nworks as follows. It is non-deterministic, but the set from which a value is\nnon-deterministically chosen is determined by the values of ferryman, goat,\nMODULE main\nVAR\nferryman : boolean;\ngoat\n: boolean;\ncabbage\n: boolean;\nwolf\n: boolean;\ncarry\n: {g,c,w,0};\nASSIGN\ninit(ferryman) := 0; init(goat)\n:= 0;\ninit(cabbage)\n:= 0; init(wolf)\n:= 0;\ninit(carry)\n:= 0;\nnext(ferryman) := 0,1;\nnext(carry) := case\nferryman=goat : g;\n1\n: 0;\nesac union\ncase\nferryman=cabbage : c;\n1\n: 0;\nesac union\ncase\nferryman=wolf : w;\n1\n: 0;\nesac union 0;\nnext(goat) := case\nferryman=goat\n& next(carry)=g : next(ferryman);\n1\n: goat;\nesac;\nnext(cabbage) := case\nferryman=cabbage & next(carry)=c : next(ferryman);\n1\n: cabbage;\nesac;\nnext(wolf) := case\nferryman=wolf & next(carry)=w : next(ferryman);\n1\n: wolf;\nesac;\nLTLSPEC !((\n(goat=cabbage | goat=wolf) -> goat=ferryman)\nU (cabbage & goat & wolf & ferryman))\nFigure 3.12. NuSMV code for the ferryman planning problem.\n3.3 Model checking: systems, tools, properties\n201\netc., and always includes 0. If ferryman = goat (i.e., they are on the same\nside) then g is a member of the set from which next(carry) is chosen. The\nsituation for cabbage and wolf is similar. Thus, if ferryman = goat = wolf ̸=\ncabbage then that set is {g, w, 0}. The next value assigned to ferryman is\nnon-deterministic: he can choose to cross or not to cross the river. But the\nnext values of goat, cabbage and wolf are deterministic, since whether they\nare carried or not is determined by the ferryman’s choice, represented by the\nnon-deterministic assignment to carry; these values follow the same pattern.\nNote how the boolean guards refer to state bits at the next state. The\nSMV compiler does a dependency analysis and rejects circular dependencies\nlabels given in Section 3.6.1.\n9.\n*\nFor mutual exclusion, draw a transition system which forces the two processes\nto enter their critical section in strict sequence and show that φ4 is false of its\ninitial state.\n10. Use the deﬁnition of ⊨between states and CTL formulas to explain why s ⊨\nAG AF φ means that φ is true inﬁnitely often along every path starting at s.\n11.\n*\nShow that a CTL formula φ is true on inﬁnitely many states of a computa-\ntion path s0 →s1 →s2 →. . . iﬀfor all n ≥0 there is some m ≥n such that\nsm ⊨φ.\n12. Run the NuSMV system on some examples. Try commenting out, or deleting,\nsome of the fairness constraints, if applicable, and see the counter examples\nNuSMV generates. NuSMV is very easy to run.\n13. In the one-bit channel, there are two fairness constraints. We could have written\nthis as a single one, inserting ‘&’ between running and the long formula, or we\ncould have separated the long formula into two and made it into a total of three\nfairness constraints.\nIn general, what is the diﬀerence between the single fairness constraint φ1 ∧φ2 ∧\n· · · ∧φn and the n fairness constraints φ1, φ2, . . . , φn? Write an SMV program\nwith a fairness constraint a & b which is not equivalent to the two fairness\nconstraints a and b. (You can actually do it in four lines of SMV.)\n14. Explain the construction of formula φ4, used to express that the processes need\nnot enter their critical section in strict sequence. Does it rely on the fact that\nthe safety property φ1 holds?\n15.\n*\nCompute the ECG ⊤labels for Figure 3.11, given the fairness constraints of the\ncode in Figure 3.10 on page 196.\nExercises 3.7\n1. Consider the functions\nH1, H2, H3 : P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) →P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\ndeﬁned by\nH1(Y )\ndef\n= Y −{1, 4, 7}\nH2(Y )\ndef\n= {2, 5, 9} −Y\nH3(Y )\ndef\n= {1, 2, 3, 4, 5} ∩({2, 4, 8} ∪Y )\nfor all Y ⊆{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.\n(a)\n*\nWhich of these functions are monotone; which ones aren’t? Justify your an-\nswer in each case.\n(b)\n*\ncal; SQL queries over relational databases or XQueries over XML documents\nare examples of this in practice.\nSoftware models, design standards, and execution models of hardware or\nprograms often are described in terms of directed graphs. Such models M\nare interpretations of a two-argument predicate symbol R over a concrete\nset A of ‘states.’\nExample 2.23 Given a set of states A = {s0, s1, s2, s3}, let RM be the\nset {(s0, s1), (s1, s0), (s1, s1), (s1, s2), (s2, s0), (s3, s0), (s3, s2)}. We may de-\npict this model as a directed graph in Figure 2.5, where an edge (a transi-\ntion) leads from a node s to a node s′ iﬀ(s, s′) ∈RM. In that case, we often\ndenote this as s →s′.\nThe validation of many applications requires to show that a ‘bad’ state\ncannot be reached from a ‘good’ state. What ‘good’ and ‘bad’ mean will\ndepend on the context. For example, a good state may be one in which an\ninteger expression, say x ∗(y −1), evaluates to a value that serves as a safe\nindex into an array a of length 10. A bad state would then be one in which\nthis integer expression evaluates to an unsafe value, say 11, causing an ‘out-\nof-bounds exception.’ In its essence, deciding whether from a good state one\ncan reach a bad state is the reachability problem in directed graphs.\n2.6 Expressiveness of predicate logic\n137\ns1\ns0\ns3\ns2\nFigure 2.5. A directed graph, which is a model M for a predicate sym-\nbol R with two arguments. A pair of nodes (n, n′) is in the interpretation\nRM of R iff there is a transition (an edge) from node n to node n′ in\nthat graph.\nReachability: Given nodes n and n′ in a directed graph, is there a ﬁnite\npath of transitions from n to n′?\nIn Figure 2.5, state s2 is reachable from state s0, e.g. through the path\ns0 →s1 →s2. By convention, every state reaches itself by a path of length\n0. State s3, however, is not reachable from s0; only states s0, s1, and s2\nare reachable from s0. Given the evident importance of this concept, can\nabout expressing properties in LTL are appropriate. Notice that in the\n190\n3 Verification by model checking\nno-strict-sequencing property, we overcame the problem of not being able to\nexpress the existence of paths by instead expressing the complement prop-\nerty, which of course talks about all paths. Then we can perform our check,\nand simply reverse the answer; if the complement property is false, we de-\nclare our property to be true, and vice versa.\nWhy was that tactic not available to us to express the non-blocking prop-\nerty? The reason is that it says: every path to a n1 state may be continued\nby a one-step path to a t1 state. The presence of both universal and exis-\ntential quantiﬁers is the problem. In the no-strict-sequencing property, we\nhad only an existential quantiﬁer; thus, taking the complement property\nturned it into a universal path quantiﬁer, which can be expressed in LTL.\nBut where we have alternating quantiﬁers, taking the complement property\ndoesn’t help in general.\nLet’s go back to the mutual exclusion example. The reason liveness failed\nin our ﬁrst attempt at modelling mutual exclusion is that non-determinism\nmeans it might continually favour one process over another. The problem is\nthat the state s3 does not distinguish between which of the processes ﬁrst\nwent into its trying state. We can solve this by splitting s3 into two states.\nThe second modelling attempt\nThe two states s3 and s9 in Figure 3.8\nboth correspond to the state s3 in our ﬁrst modelling attempt. They both\nrecord that the two processes are in their trying states, but in s3 it is im-\nplicitly recorded that it is process 1’s turn, whereas in s9 it is process 2’s\nturn. Note that states s3 and s9 both have the labelling t1t2; the deﬁnition of\ntransition systems does not preclude this. We can think of there being some\nother, hidden, variables which are not part of the initial labelling, which\ndistinguish s3 and s9.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-2",
                            "title": "The NuSMV Model Checker",
                            "content": "system description language as CMU SMV, but it has an improved user in-\nterface and a greater variety of algorithms. For example, whereas CMU SMV\nchecks only CTL speciﬁcation, NuSMV supports LTL and CTL. NuSMV im-\nplements bounded model checking [BCCZ99]. Cadence SMV8 is an entirely\nnew model checker focused on compositional systems and abstraction as\nways of addressing the state explosion problem. It was also developed by\nK. McMillan and its description language resembles but much extends the\noriginal SMV.\nA website which gathers frequently used speciﬁcation patterns in various\nframeworks (such as CTL, LTL and regular expressions) is maintained by\nM. Dwyer, G. Avrunin, J. Corbett and L. Dillon9.\nCurrent research in model checking includes attempts to exploit abstrac-\ntions, symmetries and compositionality [CGL94, Lon83, Dam96] in order to\nreduce the impact of the state explosion problem.\nThe model checker Spin, which is geared towards asynchronous systems\nand is based on the temporal logic LTL, can be found at the Spin website10. A\nmodel checker called FDR2 based on the process algebra CSP is available11.\n6 www.cs.cmu.edu/~modelcheck/\n7 nusmv.irst.itc.it\n8 www-cad.eecs.berkeley.edu/~kenmcmil/\n9 patterns.projects.cis.ksu.edu/\n10 netlib.bell-labs.com/netlib/spin/whatispin.html\n11 www.fsel.com.fdr2 download.html\n3.9 Bibliographic notes\n255\nThe Edinburgh Concurrency Workbench12 and the Concurrency Workbench\nof North Carolina13 are similar software tools for the design and analysis of\nconcurrent systems. An example of a customisable and extensible modular\nmodel checking frameworks for the veriﬁcation of concurrent software is\nBogor14.\nThere are many textbooks about veriﬁcation of reactive systems; we men-\ntion [MP91, MP95, Ros97, Hol90]. The SMV code contained in this chapter\ncan be downloaded from www.cs.bham.ac.uk/research/lics/.\n12 www.dcs.ed.ac.uk/home/cwb\n13 www.cs.sunysb.edu/~cwb\n14 http://bogor.projects.cis.ksu.edu/\n4\nProgram verification\nrun the speciﬁcation checks, as well as inspect partial results and set various\nparameters. See the NuSMV user manual for more details.\nNuSMV also supports bounded model checking, invoked by the command-\nline option -bmc. Bounded model checking looks for counterexamples in\norder of size, starting with counterexamples of length 1, then 2, etc., up\nto a given threshold (10 by default). Note that bounded model checking\nis incomplete: failure to ﬁnd a counterexample does not mean that there\nis none, but only that there is none of length up to the threshold. For\nrelated reasons, this incompleteness features also in Alloy and its constraint\nanalyzer. Thus, while a negative answer can be relied on (if NuSMV ﬁnds a\ncounterexample, it is valid), a positive one cannot. References on bounded\nmodel checking can be found in the bibliographic notes on page 254. Later\non, we use bounded model checking to prove the optimality of a scheduler.\n3.3.4 Mutual exclusion revisited\nFigure 3.10 gives the SMV code for a mutual exclusion protocol. This code\nconsists of two modules, main and prc. The module main has the variable\nturn, which determines whose turn it is to enter the critical section if both\nare trying to enter (recall the discussion about the states s3 and s9 in Sec-\ntion 3.3.1).\nThe module main also has two instantiations of prc. In each of these\ninstantiations, st is the status of a process (saying whether it is in its critical\nsection, or not, or trying) and other-st is the status of the other process\n(notice how this is passed as a parameter in the third and fourth lines of\nmain).\nThe value of st evolves in the way described in a previous section: when\nit is n, it may stay as n or move to t. When it is t, if the other one is n, it will\ngo straight to c, but if the other one is t, it will check whose turn it is before\ngoing to c. Then, when it is c, it may move back to n. Each instantiation of\nprc gives the turn to the other one when it gets to its critical section.\n‘New Symbolic Model Veriﬁer.’ NuSMV is an Open Source product, is ac-\ntively supported and has a substantial user community. For details on how\nto obtain it, see the bibliographic notes at the end of the chapter.\nNuSMV (sometimes called simply SMV) provides a language for describ-\ning the models we have been drawing as diagrams and it directly checks the\nvalidity of LTL (and also CTL) formulas on those models. SMV takes as\ninput a text consisting of a program describing a model and some speciﬁca-\ntions (temporal logic formulas). It produces as output either the word ‘true’\nif the speciﬁcations hold, or a trace showing why the speciﬁcation is false\nfor the model represented by our program.\nSMV programs consist of one or more modules. As in the programming\nlanguage C, or Java, one of the modules must be called main. Modules can\ndeclare variables and assign to them. Assignments usually give the initial\nvalue of a variable and its next value as an expression in terms of the current\nvalues of variables. This expression can be non-deterministic (denoted by\nseveral expressions in braces, or no assignment at all). Non-determinism is\nused to model the environment and for abstraction.\n192\n3 Verification by model checking\nThe following input to SMV:\nMODULE main\nVAR\nrequest : boolean;\nstatus : {ready,busy};\nASSIGN\ninit(status) := ready;\nnext(status) := case\nrequest : busy;\n1 : {ready,busy};\nesac;\nLTLSPEC\nG(request -> F status=busy)\nconsists of a program and a speciﬁcation. The program has two variables,\nrequest of type boolean and status of enumeration type {ready, busy}:\n0 denotes ‘false’ and 1 represents ‘true.’ The initial and subsequent values\nof variable request are not determined within this program; this conserva-\ntively models that these values are determined by an external environment.\nThis under-speciﬁcation of request implies that the value of variable status\nis partially determined: initially, it is ready; and it becomes busy whenever\nIt is possible to implement the check for such a path in terms of CTL\nmodel checking, and this is in fact what NuSMV does. The combined system\nM × A¬φ is represented as the system to be model checked in NuSMV,\nand the formula to be checked is simply EG ⊤. Thus, we ask the question:\ndoes the combined system have a path. The acceptance conditions of A¬φ\nare represented as implicit fairness conditions for the CTL model-checking\nprocedure. Explicitly, this amounts to asserting ‘FAIRNESS ¬(χ U ψ) ∨ψ’\nfor each formula χ U ψ occurring in C(φ).\n3.7 The fixed-point characterisation of CTL\nOn page 227, we presented an algorithm which, given a CTL formula φ and\na model M = (S, →, L), computes the set of states s ∈S satisfying φ. We\nwrite this set as [[φ]]. The algorithm works recursively on the structure of\nφ. For formulas φ of height 1 (⊥, ⊤or p), [[φ]] is computed directly. Other\n3.7 The fixed-point characterisation of CTL\n239\nformulas are composed of smaller subformulas combined by a connective of\nCTL. For example, if φ is ψ1 ∨ψ2, then the algorithm computes the sets\n[[ψ1]] and [[ψ2]] and combines them in a certain way (in this case, by taking\nthe union) in order to obtain [[ψ1 ∨ψ2]].\nThe more interesting cases arise when we deal with a formula such as\nEX ψ, involving a temporal operator. The algorithm computes the set [[ψ]]\nand then computes the set of all states which have a transition to a state in\n[[ψ]]. This is in accord with the semantics of EX ψ: M, s ⊨EX ψ iﬀthere is\na state s′ with s →s′ and M, s′ ⊨ψ.\nFor most of these logical operators, we may easily continue this discussion\nto see that the algorithms work just as expected. However, the cases EU,\nAF and EG (where we needed to iterate a certain labelling policy until it\nstabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-3",
                            "title": "Running NuSMV",
                            "content": "are carried or not is determined by the ferryman’s choice, represented by the\nnon-deterministic assignment to carry; these values follow the same pattern.\nNote how the boolean guards refer to state bits at the next state. The\nSMV compiler does a dependency analysis and rejects circular dependencies\non next values. (The dependency analysis is rather pessimistic: sometimes\nNuSMV complains of circularity even in situations when it could be resolved.\nThe original CMU-SMV is more liberal in this respect.)\nRunning NuSMV\nWe seek a path satisfying φ U ψ, where ψ asserts the\nﬁnal goal state, and φ expresses the safety condition (if the goat is with\nthe cabbage or the wolf, then the ferryman is there, too, to prevent any\nuntoward behaviour). Thus, we assert that all paths satisfy ¬(φ U ψ), i.e.,\nno path satisﬁes φ U ψ. We hope this is not the case, and NuSMV will give\nus an example path which does satisfy φ U ψ. Indeed, running NuSMV gives\nus the path of Figure 3.13, which represents a solution to the puzzle.\nThe beginning of the generated path represents the usual solution to this\npuzzle: the ferryman takes the goat ﬁrst, then goes back for the cabbage. To\navoid leaving the goat and the cabbage together, he takes the goat back, and\npicks up the wolf. Now the wolf and the cabbage are on the destination side,\nand he goes back again to get the goat. This brings us to State 1.9, where\nthe ferryman appears to take a well-earned break. But the path continues.\nStates 1.10 to 1.15 show that he takes his charges back to the original side\nof the bank; ﬁrst the cabbage, then the wolf, then the goat. Unfortunately\nit appears that the ferryman’s clever plan up to state 1.9 is now spoiled,\nbecause the goat meets an unhappy end in state 1.11.\nWhat went wrong? Nothing, actually. NuSMV has given us an inﬁnite\npath, which loops around the 15 illustrated states. Along the inﬁnite path,\nthe ferryman repeatedly takes his goods across (safely), and then back again\nlabels given in Section 3.6.1.\n9.\n*\nFor mutual exclusion, draw a transition system which forces the two processes\nto enter their critical section in strict sequence and show that φ4 is false of its\ninitial state.\n10. Use the deﬁnition of ⊨between states and CTL formulas to explain why s ⊨\nAG AF φ means that φ is true inﬁnitely often along every path starting at s.\n11.\n*\nShow that a CTL formula φ is true on inﬁnitely many states of a computa-\ntion path s0 →s1 →s2 →. . . iﬀfor all n ≥0 there is some m ≥n such that\nsm ⊨φ.\n12. Run the NuSMV system on some examples. Try commenting out, or deleting,\nsome of the fairness constraints, if applicable, and see the counter examples\nNuSMV generates. NuSMV is very easy to run.\n13. In the one-bit channel, there are two fairness constraints. We could have written\nthis as a single one, inserting ‘&’ between running and the long formula, or we\ncould have separated the long formula into two and made it into a total of three\nfairness constraints.\nIn general, what is the diﬀerence between the single fairness constraint φ1 ∧φ2 ∧\n· · · ∧φn and the n fairness constraints φ1, φ2, . . . , φn? Write an SMV program\nwith a fairness constraint a & b which is not equivalent to the two fairness\nconstraints a and b. (You can actually do it in four lines of SMV.)\n14. Explain the construction of formula φ4, used to express that the processes need\nnot enter their critical section in strict sequence. Does it rely on the fact that\nthe safety property φ1 holds?\n15.\n*\nCompute the ECG ⊤labels for Figure 3.11, given the fairness constraints of the\ncode in Figure 3.10 on page 196.\nExercises 3.7\n1. Consider the functions\nH1, H2, H3 : P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) →P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\ndeﬁned by\nH1(Y )\ndef\n= Y −{1, 4, 7}\nH2(Y )\ndef\n= {2, 5, 9} −Y\nH3(Y )\ndef\n= {1, 2, 3, 4, 5} ∩({2, 4, 8} ∪Y )\nfor all Y ⊆{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.\n(a)\n*\nWhich of these functions are monotone; which ones aren’t? Justify your an-\nswer in each case.\n(b)\n*\nbecause the goat meets an unhappy end in state 1.11.\nWhat went wrong? Nothing, actually. NuSMV has given us an inﬁnite\npath, which loops around the 15 illustrated states. Along the inﬁnite path,\nthe ferryman repeatedly takes his goods across (safely), and then back again\n(unsafely). This path does indeed satisfy the speciﬁcation φ U ψ, which as-\nserts the safety of the forward journey but says nothing about what happens\nafter that. In other words, the path is correct; it satisﬁes φ U ψ (with ψ oc-\ncurring at state 8). What happens along the path after that has no bearing\non φ U ψ.\n202\n3 Verification by model checking\nacws-0116% nusmv\nferryman.smv\n*** This is NuSMV 2.1.2 (compiled 2002-11-22 12:00:00)\n*** For more information of NuSMV see <http://nusmv.irst.itc.it>\n*** or email to <nusmv-users@irst.itc.it>.\n*** Please report bugs to <nusmv-users@irst.itc.it>.\n-- specification !(((goat = cabbage | goat = wolf) -> goat = ferryman)\nU (((cabbage & goat) & wolf) & ferryman)) is false\n-- as demonstrated by the following execution sequence\n-- loop starts here --\n-> State 1.1 <-\nferryman = 0\n-> State 1.8 <-\ngoat = 0\nferryman = 1\ncabbage = 0\ngoat = 1\nwolf = 0\ncarry = g\ncarry = 0\n-> State 1.9 <-\n-> State 1.2 <-\n-> State 1.10 <-\nferryman = 1\nferryman = 0\ngoat = 1\ncabbage = 0\ncarry = g\ncarry = c\n-> State 1.3 <-\n-> State 1.11 <-\nferryman = 0\nferryman = 1\ncarry = 0\ncarry = 0\n-> State 1.4 <-\n-> State 1.12 <-\nferryman = 1\nferryman = 0\ncabbage = 1\nwolf = 0\ncarry = c\ncarry = w\n-> State 1.5 <-\n-> State 1.13 <-\nferryman = 0\nferryman = 1\ngoat = 0\ncarry = 0\ncarry = g\n-> State 1.14 <-\n-> State 1.6 <-\nferryman = 0\nferryman = 1\ngoat = 0\nwolf = 1\ncarry = g\ncarry = w\n-> State 1.15 <-\n-> State 1.7 <-\ncarry = 0\nferryman = 0\ncarry = 0\nFigure 3.13. A solution path to the ferryman puzzle. It is unnecessar-\nily long. Using bounded model checking will refine it into an optimal\nsolution.\nInvoking bounded model checking will produce the shortest possible path\n‘New Symbolic Model Veriﬁer.’ NuSMV is an Open Source product, is ac-\ntively supported and has a substantial user community. For details on how\nto obtain it, see the bibliographic notes at the end of the chapter.\nNuSMV (sometimes called simply SMV) provides a language for describ-\ning the models we have been drawing as diagrams and it directly checks the\nvalidity of LTL (and also CTL) formulas on those models. SMV takes as\ninput a text consisting of a program describing a model and some speciﬁca-\ntions (temporal logic formulas). It produces as output either the word ‘true’\nif the speciﬁcations hold, or a trace showing why the speciﬁcation is false\nfor the model represented by our program.\nSMV programs consist of one or more modules. As in the programming\nlanguage C, or Java, one of the modules must be called main. Modules can\ndeclare variables and assign to them. Assignments usually give the initial\nvalue of a variable and its next value as an expression in terms of the current\nvalues of variables. This expression can be non-deterministic (denoted by\nseveral expressions in braces, or no assignment at all). Non-determinism is\nused to model the environment and for abstraction.\n192\n3 Verification by model checking\nThe following input to SMV:\nMODULE main\nVAR\nrequest : boolean;\nstatus : {ready,busy};\nASSIGN\ninit(status) := ready;\nnext(status) := case\nrequest : busy;\n1 : {ready,busy};\nesac;\nLTLSPEC\nG(request -> F status=busy)\nconsists of a program and a speciﬁcation. The program has two variables,\nrequest of type boolean and status of enumeration type {ready, busy}:\n0 denotes ‘false’ and 1 represents ‘true.’ The initial and subsequent values\nof variable request are not determined within this program; this conserva-\ntively models that these values are determined by an external environment.\nThis under-speciﬁcation of request implies that the value of variable status\nis partially determined: initially, it is ready; and it becomes busy whenever\nrun the speciﬁcation checks, as well as inspect partial results and set various\nparameters. See the NuSMV user manual for more details.\nNuSMV also supports bounded model checking, invoked by the command-\nline option -bmc. Bounded model checking looks for counterexamples in\norder of size, starting with counterexamples of length 1, then 2, etc., up\nto a given threshold (10 by default). Note that bounded model checking\nis incomplete: failure to ﬁnd a counterexample does not mean that there\nis none, but only that there is none of length up to the threshold. For\nrelated reasons, this incompleteness features also in Alloy and its constraint\nanalyzer. Thus, while a negative answer can be relied on (if NuSMV ﬁnds a\ncounterexample, it is valid), a positive one cannot. References on bounded\nmodel checking can be found in the bibliographic notes on page 254. Later\non, we use bounded model checking to prove the optimality of a scheduler.\n3.3.4 Mutual exclusion revisited\nFigure 3.10 gives the SMV code for a mutual exclusion protocol. This code\nconsists of two modules, main and prc. The module main has the variable\nturn, which determines whose turn it is to enter the critical section if both\nare trying to enter (recall the discussion about the states s3 and s9 in Sec-\ntion 3.3.1).\nThe module main also has two instantiations of prc. In each of these\ninstantiations, st is the status of a process (saying whether it is in its critical\nsection, or not, or trying) and other-st is the status of the other process\n(notice how this is passed as a parameter in the third and fourth lines of\nmain).\nThe value of st evolves in the way described in a previous section: when\nit is n, it may stay as n or move to t. When it is t, if the other one is n, it will\ngo straight to c, but if the other one is t, it will check whose turn it is before\ngoing to c. Then, when it is c, it may move back to n. Each instantiation of\nprc gives the turn to the other one when it gets to its critical section.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-4",
                            "title": "Mutual Exclusion Revisited",
                            "content": "it.\nThe transition system corresponding to this program is shown in\nFigure 3.11. Each state shows the values of the variables; for example, ct1\nis the state in which process 1 and 2 are critical and trying, respectively,\nand turn=1. The labels on the transitions show which process was selected\nfor execution. In general, each state has several transitions, some in which\nprocess 1 moves and others in which process 2 moves.\nThis model is a bit diﬀerent from the previous model given for mutual\nexclusion in Figure 3.8, for these two reasons:\nr Because the boolean variable turn has been explicitly introduced to distinguish\nbetween states s3 and s9 of Figure 3.8, we now distinguish between certain states\n198\n3 Verification by model checking\ncn0\ntn0\ntc0\ntt0\nnn0\nct0\n1,2\n2\n1\n1\n1\n2\n1,2\n1\n2\n2\n2\n2\n1\n1\n2\n1\n1,2\n1\n1,2\n1,2\n1\n2\n2\n2\n1\n2\n1\n1\n1\n2\n1\n2\n2\nnn1\ntn1\ncn1\nct1\nnt1\ntt1\nnc1\ntc1\n1,2\n2\nnc0\nnt0\n1,2\n2\n1\n1,2\n1,2\n1\n1,2\nFigure 3.11. The transition system corresponding to the SMV code\nin Figure 3.10. The labels on the transitions denote the process which\nmakes the move. The label 1, 2 means that either process could make\nthat move.\n3.3 Model checking: systems, tools, properties\n199\n(for example, ct0 and ct1) which were identical before. However, these states\nare not distinguished if you look just at the transitions from them. Therefore,\nthey satisfy the same LTL formulas which don’t mention turn. Those states are\ndistinguished only by the way they can arise.\nr We have eliminated an over-simpliﬁcation made in the model of Figure 3.8. Recall\nthat we assumed the system would move to a diﬀerent state on every tick of the\nclock (there were no transitions from a state to itself). In Figure 3.11, we allow\ntransitions from each state to itself, representing that a process was chosen for\nexecution and did some private computation, but did not move in or out of its\ncritical section. Of course, by doing this we have introduced paths in which one\na ﬁle on a disk or a database entry), it may be necessary to ensure that they\ndo not have access to it at the same time. Several processes simultaneously\nediting the same ﬁle would not be desirable.\nWe therefore identify certain critical sections of each process’ code and\narrange that only one process can be in its critical section at a time. The\ncritical section should include all the access to the shared resource (though it\nshould be as small as possible so that no unnecessary exclusion takes place).\nThe problem we are faced with is to ﬁnd a protocol for determining which\nprocess is allowed to enter its critical section at which time. Once we have\nfound one which we think works, we verify our solution by checking that it\nhas some expected properties, such as the following ones:\nSafety: Only one process is in its critical section at any time.\n188\n3 Verification by model checking\nn1n2\nt1n2\nc1n2\nt1t2\nn1t2\nn1c2\nt1c2\nc1t2\ns0\ns1\ns2\ns4\ns3\ns5\ns6\ns7\nFigure 3.7. A first-attempt model for mutual exclusion.\nThis safety property is not enough, since a protocol which permanently\nexcluded every process from its critical section would be safe, but not very\nuseful. Therefore, we should also require:\nLiveness: Whenever any process requests to enter its critical section, it\nwill eventually be permitted to do so.\nNon-blocking: A process can always request to enter its critical section.\nSome rather crude protocols might work on the basis that they cycle through\nthe processes, making each one in turn enter its critical section. Since it\nmight be naturally the case that some of them request access to the shared\nresource more often than others, we should make sure our protocol has the\nproperty:\nNo strict sequencing: Processes need not enter their critical section in\nstrict sequence.\nThe first modelling attempt\nWe will model two processes, each of\nwhich is in its non-critical state (n), or trying to enter its critical state (t),\nlabels given in Section 3.6.1.\n9.\n*\nFor mutual exclusion, draw a transition system which forces the two processes\nto enter their critical section in strict sequence and show that φ4 is false of its\ninitial state.\n10. Use the deﬁnition of ⊨between states and CTL formulas to explain why s ⊨\nAG AF φ means that φ is true inﬁnitely often along every path starting at s.\n11.\n*\nShow that a CTL formula φ is true on inﬁnitely many states of a computa-\ntion path s0 →s1 →s2 →. . . iﬀfor all n ≥0 there is some m ≥n such that\nsm ⊨φ.\n12. Run the NuSMV system on some examples. Try commenting out, or deleting,\nsome of the fairness constraints, if applicable, and see the counter examples\nNuSMV generates. NuSMV is very easy to run.\n13. In the one-bit channel, there are two fairness constraints. We could have written\nthis as a single one, inserting ‘&’ between running and the long formula, or we\ncould have separated the long formula into two and made it into a total of three\nfairness constraints.\nIn general, what is the diﬀerence between the single fairness constraint φ1 ∧φ2 ∧\n· · · ∧φn and the n fairness constraints φ1, φ2, . . . , φn? Write an SMV program\nwith a fairness constraint a & b which is not equivalent to the two fairness\nconstraints a and b. (You can actually do it in four lines of SMV.)\n14. Explain the construction of formula φ4, used to express that the processes need\nnot enter their critical section in strict sequence. Does it rely on the fact that\nthe safety property φ1 holds?\n15.\n*\nCompute the ECG ⊤labels for Figure 3.11, given the fairness constraints of the\ncode in Figure 3.10 on page 196.\nExercises 3.7\n1. Consider the functions\nH1, H2, H3 : P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) →P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\ndeﬁned by\nH1(Y )\ndef\n= Y −{1, 4, 7}\nH2(Y )\ndef\n= {2, 5, 9} −Y\nH3(Y )\ndef\n= {1, 2, 3, 4, 5} ∩({2, 4, 8} ∪Y )\nfor all Y ⊆{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.\n(a)\n*\nWhich of these functions are monotone; which ones aren’t? Justify your an-\nswer in each case.\n(b)\n*\nx-node above both of them would become redundant. Removing it would\nresult in the BDD on the right of Figure 6.5.\nTo summarise, we encountered three diﬀerent ways of reducing a BDD to\na more compact form:\nC1. Removal of duplicate terminals. If a BDD contains more than one\nterminal 0-node, then we redirect all edges which point to such a 0-node to\njust one of them. We proceed in the same way with terminal nodes labelled\nwith 1.\nC2. Removal of redundant tests. If both outgoing edges of a node n\npoint to the same node m, then we eliminate that node n, sending all its\nincoming edges to m.\nC3. Removal of duplicate non-terminals. If two distinct nodes n and\nm in the BDD are the roots of structurally identical subBDDs, then we\n364\n6 Binary decision diagrams\nx\n1\n0\nz\ny\ny\ny\nx\n0\n1\nz\ny\ny\nx\nFigure 6.5. The BDD of Figure 6.4: (a) after removal of one of the\nduplicate y-nodes; (b) after removal of another duplicate y-node and\nthen a redundant x-decision point.\neliminate one of them, say m, and redirect all its incoming edges to the\nother one.\nNote that C1 is a special case of C3. In order to deﬁne BDDs precisely,\nwe need a few auxiliary notions.\nDeﬁnition 6.4 A directed graph is a set G and a binary relation →on G:\n→⊆G × G. A cycle in a directed graph is a ﬁnite path in that graph that\nbegins and ends at the same node, i.e. a path of the form v1 →v2 →· · · →\nvn →v1. A directed acyclic graph (dag) is a directed graph that does not\nhave any cycles. A node of a dag is initial if there are no edges pointing to\nthat node. A node is called terminal if there are no edges out of that node.\nThe directed graph in Figure 3.3 on page 179 has cycles, for example\nthe cycle s0 →s1 →s0, and is not a dag. If we interpret the links in BDDs\n(whether solid or dashed) as always going in a downwards direction, then\nthe BDDs of this chapter are also directed graphs. They are also acyclic and\nhave a unique initial node. The optimisations C1–C3 preserve the property\nordering and then to apply all possible reductions.\n(a) [x, y, z].\n(b) [y, x, z].\n(c) [z, x, y].\n(d) Find an ordering of variables for which the resulting reduced OBDD Bf has a\nminimal number of edges; i.e. there is no ordering for which the corresponding\nBf has fewer edges. (How many possible orderings for x, y and z are there?)\n4. Given the truth table\nx\ny\nz\nf(x, y, z)\n1\n1\n1\n0\n1\n1\n0\n1\n1\n0\n1\n1\n1\n0\n0\n0\n0\n1\n1\n0\n0\n1\n0\n1\n0\n0\n1\n0\n0\n0\n0\n1\ncompute the reduced OBDD with respect to the following ordering of variables:\n(a) [x, y, z]\n(b) [z, y, x]\n(c) [y, z, x]\n(d) [x, z, y].\n5. Given the ordering [p, q, r], compute the reduced BDDs for p ∧(q ∨r) and (p ∧\nq) ∨(p ∧r) and explain why they are identical.\n6.\n*\nConsider the BDD in Figure 6.11 (page 370).\n(a) Construct its truth table.\n(b) Compute its conjunctive normal form.\n(c) Compare the length of that normal form with the size of the BDD. What is\nyour assessment?\n402\n6 Binary decision diagrams\nExercises 6.6\n1. Perform the execution of reduce on the following OBDDs:\n(a) The binary decision tree for\ni. x ⊕y\nii. x · y\niii. x + y\niv. x ↔y.\n(b) The OBDD in Figure 6.2 (page 361).\n(c)\n*\nThe OBDD in Figure 6.4 (page 363).\nExercises 6.7\n1. Recall the Shannon expansion in (6.1) on page 374. Suppose that x does not\noccur in f at all. Why does (6.1) still hold?\n2. Let f(x, y, z)\ndef\n= y + z · x + z · y + y · x be a boolean formula. Compute f’s\nShannon expansion with respect to\n(a) x\n(b) y\n(c) z.\n3. Show that boolean formulas f and g are semantically equivalent if, and only if,\nthe boolean formula (f + g) · (f + g) computes 1 for all possible assignments of\n0s and 1s to their variables.\n4. We may use the Shannon expansion to deﬁne formally how BDDs determine\nboolean functions. Let B be a BDD. It is intuitively clear that B determines\na unique boolean function. Formally, we compute a function fn inductively\n(bottom-up) for all nodes n of B:\n– If n is a terminal node labelled 0, then fn is the constant 0 function.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-5",
                            "title": "The Ferryman",
                            "content": "transitions from each state to itself, representing that a process was chosen for\nexecution and did some private computation, but did not move in or out of its\ncritical section. Of course, by doing this we have introduced paths in which one\nprocess gets stuck in its critical section, whence the need to invoke a fairness\nconstraint to eliminate such paths.\n3.3.5 The ferryman\nYou may recall the puzzle of a ferryman, goat, cabbage, and wolf all on one\nside of a river. The ferryman can cross the river with at most one passenger\nin his boat. There is a behavioural conﬂict between:\n1.\nthe goat and the cabbage; and\n2.\nthe goat and the wolf;\nif they are on the same river bank but the ferryman crosses the river or stays\non the other bank.\nCan the ferryman transport all goods to the other side, without any con-\nﬂicts occurring? This is a planning problem, but it can be solved by model\nchecking. We describe a transition system in which the states represent which\ngoods are at which side of the river. Then we ask if the goal state is reach-\nable from the initial state: Is there a path from the initial state such that it\nhas a state along it at which all the goods are on the other side, and during\nthe transitions to that state the goods are never left in an unsafe, conﬂicting\nsituation?\nWe model all possible behaviour (including that which results in conﬂicts)\nas a NuSMV program (Figure 3.12). The location of each agent is modelled\nas a boolean variable: 0 denotes that the agent is on the initial bank, and\n1 the destination bank. Thus, ferryman = 0 means that the ferryman is\non the initial bank, ferryman = 1 that he is on the destination bank, and\nsimilarly for the variables goat, cabbage and wolf.\nThe variable carry takes a value indicating whether the goat, cabbage,\nwolf or nothing is carried by the ferryman. The deﬁnition of next(carry)\nworks as follows. It is non-deterministic, but the set from which a value is\ncarry = w\n-> State 1.15 <-\n-> State 1.7 <-\ncarry = 0\nferryman = 0\ncarry = 0\nFigure 3.13. A solution path to the ferryman puzzle. It is unnecessar-\nily long. Using bounded model checking will refine it into an optimal\nsolution.\nInvoking bounded model checking will produce the shortest possible path\nto violate the property; in this case, it is states 1.1 to 1.8 of the illus-\ntrated path. It is the shortest, optimal solution to our planning problem\nsince the model check NuSMV -bmc -bmc_length 7 ferryman.smv shows\nthat the LTL formula holds in that model, meaning that no solution with\nfewer than seven transitions is possible.\n3.3 Model checking: systems, tools, properties\n203\nOne might wish to verify whether there is a solution which involves three\njourneys for the goat. This can be done by altering the LTL formula. In-\nstead of seeking a path satisfying φ U ψ, where φ equals (goat = cabbage ∨\ngoat = wolf) →goat = ferryman and ψ equals cabbage ∧goat ∧wolf ∧\nferryman, we now seek a path satisfying (φ U ψ) ∧G (goat →G goat). The\nlast bit says that once the goat has crossed, he remains across; otherwise,\nthe goat makes at least three trips. NuSMV veriﬁes that the negation of this\nformula is true, conﬁrming that there is no such solution.\n3.3.6 The alternating bit protocol\nThe alternating bit protocol (ABP) is a protocol for transmitting messages\nalong a ‘lossy line,’ i.e., a line which may lose or duplicate messages. The\nprotocol guarantees that, providing the line doesn’t lose inﬁnitely many mes-\nsages, communication between the sender and the receiver will be successful.\n(We allow the line to lose or duplicate messages, but it may not corrupt mes-\nsages; however, there is no way of guaranteeing successful transmission along\na line which can corrupt.)\nThe ABP works as follows. There are four entities, or agents: the sender,\nthe receiver, the message channel and the acknowledgement channel. The\nsender transmits the ﬁrst part of the message together with the ‘control’\nbecause the goat meets an unhappy end in state 1.11.\nWhat went wrong? Nothing, actually. NuSMV has given us an inﬁnite\npath, which loops around the 15 illustrated states. Along the inﬁnite path,\nthe ferryman repeatedly takes his goods across (safely), and then back again\n(unsafely). This path does indeed satisfy the speciﬁcation φ U ψ, which as-\nserts the safety of the forward journey but says nothing about what happens\nafter that. In other words, the path is correct; it satisﬁes φ U ψ (with ψ oc-\ncurring at state 8). What happens along the path after that has no bearing\non φ U ψ.\n202\n3 Verification by model checking\nacws-0116% nusmv\nferryman.smv\n*** This is NuSMV 2.1.2 (compiled 2002-11-22 12:00:00)\n*** For more information of NuSMV see <http://nusmv.irst.itc.it>\n*** or email to <nusmv-users@irst.itc.it>.\n*** Please report bugs to <nusmv-users@irst.itc.it>.\n-- specification !(((goat = cabbage | goat = wolf) -> goat = ferryman)\nU (((cabbage & goat) & wolf) & ferryman)) is false\n-- as demonstrated by the following execution sequence\n-- loop starts here --\n-> State 1.1 <-\nferryman = 0\n-> State 1.8 <-\ngoat = 0\nferryman = 1\ncabbage = 0\ngoat = 1\nwolf = 0\ncarry = g\ncarry = 0\n-> State 1.9 <-\n-> State 1.2 <-\n-> State 1.10 <-\nferryman = 1\nferryman = 0\ngoat = 1\ncabbage = 0\ncarry = g\ncarry = c\n-> State 1.3 <-\n-> State 1.11 <-\nferryman = 0\nferryman = 1\ncarry = 0\ncarry = 0\n-> State 1.4 <-\n-> State 1.12 <-\nferryman = 1\nferryman = 0\ncabbage = 1\nwolf = 0\ncarry = c\ncarry = w\n-> State 1.5 <-\n-> State 1.13 <-\nferryman = 0\nferryman = 1\ngoat = 0\ncarry = 0\ncarry = g\n-> State 1.14 <-\n-> State 1.6 <-\nferryman = 0\nferryman = 1\ngoat = 0\nwolf = 1\ncarry = g\ncarry = w\n-> State 1.15 <-\n-> State 1.7 <-\ncarry = 0\nferryman = 0\ncarry = 0\nFigure 3.13. A solution path to the ferryman puzzle. It is unnecessar-\nily long. Using bounded model checking will refine it into an optimal\nsolution.\nInvoking bounded model checking will produce the shortest possible path\nare carried or not is determined by the ferryman’s choice, represented by the\nnon-deterministic assignment to carry; these values follow the same pattern.\nNote how the boolean guards refer to state bits at the next state. The\nSMV compiler does a dependency analysis and rejects circular dependencies\non next values. (The dependency analysis is rather pessimistic: sometimes\nNuSMV complains of circularity even in situations when it could be resolved.\nThe original CMU-SMV is more liberal in this respect.)\nRunning NuSMV\nWe seek a path satisfying φ U ψ, where ψ asserts the\nﬁnal goal state, and φ expresses the safety condition (if the goat is with\nthe cabbage or the wolf, then the ferryman is there, too, to prevent any\nuntoward behaviour). Thus, we assert that all paths satisfy ¬(φ U ψ), i.e.,\nno path satisﬁes φ U ψ. We hope this is not the case, and NuSMV will give\nus an example path which does satisfy φ U ψ. Indeed, running NuSMV gives\nus the path of Figure 3.13, which represents a solution to the puzzle.\nThe beginning of the generated path represents the usual solution to this\npuzzle: the ferryman takes the goat ﬁrst, then goes back for the cabbage. To\navoid leaving the goat and the cabbage together, he takes the goat back, and\npicks up the wolf. Now the wolf and the cabbage are on the destination side,\nand he goes back again to get the goat. This brings us to State 1.9, where\nthe ferryman appears to take a well-earned break. But the path continues.\nStates 1.10 to 1.15 show that he takes his charges back to the original side\nof the bank; ﬁrst the cabbage, then the wolf, then the goat. Unfortunately\nit appears that the ferryman’s clever plan up to state 1.9 is now spoiled,\nbecause the goat meets an unhappy end in state 1.11.\nWhat went wrong? Nothing, actually. NuSMV has given us an inﬁnite\npath, which loops around the 15 illustrated states. Along the inﬁnite path,\nthe ferryman repeatedly takes his goods across (safely), and then back again\nsimilarly for the variables goat, cabbage and wolf.\nThe variable carry takes a value indicating whether the goat, cabbage,\nwolf or nothing is carried by the ferryman. The deﬁnition of next(carry)\nworks as follows. It is non-deterministic, but the set from which a value is\nnon-deterministically chosen is determined by the values of ferryman, goat,\nMODULE main\nVAR\nferryman : boolean;\ngoat\n: boolean;\ncabbage\n: boolean;\nwolf\n: boolean;\ncarry\n: {g,c,w,0};\nASSIGN\ninit(ferryman) := 0; init(goat)\n:= 0;\ninit(cabbage)\n:= 0; init(wolf)\n:= 0;\ninit(carry)\n:= 0;\nnext(ferryman) := 0,1;\nnext(carry) := case\nferryman=goat : g;\n1\n: 0;\nesac union\ncase\nferryman=cabbage : c;\n1\n: 0;\nesac union\ncase\nferryman=wolf : w;\n1\n: 0;\nesac union 0;\nnext(goat) := case\nferryman=goat\n& next(carry)=g : next(ferryman);\n1\n: goat;\nesac;\nnext(cabbage) := case\nferryman=cabbage & next(carry)=c : next(ferryman);\n1\n: cabbage;\nesac;\nnext(wolf) := case\nferryman=wolf & next(carry)=w : next(ferryman);\n1\n: wolf;\nesac;\nLTLSPEC !((\n(goat=cabbage | goat=wolf) -> goat=ferryman)\nU (cabbage & goat & wolf & ferryman))\nFigure 3.12. NuSMV code for the ferryman planning problem.\n3.3 Model checking: systems, tools, properties\n201\netc., and always includes 0. If ferryman = goat (i.e., they are on the same\nside) then g is a member of the set from which next(carry) is chosen. The\nsituation for cabbage and wolf is similar. Thus, if ferryman = goat = wolf ̸=\ncabbage then that set is {g, w, 0}. The next value assigned to ferryman is\nnon-deterministic: he can choose to cross or not to cross the river. But the\nnext values of goat, cabbage and wolf are deterministic, since whether they\nare carried or not is determined by the ferryman’s choice, represented by the\nnon-deterministic assignment to carry; these values follow the same pattern.\nNote how the boolean guards refer to state bits at the next state. The\nSMV compiler does a dependency analysis and rejects circular dependencies",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-6",
                            "title": "The Alternating Bit Protocol",
                            "content": "init(st) := sending;\nnext(st) := case\nack = message2 & !(st=sent) : sent;\n1\n: sending;\nesac;\nnext(message1) :=\ncase\nst = sent : {0,1};\n1\n: message1;\nesac;\nnext(message2) :=\ncase\nst = sent : !message2;\n1\n: message2;\nesac;\nFAIRNESS running\nLTLSPEC G F st=sent\nFigure 3.14. The ABP sender in SMV.\nsequentially. The variable message1 is the current bit of the message be-\ning sent, whereas message2 is the control bit. The deﬁnition of the mod-\nule sender is given in Figure 3.14. This module spends most of its time in\nst=sending, going only brieﬂy to st=sent when it receives an acknowledge-\nment corresponding to the control bit of the message it has been sending.\nThe variables message1 and message2 represent the actual data being sent\nand the control bit, respectively. On successful transmission, the module ob-\ntains a new message to send and returns to st=sending. The new message1\nis obtained non-deterministically (i.e., from the environment); message2 al-\nternates in value. We impose FAIRNESS running, i.e., the sender must be\nselected to run inﬁnitely often. The LTLSPEC tests that we can always suc-\nceed in sending the current message. The module receiver is programmed\nin a similar way, in Figure 3.15.\nWe also need to describe the two channels, in Figure 3.16. The acknowl-\nedgement channel is an instance of the one-bit channel one-bit-chan below.\nIts lossy character is speciﬁed by the assignment to forget. The value of\n3.3 Model checking: systems, tools, properties\n205\nMODULE receiver(message1,message2)\nVAR\nst\n: {receiving,received};\nack\n: boolean;\nexpected : boolean;\nASSIGN\ninit(st) := receiving;\nnext(st) := case\nmessage2=expected & !(st=received) : received;\n1\n: receiving;\nesac;\nnext(ack) :=\ncase\nst = received : message2;\n1\n: ack;\nesac;\nnext(expected) :=\ncase\nst = received : !expected;\n1\n: expected;\nesac;\nFAIRNESS running\nLTLSPEC G F st=received\nFigure 3.15. The ABP receiver in SMV.\ninput should be transmitted to output, unless forget is true. The two-bit\nnext(output1) := case\nforget : output1;\n1:\ninput1;\nesac;\nnext(output2) := case\nforget : output2;\n1:\ninput2;\nesac;\nFAIRNESS running\nFAIRNESS input1 & !forget\nFAIRNESS !input1 & !forget\nFAIRNESS input2 & !forget\nFAIRNESS !input2 & !forget\nFigure 3.16. The two modules for the two ABP channels in SMV.\ncontraints of the form ‘inﬁnitely often p implies inﬁnitely often q’, which\nwould be more satisfactory here, but is not allowed by SMV.\nFinally, we tie it all together with the module main (Figure 3.17). Its role\nis to connect together the components of the system, and giving them initial\nvalues of their parameters. Since the ﬁrst control bit is 0, we also initialise\nthe receiver to expect a 0. The receiver should start oﬀby sending 1 as its\n3.4 Branching-time logic\n207\nMODULE main\nVAR\ns : process sender(ack_chan.output);\nr : process receiver(msg_chan.output1,msg_chan.output2);\nmsg_chan : process two-bit-chan(s.message1,s.message2);\nack_chan : process one-bit-chan(r.ack);\nASSIGN\ninit(s.message2) := 0;\ninit(r.expected) := 0;\ninit(r.ack)\n:= 1;\ninit(msg_chan.output2) := 1;\ninit(ack_chan.output) := 1;\nLTLSPEC\nG (s.st=sent & s.message1=1 -> msg_chan.output1=1)\nFigure 3.17. The main ABP module.\nacknowledgement, so that sender does not think that its very ﬁrst message\nis being acknowledged before anything has happened. For the same reason,\nthe output of the channels is initialised to 1.\nThe speciﬁcations for ABP.\nOur SMV program satisﬁes the following spec-\niﬁcations:\nSafety: If the message bit 1 has been sent and the correct acknowledge-\nment has been returned, then a 1 was indeed received by the receiver:\nG (S.st=sent & S.message1=1 -> msg chan.output1=1).\nLiveness: Messages get through eventually. Thus, for any state there is\ninevitably a future state in which the current message has got through. In\nthe module sender, we speciﬁed G F st=sent. (This speciﬁcation could\nequivalently have been written in the main module, as G F S.st=sent.)\na line which can corrupt.)\nThe ABP works as follows. There are four entities, or agents: the sender,\nthe receiver, the message channel and the acknowledgement channel. The\nsender transmits the ﬁrst part of the message together with the ‘control’\nbit 0. If, and when, the receiver receives a message with the control bit 0,\nit sends 0 along the acknowledgement channel. When the sender receives\nthis acknowledgement, it sends the next packet with the control bit 1. If\nand when the receiver receives this, it acknowledges by sending a 1 on the\nacknowledgement channel. By alternating the control bit, both receiver and\nsender can guard against duplicating messages and losing messages (i.e.,\nthey ignore messages that have the unexpected control bit).\nIf the sender doesn’t get the expected acknowledgement, it continually re-\nsends the message, until the acknowledgement arrives. If the receiver doesn’t\nget a message with the expected control bit, it continually resends the pre-\nvious acknowledgement.\nFairness is also important for the ABP. It comes in because, although\nwe want to model the fact that the channel can lose messages, we want to\nassume that, if we send a message often enough, eventually it will arrive.\nIn other words, the channel cannot lose an inﬁnite sequence of messages. If\nwe did not make this assumption, then the channels could lose all messages\nand, in that case, the ABP would not work.\nLet us see this in the concrete setting of SMV. We may assume that\nthe text to be sent is divided up into single-bit messages, which are sent\n204\n3 Verification by model checking\nMODULE sender(ack)\nVAR\nst\n: {sending,sent};\nmessage1 : boolean;\nmessage2 : boolean;\nASSIGN\ninit(st) := sending;\nnext(st) := case\nack = message2 & !(st=sent) : sent;\n1\n: sending;\nesac;\nnext(message1) :=\ncase\nst = sent : {0,1};\n1\n: message1;\nesac;\nnext(message2) :=\ncase\nst = sent : !message2;\n1\n: message2;\nesac;\nFAIRNESS running\nLTLSPEC G F st=sent\nFigure 3.14. The ABP sender in SMV.\nesac;\nnext(ack) :=\ncase\nst = received : message2;\n1\n: ack;\nesac;\nnext(expected) :=\ncase\nst = received : !expected;\n1\n: expected;\nesac;\nFAIRNESS running\nLTLSPEC G F st=received\nFigure 3.15. The ABP receiver in SMV.\ninput should be transmitted to output, unless forget is true. The two-bit\nchannel two-bit-chan, used to send messages, is similar. Again, the non-\ndeterministic variable forget determines whether the current bit is lost or\nnot. Either both parts of the message get through, or neither of them does\n(the channel is assumed not to corrupt messages).\nThe channels have fairness constraint which are intended to model the fact\nthat, although channels can lose messages, we assume that they inﬁnitely\noften transmit the message correctly. (If this were not the case, then we\ncould ﬁnd an uninteresting violation of the liveness property, for example a\npath along which all messages from a certain time onwards get lost.)\nIt is interesting to note that the fairness constraint ‘inﬁnitely often\n!forget’ is not suﬃcient to prove the desired properties, for although it\nforces the channel to transmit inﬁnitely often, it doesn’t prevent it from\n(say) dropping all the 0 bits and transmitting all the 1 bits. That is why\nwe use the stronger fairness constraints shown. Some systems allow fairness\n206\n3 Verification by model checking\nMODULE one-bit-chan(input)\nVAR\noutput : boolean;\nforget : boolean;\nASSIGN\nnext(output) := case\nforget : output;\n1:\ninput;\nesac;\nFAIRNESS running\nFAIRNESS input & !forget\nFAIRNESS !input & !forget\nMODULE two-bit-chan(input1,input2)\nVAR\nforget : boolean;\noutput1 : boolean;\noutput2 : boolean;\nASSIGN\nnext(output1) := case\nforget : output1;\n1:\ninput1;\nesac;\nnext(output2) := case\nforget : output2;\n1:\ninput2;\nesac;\nFAIRNESS running\nFAIRNESS input1 & !forget\nFAIRNESS !input1 & !forget\nFAIRNESS input2 & !forget\nFAIRNESS !input2 & !forget\nFigure 3.16. The two modules for the two ABP channels in SMV.\nlabels given in Section 3.6.1.\n9.\n*\nFor mutual exclusion, draw a transition system which forces the two processes\nto enter their critical section in strict sequence and show that φ4 is false of its\ninitial state.\n10. Use the deﬁnition of ⊨between states and CTL formulas to explain why s ⊨\nAG AF φ means that φ is true inﬁnitely often along every path starting at s.\n11.\n*\nShow that a CTL formula φ is true on inﬁnitely many states of a computa-\ntion path s0 →s1 →s2 →. . . iﬀfor all n ≥0 there is some m ≥n such that\nsm ⊨φ.\n12. Run the NuSMV system on some examples. Try commenting out, or deleting,\nsome of the fairness constraints, if applicable, and see the counter examples\nNuSMV generates. NuSMV is very easy to run.\n13. In the one-bit channel, there are two fairness constraints. We could have written\nthis as a single one, inserting ‘&’ between running and the long formula, or we\ncould have separated the long formula into two and made it into a total of three\nfairness constraints.\nIn general, what is the diﬀerence between the single fairness constraint φ1 ∧φ2 ∧\n· · · ∧φn and the n fairness constraints φ1, φ2, . . . , φn? Write an SMV program\nwith a fairness constraint a & b which is not equivalent to the two fairness\nconstraints a and b. (You can actually do it in four lines of SMV.)\n14. Explain the construction of formula φ4, used to express that the processes need\nnot enter their critical section in strict sequence. Does it rely on the fact that\nthe safety property φ1 holds?\n15.\n*\nCompute the ECG ⊤labels for Figure 3.11, given the fairness constraints of the\ncode in Figure 3.10 on page 196.\nExercises 3.7\n1. Consider the functions\nH1, H2, H3 : P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) →P({1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\ndeﬁned by\nH1(Y )\ndef\n= Y −{1, 4, 7}\nH2(Y )\ndef\n= {2, 5, 9} −Y\nH3(Y )\ndef\n= {1, 2, 3, 4, 5} ∩({2, 4, 8} ∪Y )\nfor all Y ⊆{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}.\n(a)\n*\nWhich of these functions are monotone; which ones aren’t? Justify your an-\nswer in each case.\n(b)\n*",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-4",
                    "title": "Branching-Time Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-4-subsection-1",
                            "title": "Syntax of CTL",
                            "content": "U cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nConvention 3.13 We assume similar binding priorities for the CTL con-\nnectives to what we did for propositional and predicate logic. The unary\nconnectives (consisting of ¬ and the temporal connectives AG, EG, AF, EF,\nAX and EX) bind most tightly. Next in the order come ∧and ∨; and after\nthat come →, AU and EU .\nNaturally, we can use brackets in order to override these priorities. Let\nus see some examples of well-formed CTL formulas and some examples\nwhich are not well-formed, in order to understand the syntax. Suppose\nthat p, q and r are atomic formulas. The following are well-formed CTL\nformulas:\nr AG (q →EG r), note that this is not the same as AG q →EG r, for according to\nConvention 3.13, the latter formula means (AG q) →(EG r)\nr EF E[r U q]\nr A[p U EF r]\nr EF EG p →AF r, again, note that this binds as (EF EG p) →AF r, not\nEF (EG p →AF r) or EF EG (p →AF r)\nr A[p1 U A[p2 U p3]]\nr E[A[p1 U p2] U p3]\nr AG (p →A[p U (¬p ∧A[¬p U q])]).\nIt is worth spending some time seeing how the syntax rules allow us to\nconstruct each of these. The following are not well-formed formulas:\nr EF G r\nr A¬G ¬p\nr F [r U q]\nr EF (r U q)\nr AEF r\nr A[(r U q) ∧(p U r)].\nIt is especially worth understanding why the syntax rules don’t allow us to\nconstruct these. For example, take EF (r U q). The problem with this string\nis that U can occur only when paired with an A or an E. The E we have is\npaired with the F. To make this into a well-formed CTL formula, we would\nhave to write EF E[r U q] or EF A[r U q].\n210\n3 Verification by model checking\nAU\nEU\nAX\n¬\n¬\nEX\np\np\n∧\nq\np\nFigure 3.18. The parse tree of a CTL formula without infix notation.\nNotice that we use square brackets after the A or E, when the paired\nall paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nLTL we also have quantiﬁers A and E which express ‘all paths’ and ‘exists\na path’, respectively. For example, we can write:\nr There is a reachable state satisfying q: this is written EF q.\nr From all reachable states satisfying p, it is possible to maintain p continuously\nuntil reaching a state satisfying q: this is written AG (p →E[p U q]).\nr Whenever a state satisfying p is reached, the system can exhibit q continuously\nforevermore: AG (p →EG q).\nr There is a reachable state from which all reachable states satisfy p: EF AG p.\n3.4.1 Syntax of CTL\nComputation Tree Logic, or CTL for short, is a branching-time logic, mean-\ning that its model of time is a tree-like structure in which the future is not\ndetermined; there are diﬀerent paths in the future, any one of which might\nbe the ‘actual’ path that is realised.\nAs before, we work with a ﬁxed set of atomic formulas/descriptions (such\nas p, q, r, . . . , or p1, p2, . . . ).\nDeﬁnition 3.12 We deﬁne CTL formulas inductively via a Backus Naur\nform as done for LTL:\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | AX φ | EX φ |\nAF φ | EF φ | AG φ | EG φ | A[φ U φ] | E[φ U φ]\nwhere p ranges over a set of atomic formulas.\nNotice that each of the CTL temporal connectives is a pair of symbols.\nThe ﬁrst of the pair is one of A and E. A means ‘along All paths’ (inevitably)\nand E means ‘along at least (there Exists) one path’ (possibly). The second\none of the pair is X, F, G, or U, meaning ‘neXt state,’ ‘some Future state,’\n‘all future states (Globally)’ and Until, respectively. The pair of symbols\nin E[φ1 U φ2], for example, is EU. In CTL, pairs of symbols like EU are\n3.4 Branching-time logic\n209\nindivisible. Notice that AU and EU are binary. The symbols X, F, G and\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-2",
                            "title": "Semantics of CTL",
                            "content": "U cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nConvention 3.13 We assume similar binding priorities for the CTL con-\nnectives to what we did for propositional and predicate logic. The unary\nconnectives (consisting of ¬ and the temporal connectives AG, EG, AF, EF,\nAX and EX) bind most tightly. Next in the order come ∧and ∨; and after\nthat come →, AU and EU .\nNaturally, we can use brackets in order to override these priorities. Let\nus see some examples of well-formed CTL formulas and some examples\nwhich are not well-formed, in order to understand the syntax. Suppose\nthat p, q and r are atomic formulas. The following are well-formed CTL\nformulas:\nr AG (q →EG r), note that this is not the same as AG q →EG r, for according to\nConvention 3.13, the latter formula means (AG q) →(EG r)\nr EF E[r U q]\nr A[p U EF r]\nr EF EG p →AF r, again, note that this binds as (EF EG p) →AF r, not\nEF (EG p →AF r) or EF EG (p →AF r)\nr A[p1 U A[p2 U p3]]\nr E[A[p1 U p2] U p3]\nr AG (p →A[p U (¬p ∧A[¬p U q])]).\nIt is worth spending some time seeing how the syntax rules allow us to\nconstruct each of these. The following are not well-formed formulas:\nr EF G r\nr A¬G ¬p\nr F [r U q]\nr EF (r U q)\nr AEF r\nr A[(r U q) ∧(p U r)].\nIt is especially worth understanding why the syntax rules don’t allow us to\nconstruct these. For example, take EF (r U q). The problem with this string\nis that U can occur only when paired with an A or an E. The E we have is\npaired with the F. To make this into a well-formed CTL formula, we would\nhave to write EF E[r U q] or EF A[r U q].\n210\n3 Verification by model checking\nAU\nEU\nAX\n¬\n¬\nEX\np\np\n∧\nq\np\nFigure 3.18. The parse tree of a CTL formula without infix notation.\nNotice that we use square brackets after the A or E, when the paired\nall paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nLTL we also have quantiﬁers A and E which express ‘all paths’ and ‘exists\na path’, respectively. For example, we can write:\nr There is a reachable state satisfying q: this is written EF q.\nr From all reachable states satisfying p, it is possible to maintain p continuously\nuntil reaching a state satisfying q: this is written AG (p →E[p U q]).\nr Whenever a state satisfying p is reached, the system can exhibit q continuously\nforevermore: AG (p →EG q).\nr There is a reachable state from which all reachable states satisfy p: EF AG p.\n3.4.1 Syntax of CTL\nComputation Tree Logic, or CTL for short, is a branching-time logic, mean-\ning that its model of time is a tree-like structure in which the future is not\ndetermined; there are diﬀerent paths in the future, any one of which might\nbe the ‘actual’ path that is realised.\nAs before, we work with a ﬁxed set of atomic formulas/descriptions (such\nas p, q, r, . . . , or p1, p2, . . . ).\nDeﬁnition 3.12 We deﬁne CTL formulas inductively via a Backus Naur\nform as done for LTL:\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | AX φ | EX φ |\nAF φ | EF φ | AG φ | EG φ | A[φ U φ] | E[φ U φ]\nwhere p ranges over a set of atomic formulas.\nNotice that each of the CTL temporal connectives is a pair of symbols.\nThe ﬁrst of the pair is one of A and E. A means ‘along All paths’ (inevitably)\nand E means ‘along at least (there Exists) one path’ (possibly). The second\none of the pair is X, F, G, or U, meaning ‘neXt state,’ ‘some Future state,’\n‘all future states (Globally)’ and Until, respectively. The pair of symbols\nin E[φ1 U φ2], for example, is EU. In CTL, pairs of symbols like EU are\n3.4 Branching-time logic\n209\nindivisible. Notice that AU and EU are binary. The symbols X, F, G and\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\n3.6.1 The CTL model-checking algorithm\nHumans may ﬁnd it easier to do model checks on the unwindings of models\ninto inﬁnite trees, given a designated initial state, for then all possible paths\nare plainly visible. However, if we think of implementing a model checker\non a computer, we certainly cannot unwind transition systems into inﬁ-\nnite trees. We need to do checks on ﬁnite data structures. For this reason,\nwe now have to develop new insights into the semantics of CTL. Such a\ndeeper understanding will provide the basis for an eﬃcient algorithm which,\ngiven M, s ∈S and φ, computes whether M, s ⊨φ holds. In the case that\nφ is not satisﬁed, such an algorithm can be augmented to produce an ac-\ntual path (= run) of the system demonstrating that M cannot satisfy φ.\nThat way, we may debug a system by trying to ﬁx what enables runs which\nrefute φ.\nThere are various ways in which one could consider\nM, s0\n?\n⊨φ\nas a computational problem. For example, one could have the model M, the\nformula φ and a state s0 as input; one would then expect a reply of the form\n‘yes’ (M, s0 ⊨φ holds), or ‘no’ (M, s0 ⊨φ does not hold). Alternatively, the\ninputs could be just M and φ, where the output would be all states s of the\nmodel M which satisfy φ.\nIt turns out that it is easier to provide an algorithm for solving the second\nof these two problems. This automatically gives us a solution to the ﬁrst one,\nsince we can simply check whether s0 is an element of the output set.\nThe labelling algorithm\nWe present an algorithm which, given a model\nand a CTL formula, outputs the set of states of the model that satisfy the\nformula. The algorithm does not need to be able to handle every CTL con-\nnective explicitly, since we have already seen that the connectives ⊥, ¬ and\n∧form an adequate set as far as the propositional connectives are concerned;\nand AF , EU and EX form an adequate set of temporal connectives. Given\nan arbitrary CTL formula φ, we would simply pre-process φ in order to write",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-3",
                            "title": "Practical Patterns of Specifications",
                            "content": "speciﬁcations are usually symbolic encodings of real-world constraints into\nsome sort of logic. Thus, a framework for producing the software could be:\nr Convert the informal description R of requirements for an application domain\ninto an ‘equivalent’ formula φR of some symbolic logic;\nr Write a program P which is meant to realise φR in the programming environment\nsupplied by your company, or wanted by the particular customer;\nr Prove that the program P satisﬁes the formula φR.\nThis scheme is quite crude – for example, constraints may be actual design\ndecisions for interfaces and data types, or the speciﬁcation may ‘evolve’\n4.2 A framework for software verification\n259\nand may partly be ‘unknown’ in big projects – but it serves well as a ﬁrst\napproximation to trying to deﬁne good programming methodology. Several\nvariations of such a sequence of activities are conceivable. For example,\nyou, as a programmer, might have been given only the formula φR, so you\nmight have little if any insight into the real-world problem which you are\nsupposed to solve. Technically, this poses no problem, but often it is handy\nto have both informal and formal descriptions available. Moreover, crafting\nthe informal requirements R is often a mutual process between the client\nand the programmer, whereby the attempt at formalising R can uncover\nambiguities or undesired consequences and hence lead to revisions of R.\nThis ‘going back and forth’ between the realms of informal and formal\nspeciﬁcations is necessary since it is impossible to ‘verify’ whether an infor-\nmal requirement R is equivalent to a formal description φR. The meaning\nof R as a piece of natural language is grounded in common sense and gen-\neral knowledge about the real-world domain and often based on heuristics\nor quantitative reasoning. The meaning of a logic formula φR, on the other\nhand, is deﬁned in a precise mathematical, qualitative and compositional\nresolve important issues. The logical structure of the formal speciﬁcation, written\nas a formula in a suitable logic, typically serves as a guiding principle in trying\nto write an implementation in which it holds.\nr Time-to-market: Debugging big systems during the testing phase is costly and\ntime-consuming and local ‘ﬁxes’ often introduce new bugs at other places. Ex-\nperience has shown that verifying programs with respect to formal speciﬁcations\ncan signiﬁcantly cut down the duration of software development and maintenance\nby eliminating most errors in the planning phase and helping in the clariﬁcation\nof the roles and structural aspects of system components.\nr Refactoring: Properly speciﬁed and veriﬁed software is easier to reuse, since\nwe have a clear speciﬁcation of what it is meant to do.\nr Certiﬁcation audits: Safety-critical computer systems – such as the control\nof cooling systems in nuclear power stations, or cockpits of modern aircrafts –\ndemand that their software be speciﬁed and veriﬁed with as much rigour and\nformality as possible. Other programs may be commercially critical, such as ac-\ncountancy software used by banks, and they should be delivered with a warranty:\na guarantee for correct performance within proper use. The proof that a program\nmeets its speciﬁcations is indeed such a warranty.\n258\n4 Program verification\nThe degree to which the software industry accepts the beneﬁts of proper\nveriﬁcation of code depends on the perceived extra cost of producing it and\nthe perceived beneﬁts of having it. As veriﬁcation technology improves, the\ncosts are declining; and as the complexity of software and the extent to which\nsociety depends on it increase, the beneﬁts are becoming more important.\nThus, we can expect that the importance of veriﬁcation to industry will\ncontinue to increase over the next decades. Microsoft’s emergent technology\nA# combines program veriﬁcation, testing, and model-checking techniques\n1.\nit captures formally static and dynamic system structure and behaviour;\n2.\nit can verify consistency of the constrained design space;\n2.7 Micromodels of software\n149\n3.\nit is executable, so it allows guided simulations through a potentially very com-\nplex design space; and\n4.\nit can boost our conﬁdence into the correctness of claims about static and\ndynamic aspects of all its compliant implementations.\nMoreover, formal models attached to software products can be seen as a\nreliability contract; a promise that the software implements the structure and\nbehaviour of the model and is expected to meet all of the assertions certiﬁed\ntherein. (However, this may not be very useful for extremely under-speciﬁed\nmodels.)\nWe will model a software package dependency system. This system is used\nwhen software packages are installed or upgraded. The system checks to see\nif prerequisites in the form of libraries or other packages are present. The\nrequirements on a software package dependency system are not straightfor-\nward. As most computer users know, the upgrading process can go wrong\nin various ways. For example, upgrading a package can involve replacing\nshared libraries with newer versions. But other packages which rely on the\nolder versions of the shared libraries may then cease to work.\nSoftware package dependency systems are used in several computer sys-\ntems, such as Red Hat Linux, .NET’s Global Assembly Cache and others.\nUsers often have to guess how technical questions get resolved within the de-\npendency system. To the best of our knowledge, there is no publicly available\nformal and executable model of any particular dependency system to which\napplication programmers could turn if they had such non-trivial technical\nquestions about its inner workings.\nIn our model, applications are built out of components. Components oﬀer\nservices to other components. A service can be a number of things. Typically,\nanalyzer [JSS01] have been developed by D. Jackson and his Software\nDesign Group at the Laboratory for Computer Science at the Massachusetts\nInstitute of Technology. The tool has a dedicated repository website at\nalloy.mit.edu.\nMore information on typed higher-order logics and their use in the\nmodelling and verifying of programming frameworks can be found on F.\nPfenning’s course homepage7 on Computation and Deduction.\n7 www-2.cs.cmu.edu/~fp/courses/comp-ded/\n3\nVerification by model checking\n3.1 Motivation for verification\nThere is a great advantage in being able to verify the correctness of computer\nsystems, whether they are hardware, software, or a combination. This is most\nobvious in the case of safety-critical systems, but also applies to those that\nare commercially critical, such as mass-produced chips, mission critical, etc.\nFormal veriﬁcation methods have quite recently become usable by industry\nand there is a growing demand for professionals able to apply them. In this\nchapter, and the next one, we examine two applications of logics to the\nquestion of verifying the correctness of computer systems, or programs.\nFormal veriﬁcation techniques can be thought of as comprising three\nparts:\nr a framework for modelling systems, typically a description language of some sort;\nr a speciﬁcation language for describing the properties to be veriﬁed;\nr a veriﬁcation method to establish whether the description of a system satisﬁes\nthe speciﬁcation.\nApproaches to veriﬁcation can be classiﬁed according to the following\ncriteria:\nProof-based vs. model-based. In a proof-based approach, the system\ndescription is a set of formulas Γ (in a suitable logic) and the speciﬁcation\nis another formula φ. The veriﬁcation method consists of trying to ﬁnd\na proof that Γ |−φ. This typically requires guidance and expertise from\nthe user.\nIn a model-based approach, the system is represented by a model M for\nan appropriate logic. The speciﬁcation is again represented by a formula\nsmall scope hypothesis, 143\nSMV, 254\nmain program for ABP, 207\nmodule, 193\nreceiver, 205\nsender, 204\nfor channel, 206\ninstantiation, 193\nprocess, 389\nprogram\nexample, 192\nfor Mutex, 195\nspeciﬁcation, 192\nsoftware\nlife-cycle, 142\nmicromodel, 142\nreliability, 149\nrequirements, 142\nspeciﬁcation, 142\nvalidation, 142\nsoundness\nof forall-elimination, 109\nof natural deduction\nbasic modal logic, 354\npredicate logic, 96, 122\npropositional logic, 45\nof program logics, 267\nof proof rule for while-statements,\n282\nof the substitution principle, 108\n426\nIndex\nspeciﬁcation\nfor ABP, 207\nformal, 259\ninformal, 259\nlanguage, 172\nof a predicate, 157\npatterns, 254\npractical pattern, 183, 215\ntruth table, 58\nspeciﬁcations, 191\nSpin, 254\nstate\ncritical, 188\nexplosion, 229\nexplosion problem, 254\nfair, 397\nﬁnal, 142\nformula, 218\nglobal, 188\ngraph, 180\ninitial, 142, 189, 222, 247, 252, 264\nnon-critical, 188\nof a system, 269\nof core program, 264\nreachable, 247\nresulting, 263, 299\nspace, 229\nsplitting states, 190\ntransition, 142\ntrying, 188\nstate machine, 142\nstorage\nlocation, 288\nstate, 261\nstore\nof core program, 264\nstring, 247, 307\nbinary, 126, 132\nempty, 126\nstrongly connected component, 225\nstructural equality, 153\nstructural induction, 44, 51\nsubformula, 178\nsubstitution\nin predicate logic, 105\ninstance, 323\ninstance of tautology, 314\nprinciple, 108\nsymbolic model checking, 383\nsyntactic\ndomain, 260, 261\nsyntax\nof basic modal logic, 307\nof boolean expressions, 261\nof boolean formulas, 398\nof CTL, 208\nof CTL*, 218\nof KT45n, 335\nof LTL, 175\nof predicate logic, 100\nof propositional logic, 33\nof relational mu-calculus, 390\nof terms, 99\nsystem\nasynchronous, 254\ninterleaving model, 389\nsimultaneous model, 389\naxiomatic, 91\ncommercially critical, 172, 257\ncomponent, 206\nconcurrent, 173\ndebugging, 174\ndescription, 193\ndesign, 174\ndevelopment, 173\nelevator, 184, 215\nﬁnite-state, 256\nhybrid, 277\ninﬁnite-state, 256\nmission-critical, 172\nmulti-agent, 331\nphysical, 175\nreactive, 173, 257, 358",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-4",
                            "title": "Important Equivalences Between CTL Formulas",
                            "content": "all paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nConvention 3.13 We assume similar binding priorities for the CTL con-\nnectives to what we did for propositional and predicate logic. The unary\nconnectives (consisting of ¬ and the temporal connectives AG, EG, AF, EF,\nAX and EX) bind most tightly. Next in the order come ∧and ∨; and after\nthat come →, AU and EU .\nNaturally, we can use brackets in order to override these priorities. Let\nus see some examples of well-formed CTL formulas and some examples\nwhich are not well-formed, in order to understand the syntax. Suppose\nthat p, q and r are atomic formulas. The following are well-formed CTL\nformulas:\nr AG (q →EG r), note that this is not the same as AG q →EG r, for according to\nConvention 3.13, the latter formula means (AG q) →(EG r)\nr EF E[r U q]\nr A[p U EF r]\nr EF EG p →AF r, again, note that this binds as (EF EG p) →AF r, not\nEF (EG p →AF r) or EF EG (p →AF r)\nr A[p1 U A[p2 U p3]]\nr E[A[p1 U p2] U p3]\nr AG (p →A[p U (¬p ∧A[¬p U q])]).\nIt is worth spending some time seeing how the syntax rules allow us to\nconstruct each of these. The following are not well-formed formulas:\nr EF G r\nr A¬G ¬p\nr F [r U q]\nr EF (r U q)\nr AEF r\nr A[(r U q) ∧(p U r)].\nIt is especially worth understanding why the syntax rules don’t allow us to\nconstruct these. For example, take EF (r U q). The problem with this string\nis that U can occur only when paired with an A or an E. The E we have is\npaired with the F. To make this into a well-formed CTL formula, we would\nhave to write EF E[r U q] or EF A[r U q].\n210\n3 Verification by model checking\nAU\nEU\nAX\n¬\n¬\nEX\np\np\n∧\nq\np\nFigure 3.18. The parse tree of a CTL formula without infix notation.\nNotice that we use square brackets after the A or E, when the paired\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\n(b) (x1, x2, x3) ⇒(0, 1, 0).\n10. Prove\nTheorem 6.19 Given a coding for a ﬁnite CTL model, let φ be a CTL formula\nfrom an adequate fragment. Then [[φ]] corresponds to the set of valuations ρ such\nthat ρ ⊨f φ.\nby structural induction on φ. You may ﬁrst want to show that the evaluation of\nρ ⊨f φ depends only on the values ρ(xi), i.e. it does not matter what ρ assigns\nto x′\ni or Z.\n11. Argue that Theorem 6.19 above remains valid for arbitrary CTL formulas as\nlong as we translate formulas φ which are not in the adequate fragment into\nsemantically equivalent formulas ψ in that fragment and deﬁne f φ to be f ψ.\n12. Derive the formula f AF (¬x1∧x2) for the model in Figure 6.32(b) on page 407\nand evaluate it for the valuation corresponding to state s2 to determine whether\ns2 ⊨AF (¬x1 ∧x2) holds.\n13. Repeat the last exercise with f E[x1∨¬x2Ux1].\n14. Recall the way the two labelling algorithms operate in Chapter 3. Does our\nsymbolic coding mimic either or both of them, or neither?\nExercises 6.16\n1. Consider the equations in (6.22) and (6.27). The former deﬁnes fair in terms of\nf ECG⊤, whereas the latter deﬁnes f ECG φ for general φ. Why is this unproblem-\natic, i.e. non-circular?\n2. Given a ﬁxed CTL model M = (S, →, L), we saw how to code formulas f φ\nrepresenting the set of states s ∈S with s ⊨φ, φ being a CTL formula of an\nadequate fragment.\n(a) Assume the coding without consideration of simple fairness constraints. Use\nstructural induction on the CTL formula φ to show that\ni. the free variables of f φ are among ˆx, where the latter is the vector of\nboolean variables which code states s ∈S;\nii. all ﬁxed-point subformulas of f φ are formally monotone.\n412\n6 Binary decision diagrams\n(b) Show these two assertions if f φ also encodes simple fairness constraints.\n3. Consider the pseudo-code for the function SAT on page 227. We now want to\nmodify it so that the resulting output is not a set, or an OBDD, but a formula\nin plain English.\n3. Consider the set of LTL/CTL formulas F = {F p →F q, AF p →AF q, AG (p →\nAF q)}.\n(a) Is there a model such that all formulas hold in it?\n(b) For each φ ∈F, is there a model such that φ is the only formula in F satisﬁed\nin that model?\n(c) Find a model in which no formula of F holds.\n4. Consider the CTL formula AG (p →AF (s ∧AX (AF t))). Explain what exactly\nit expresses in terms of the order of occurrence of events p, s and t.\n5. Extend the algorithm NNF from page 62 which computes the negation normal\nform of propositional logic formulas to CTL*. Since CTL* is deﬁned in terms\nof two syntactic categories (state formulas and path formulas), this requires two\nseparate versions of NNF which call each other in a way that is reﬂected by the\nsyntax of CTL* given on page 218.\n6. Find a transition system which distinguishes the following pairs of CTL* formu-\nlas, i.e., show that they are not equivalent:\n(a) AF G p and AF AG p\n(b)\n*\nAG F p and AG EF p\n(c) A[(p U r) ∨(q U r)] and A[(p ∨q) U r)]\n3.8 Exercises\n251\n(d)\n*\nA[X p ∨X X p] and AX p ∨AX AX p\n(e) E[G F p] and EG EF p.\n7. The translation from CTL with boolean combinations of path formulas to plain\nCTL introduced in Section 3.5.1 is not complete. Invent CTL equivalents for:\n(a)\n*\nE[F p ∧(q U r)]\n(b)\n*\nE[F p ∧G q].\nIn this way, we have dealt with all formulas of the form E[φ ∧ψ]. Formulas of the\nform E[φ ∨ψ] can be rewritten as E[φ] ∨E[ψ] and A[φ] can be written ¬E[¬φ].\nUse this translation to write the following in CTL:\n(c) E[(p U q) ∧F p]\n(d)\n*\nA[(p U q) ∧G p]\n(e)\n*\nA[F p →F q].\n8. The aim of this exercise is to demonstrate the expansion given for AW at the\nend of the last section, i.e., A[p W q] ≡¬E[¬q U ¬(p ∨q)].\n(a) Show that the following LTL formulas are valid (i.e., true in any state of any\nmodel):\n(i) ¬q U (¬p ∧¬q) →¬G p\n(ii) G ¬q ∧F ¬p →¬q U (¬p ∧¬q).\n(b) Expand ¬((p U q) ∨G p) using de Morgan rules and the LTL equivalence\n¬(φ U ψ) ≡(¬ψ U (¬φ ∧¬ψ)) ∨¬F ψ.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-5",
                            "title": "Adequate Sets of CTL Connectives",
                            "content": "U cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nConvention 3.13 We assume similar binding priorities for the CTL con-\nnectives to what we did for propositional and predicate logic. The unary\nconnectives (consisting of ¬ and the temporal connectives AG, EG, AF, EF,\nAX and EX) bind most tightly. Next in the order come ∧and ∨; and after\nthat come →, AU and EU .\nNaturally, we can use brackets in order to override these priorities. Let\nus see some examples of well-formed CTL formulas and some examples\nwhich are not well-formed, in order to understand the syntax. Suppose\nthat p, q and r are atomic formulas. The following are well-formed CTL\nformulas:\nr AG (q →EG r), note that this is not the same as AG q →EG r, for according to\nConvention 3.13, the latter formula means (AG q) →(EG r)\nr EF E[r U q]\nr A[p U EF r]\nr EF EG p →AF r, again, note that this binds as (EF EG p) →AF r, not\nEF (EG p →AF r) or EF EG (p →AF r)\nr A[p1 U A[p2 U p3]]\nr E[A[p1 U p2] U p3]\nr AG (p →A[p U (¬p ∧A[¬p U q])]).\nIt is worth spending some time seeing how the syntax rules allow us to\nconstruct each of these. The following are not well-formed formulas:\nr EF G r\nr A¬G ¬p\nr F [r U q]\nr EF (r U q)\nr AEF r\nr A[(r U q) ∧(p U r)].\nIt is especially worth understanding why the syntax rules don’t allow us to\nconstruct these. For example, take EF (r U q). The problem with this string\nis that U can occur only when paired with an A or an E. The E we have is\npaired with the F. To make this into a well-formed CTL formula, we would\nhave to write EF E[r U q] or EF A[r U q].\n210\n3 Verification by model checking\nAU\nEU\nAX\n¬\n¬\nEX\np\np\n∧\nq\np\nFigure 3.18. The parse tree of a CTL formula without infix notation.\nNotice that we use square brackets after the A or E, when the paired\nexist:\n¬AF φ ≡EG ¬φ\n¬EF φ ≡AG ¬φ\n(3.6)\n¬AX φ ≡EX ¬φ.\nWe also have the equivalences\nAF φ ≡A[⊤U φ]\nEF φ ≡E[⊤U φ]\nwhich are similar to the corresponding equivalences in LTL.\n3.4.5 Adequate sets of CTL connectives\nAs in propositional logic and in LTL, there is some redundancy among the\nCTL connectives. For example, the connective AX can be written ¬EX ¬;\nand AG, AF, EG and EF can be written in terms of AU and EU as follows:\nﬁrst, write AG φ as ¬EF ¬φ and EG φ as ¬AF ¬φ, using (3.6), and then use\nAF φ ≡A[⊤U φ] and EF φ ≡E[⊤U φ]. Therefore AU, EU and EX form\nan adequate set of temporal connectives.\nAlso EG, EU, and EX form an adequate set, for we have the equivalence\nA[φ U ψ] ≡¬(E[¬ψ U (¬φ ∧¬ψ)] ∨EG ¬ψ)\n(3.7)\nwhich can be proved as follows:\nA[φ U ψ] ≡A[¬(¬ψ U (¬φ ∧¬ψ)) ∧F ψ]\n≡¬E¬[¬(¬ψ U (¬φ ∧¬ψ)) ∧F ψ]\n≡¬E[(¬ψ U (¬φ ∧¬ψ)) ∨G ¬ψ]\n≡¬(E[¬ψ U (¬φ ∧¬ψ)] ∨EG ¬ψ).\nThe ﬁrst line is by Theorem 3.10, and the remainder by elementary manipu-\nlation. (This proof involves intermediate formulas which violate the syntactic\nformation rules of CTL; however, it is valid in the logic CTL* introduced in\nthe next section.) More generally, we have:\nTheorem 3.17 A set of temporal connectives in CTL is adequate if, and\nonly if, it contains at least one of {AX , EX }, at least one of {EG , AF , AU }\nand EU .\n3.5 CTL* and the expressive powers of LTL and CTL\n217\nThis theorem is proved in a paper referenced in the bibliographic notes\nat the end of the chapter. The connective EU plays a special role in that\ntheorem because neither weak-until W nor release R are primitive in CTL\n(Deﬁnition 3.12). The temporal connectives AR, ER, AW and EW are all\ndeﬁnable in CTL:\nr A[φ R ψ] = ¬E[¬φ U ¬ψ]\nr E[φ R ψ] = ¬A[¬φ U ¬ψ]\nr A[φ W ψ] = A[ψ R (φ ∨ψ)], and then use the ﬁrst equation above\nr E[φ W ψ] = E[ψ R (φ ∨ψ)], and then use the second one.\nThese deﬁnitions are justiﬁed by LTL equivalences in Sections 3.2.4\nand 3.2.5. Some other noteworthy equivalences in CTL are the following:\nAG φ ≡φ ∧AX AG φ\n∧form an adequate set as far as the propositional connectives are concerned;\nand AF , EU and EX form an adequate set of temporal connectives. Given\nan arbitrary CTL formula φ, we would simply pre-process φ in order to write\nit in an equivalent form in terms of the adequate set of connectives, and then\n3.6 Model-checking algorithms\n223\nRepeat. . .\nAFψ1\nAFψ1\nAFψ1\nAFψ1\nAFψ1\nAFψ1\nAFψ1\n. . . until no change.\nFigure 3.24. The iteration step of the procedure for labelling states with\nsubformulas of the form AF ψ1.\ncall the model-checking algorithm. Here is the algorithm:\nINPUT: a CTL model M = (S, →, L) and a CTL formula φ.\nOUTPUT: the set of states of M which satisfy φ.\nFirst, change φ to the output of TRANSLATE (φ), i.e., we write φ in terms\nof the connectives AF, EU, EX, ∧, ¬ and ⊥using the equivalences given\nearlier in the chapter. Next, label the states of M with the subformulas of φ\nthat are satisﬁed there, starting with the smallest subformulas and working\noutwards towards φ.\nSuppose ψ is a subformula of φ and states satisfying all the immediate\nsubformulas of ψ have already been labelled. We determine by a case analysis\nwhich states to label with ψ. If ψ is\nr ⊥: then no states are labelled with ⊥.\nr p: then label s with p if p ∈L(s).\nr ψ1 ∧ψ2: label s with ψ1 ∧ψ2 if s is already labelled both with ψ1 and with ψ2.\nr ¬ψ1: label s with ¬ψ1 if s is not already labelled with ψ1.\nr AF ψ1:\n– If any state s is labelled with ψ1, label it with AF ψ1.\n– Repeat: label any state with AF ψ1 if all successor states are labelled with\nAF ψ1, until there is no change. This step is illustrated in Figure 3.24.\nr E[ψ1 U ψ2]:\n– If any state s is labelled with ψ2, label it with E[ψ1 U ψ2].\n– Repeat: label any state with E[ψ1 U ψ2] if it is labelled with ψ1 and at least\none of its successors is labelled with E[ψ1 U ψ2], until there is no change. This\nstep is illustrated in Figure 3.25.\nr EX ψ1: label any state with EX ψ1 if one of its successors is labelled with ψ1.\n224\nall paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nhow SMV could use fairness assumptions which were not expressible entirely\n5 Since we have added the variable u, there are actually six states; they all satisfy the formula.\n6.4 A relational mu-calculus\n397\nwithin CTL and its semantics. The addition of fairness could be achieved\nby restricting the ordinary CTL semantics to fair computation paths, or fair\nstates. Formally, we were given a set C = {ψ1, ψ2, . . . , ψk} of CTL formulas,\ncalled the fairness constraints, and we wanted to check whether s ⊨φ holds\nfor a CTL formula φ and all initial states s, with the additional fairness\nconstraints in C. Since ⊥, ¬, ∧, EX, EU and EG form an adequate set of\nconnectives for CTL, we may restrict this discussion to only these operators.\nClearly, the propositional connectives won’t change their meaning with the\naddition of fairness constraints. Therefore, it suﬃces to provide symbolic\ncodings for the fair connectives ECX, ECU and ECG from Chapter 3. The\nkey is to represent the set of fair states symbolically as a boolean formula\nfair deﬁned as\nfair\ndef\n= fECG⊤\n(6.22)\nwhich uses the (yet to be deﬁned) function fECG φ with ⊤as an instance.\nAssuming that the coding of fECG φ is correct, we see that fair computes 1\nin a state s if, and only if, there is a fair path with respect to C that begins\nin s. We say that such an s is a fair state.\nAs for ECX, note that s ⊨ECXφ if, and only if, there is some next state s′\nwith s →s′ and s′ ⊨φ such that s′ is a fair state. This immediately renders\nfECXφ def\n= ∃ˆx′.(f→· (fφ · fair)[ˆx := ˆx′]).\n(6.23)\nSimilarly, we obtain\nfEC[φ1Uφ2] def\n= µZ. (fφ2 · fair + fφ1 · ∃ˆx′. (f→· Z[ˆx := ˆx′])).\n(6.24)\nThis leaves us with the task of coding fECG φ. It is this last connective\nwhich reveals the complexity of fairness checks at work. Because the coding\nof fECG φ is rather complex, we proceed in steps. It is convenient to have the\nEX and EU functionality also at the level of boolean formulas directly. For",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-5",
                    "title": "CTL* and the Expressive Powers of LTL and CTL",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-5-subsection-1",
                            "title": "Boolean Combinations of Temporal Formulas in CTL",
                            "content": "The NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\nto write a procedure SATAU. Can you use that routine to handle all calls of the\nform AF φ as well?\n7. Prove that [[A[φ1 U φ2]]] = [[φ2 ∨(φ1 ∧AX (A[φ1 U φ2]))]].\n8. Prove that [[AG φ]] = [[φ ∧AX (AG φ)]].\n9. Show that the repeat-statements in the code for SATEU and SATEG always termi-\nnate. Use this fact to reason informally that the main program SAT terminates\nfor all valid CTL formulas φ. Note that some subclauses, like the one for AU,\ncall SAT recursively and with a more complex formula. Why does this not aﬀect\ntermination?\n254\n3 Verification by model checking\n3.9 Bibliographic notes\nTemporal logic was invented by the philosopher A. Prior in the 1960s; his\nlogic was similar to what we now call LTL. The ﬁrst use of temporal logic for\nreasoning about concurrent programs was by A. Pnueli [Pnu81]. The logic\nCTL was invented by E. Clarke and E. A. Emerson (during the early 1980s);\nand CTL* was invented by E. A. Emerson and J. Halpern (in 1986) to unify\nCTL and LTL.\nCTL model checking was invented by E. Clarke and E. A. Emerson [CE81]\nand by J. Quielle and J. Sifakis [QS81]. The technique we described for LTL\nmodel checking was invented by M. Vardi and P. Wolper [VW84]. Surveys\nof some of these ideas can be found in [CGL93] and [CGP99]. The theorem\nabout adequate sets of CTL connectives is proved in [Mar01].\nThe original SMV system was written by K. McMillan [McM93] and is\navailable with source code from Carnegie Mellon University6. NuSMV7 is a\nreimplementation, developed in Trento by A. Cimatti, and M. Roveri and is\naimed at being customisable and extensible. Extensive documentation about\nNuSMV can be found at that site. NuSMV supports essentially the same\nsystem description language as CMU SMV, but it has an improved user in-\nterface and a greater variety of algorithms. For example, whereas CMU SMV\nchecks only CTL speciﬁcation, NuSMV supports LTL and CTL. NuSMV im-\nplements bounded model checking [BCCZ99]. Cadence SMV8 is an entirely\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\nU cannot occur without being preceded by an A or an E; similarly, every A\nor E must have one of X, F, G and U to accompany it.\nUsually weak-until (W) and release (R) are not included in CTL, but they\nare derivable (see Section 3.4.5).\nConvention 3.13 We assume similar binding priorities for the CTL con-\nnectives to what we did for propositional and predicate logic. The unary\nconnectives (consisting of ¬ and the temporal connectives AG, EG, AF, EF,\nAX and EX) bind most tightly. Next in the order come ∧and ∨; and after\nthat come →, AU and EU .\nNaturally, we can use brackets in order to override these priorities. Let\nus see some examples of well-formed CTL formulas and some examples\nwhich are not well-formed, in order to understand the syntax. Suppose\nthat p, q and r are atomic formulas. The following are well-formed CTL\nformulas:\nr AG (q →EG r), note that this is not the same as AG q →EG r, for according to\nConvention 3.13, the latter formula means (AG q) →(EG r)\nr EF E[r U q]\nr A[p U EF r]\nr EF EG p →AF r, again, note that this binds as (EF EG p) →AF r, not\nEF (EG p →AF r) or EF EG (p →AF r)\nr A[p1 U A[p2 U p3]]\nr E[A[p1 U p2] U p3]\nr AG (p →A[p U (¬p ∧A[¬p U q])]).\nIt is worth spending some time seeing how the syntax rules allow us to\nconstruct each of these. The following are not well-formed formulas:\nr EF G r\nr A¬G ¬p\nr F [r U q]\nr EF (r U q)\nr AEF r\nr A[(r U q) ∧(p U r)].\nIt is especially worth understanding why the syntax rules don’t allow us to\nconstruct these. For example, take EF (r U q). The problem with this string\nis that U can occur only when paired with an A or an E. The E we have is\npaired with the F. To make this into a well-formed CTL formula, we would\nhave to write EF E[r U q] or EF A[r U q].\n210\n3 Verification by model checking\nAU\nEU\nAX\n¬\n¬\nEX\np\np\n∧\nq\np\nFigure 3.18. The parse tree of a CTL formula without infix notation.\nNotice that we use square brackets after the A or E, when the paired\n218\n3 Verification by model checking\nsomething quite diﬀerent: it says ‘if all paths have a p along them, then\nall paths have a q along them.’ One might write AG (p →AF q), which is\ncloser, since it says that every way of extending every path to a p eventually\nmeets a q, but that is still not capturing the meaning of F p →F q.\nCTL* is a logic which combines the expressive powers of LTL and CTL,\nby dropping the CTL constraint that every temporal operator (X, U, F, G)\nhas to be associated with a unique path quantiﬁer (A, E). It allows us to\nwrite formulas such as\nr A[(p U r) ∨(q U r)]: along all paths, either p is true until r, or q is true until r.\nr A[X p ∨X X p]: along all paths, p is true in the next state, or the next but one.\nr E[G F p]: there is a path along which p is inﬁnitely often true.\nThese formulas are not equivalent to, respectively, A[(p ∨q) U r)], AX p ∨\nAX AX p and EG EF p. It turns out that the ﬁrst of them can be written\nas a (rather long) CTL formula. The second and third do not have a CTL\nequivalent.\nThe syntax of CTL* involves two classes of formulas:\nr state formulas, which are evaluated in states:\nφ ::= ⊤| p | (¬φ) | (φ ∧φ) | A[α] | E[α]\nwhere p is any atomic formula and α any path formula; and\nr path formulas, which are evaluated along paths:\nα ::= φ | (¬α) | (α ∧α) | (α U α) | (G α) | (F α) | (X α)\nwhere φ is any state formula. This is an example of an inductive deﬁnition\nwhich is mutually recursive: the deﬁnition of each class depends upon the\ndeﬁnition of the other, with base cases p and ⊤.\nLTL and CTL as subsets of CTL*\nAlthough the syntax of LTL does\nnot include A and E, the semantic viewpoint of LTL is that we consider\nall paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-5-subsection-2",
                            "title": "Past Operators in LTL",
                            "content": "the example formula may be written G (q →O p).\nNuSMV supports past operators in LTL. One could also add past opera-\ntors to CTL (AY, ES, etc.) but NuSMV does not support them.\nSomewhat counter-intuitively, past operators do not increase the expres-\nsive power of LTL. That is to say, every LTL formula with past operators\ncan be written equivalently without them. The example formula above can\nbe written ¬p W q, or equivalently ¬(¬q U (p ∧¬q)) if one wants to avoid\nW. This result is surprising, because it seems that being able to talk about\nthe past as well as the future allows more expressivity than talking about\nthe future alone. However, recall that LTL equivalence is quite crude: it says\nthat the two formulas are satisﬁed by exactly the same set of paths. The\npast operators allow us to travel backwards along the path, but only to reach\npoints we could have reached by travelling forwards from its beginning. In\ncontrast, adding past operators to CTL does increase its expressive power,\nbecause they can allow us to examine states not forward-reachable from the\npresent one.\n3.6 Model-checking algorithms\nThe semantic deﬁnitions for LTL and CTL presented in Sections 3.2 and 3.4\nallow us to test whether the initial states of a given system satisfy an LTL or\nCTL formula. This is the basic model-checking question. In general, inter-\nesting transition systems will have a huge number of states and the formula\n222\n3 Verification by model checking\nwe are interested in checking may be quite long. It is therefore well worth\ntrying to ﬁnd eﬃcient algorithms.\nAlthough LTL is generally preferred by speciﬁers, as already noted, we\nstart with CTL model checking because its algorithm is simpler.\n3.6.1 The CTL model-checking algorithm\nHumans may ﬁnd it easier to do model checks on the unwindings of models\ninto inﬁnite trees, given a designated initial state, for then all possible paths\nare plainly visible. However, if we think of implementing a model checker\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nconverted into CTL formulas by adding an A to each temporal operator. For\n220\n3 Verification by model checking\na positive example, the LTL formula G (p →F q) is equivalent to the CTL\nformula AG (p →AF q). We discuss two more negative examples:\nr F G p and AF AG p are not equivalent, since F G p is satisﬁed, whereas AF AG p\nis not satisﬁed, in the model\np\n¬p\np\nIn fact, AF AG p is strictly stronger than F G p.\nr While the LTL formulas X F p and F X p are equivalent, and they are equivalent\nto the CTL formula AX AF p, they are not equivalent to AF AX p. The latter\nis strictly stronger, and has quite a strange meaning (try working it out).\nRemark 3.19 There is a considerable literature comparing linear-time and\nbranching-time logics. The question of which one is ‘better’ has been debated\nfor about 20 years. We have seen that they have incomparable expressive\npowers. CTL* is more expressive than either of them, but is computationally\nmuch more expensive (as will be seen in Section 3.6). The choice between\nLTL and CTL depends on the application at hand, and on personal prefer-\nence. LTL lacks CTL’s ability to quantify over paths, and CTL lacks LTL’s\nﬁner-grained ability to describe individual paths. To many people, LTL ap-\npears to be more straightforward to use; as noted above, CTL formulas like\nAF AX p seem hard to understand.\n3.5.1 Boolean combinations of temporal formulas in CTL\nCompared with CTL*, the syntax of CTL is restricted in two ways: it does\nnot allow boolean combinations of path formulas and it does not allow nest-\ning of the path modalities X, F and G. Indeed, we have already seen exam-\nples of the inexpressibility in CTL of nesting of path modalities, namely the\nformulas ψ3 and ψ4 above.\nall paths. Therefore, the LTL formula α is equivalent to the CTL* formula\nA[α]. Thus, LTL can be viewed as a subset of CTL*.\nCTL is also a subset of CTL*, since it is the fragment of CTL* in which\nwe restrict the form of path formulas to\nα ::= (φ U φ) | (G φ) | (F φ) | (X φ)\nFigure 3.23 shows the relationship among the expressive powers of CTL,\nLTL and CTL*. Here are some examples of formulas in each of the subsets\n3.5 CTL* and the expressive powers of LTL and CTL\n219\nLTL\nψ1\nψ2\nψ3\nψ4\nCTL\nCTL*\nFigure 3.23. The expressive powers of CTL, LTL and CTL*.\nshown:\nIn CTL but not in LTL: ψ1\ndef\n= AG EF p. This expresses: wherever we\nhave got to, we can always get to a state in which p is true. This is\nalso useful, e.g., in ﬁnding deadlocks in protocols.\nThe proof that AG EF p is not expressible in LTL is as follows. Let φ be\nan LTL formula such that A[φ] is allegedly equivalent to AG EF p. Since\nM, s ⊨AG EF p in the left-hand diagram below, we have M, s ⊨A[φ].\nNow let M′ be as shown in the right-hand diagram. The paths from s\nin M′ are a subset of those from s in M, so we have M′, s ⊨A[φ]. Yet,\nit is not the case that M′, s ⊨AG EF p; a contradiction.\n¬p\n¬p\np\ns\ns\nt\nIn CTL*, but neither in CTL nor in LTL: ψ4\ndef\n= E[G F p],\nsaying\nthat\nthere is a path with inﬁnitely many p.\nThe proof that this is not expressible in CTL is quite complex and may\nbe found in the papers co-authored by E. A. Emerson with others, given\nin the references. (Why is it not expressible in LTL?)\nIn LTL but not in CTL: ψ3\ndef\n= A[G F p →F q], saying that if there are in-\nﬁnitely many p along the path, then there is an occurrence of q. This\nis an interesting thing to be able to say; for example, many fairness\nconstraints are of the form ‘inﬁnitely often requested implies eventually\nacknowledged’.\nIn LTL and CTL: ψ2\ndef\n= AG (p →AF q) in CTL, or G (p →F q) in LTL:\nany p is eventually followed by a q.\nRemark 3.18 We just saw that some (but not all) LTL formulas can be\nLTL in which the future excludes the present. A consequence of adopting\nthe convention that the future shall include the present is that the formulas\nG p →p, p →q U p and p →F p are true in every state of every model.\nSo far we have deﬁned a satisfaction relation between paths and LTL for-\nmulas. However, to verify systems, we would like to say that a model as\na whole satisﬁes an LTL formula. This is deﬁned to hold whenever every\npossible execution path of the model satisﬁes the formula.\nDeﬁnition 3.8 Suppose M = (S, →, L) is a model, s ∈S, and φ an LTL\nformula. We write M, s ⊨φ if, for every execution path π of M starting at\ns, we have π ⊨φ.\nIf M is clear from the context, we may abbreviate M, s ⊨φ by s ⊨φ.\nIt should be clear that we have outlined the formal foundations of a pro-\ncedure that, given φ, M and s, can check whether M, s ⊨φ holds. Later\nin this chapter, we will examine algorithms which implement this calcula-\ntion. Let us now look at some example checks for the system in Figures 3.3\nand 3.5.\n1.\nM, s0 ⊨p ∧q holds since the atomic symbols p and q are contained in the node\nof s0: π ⊨p ∧q for every path π beginning in s0.\n3.2 Linear-time temporal logic\n183\n2.\nM, s0 ⊨¬r holds since the atomic symbol r is not contained in node s0.\n3.\nM, s0 ⊨⊤holds by deﬁnition.\n4.\nM, s0 ⊨X r holds since all paths from s0 have either s1 or s2 as their next\nstate, and each of those states satisﬁes r.\n5.\nM, s0 ⊨X (q ∧r) does not hold since we have the rightmost computation path\ns0 →s2 →s2 →s2 →. . . in Figure 3.5, whose second node s2 contains r, but\nnot q.\n6.\nM, s0 ⊨G ¬(p ∧r) holds since all computation paths beginning in s0 satisfy\nG ¬(p ∧r), i.e. they satisfy ¬(p ∧r) in each state along the path. Notice that\nG φ holds in a state if, and only if, φ holds in all states reachable from the\ngiven state.\n7.\nFor similar reasons, M, s2 ⊨G r holds (note the s2 instead of s0).\n8.\nFor any state s of M, we have M, s ⊨F (¬q ∧r) →F G r. This says that if\nthat φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-6",
                    "title": "Model-Checking Algorithms",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-6-subsection-1",
                            "title": "The CTL Model-Checking Algorithm",
                            "content": "3.6.1 The CTL model-checking algorithm\nHumans may ﬁnd it easier to do model checks on the unwindings of models\ninto inﬁnite trees, given a designated initial state, for then all possible paths\nare plainly visible. However, if we think of implementing a model checker\non a computer, we certainly cannot unwind transition systems into inﬁ-\nnite trees. We need to do checks on ﬁnite data structures. For this reason,\nwe now have to develop new insights into the semantics of CTL. Such a\ndeeper understanding will provide the basis for an eﬃcient algorithm which,\ngiven M, s ∈S and φ, computes whether M, s ⊨φ holds. In the case that\nφ is not satisﬁed, such an algorithm can be augmented to produce an ac-\ntual path (= run) of the system demonstrating that M cannot satisfy φ.\nThat way, we may debug a system by trying to ﬁx what enables runs which\nrefute φ.\nThere are various ways in which one could consider\nM, s0\n?\n⊨φ\nas a computational problem. For example, one could have the model M, the\nformula φ and a state s0 as input; one would then expect a reply of the form\n‘yes’ (M, s0 ⊨φ holds), or ‘no’ (M, s0 ⊨φ does not hold). Alternatively, the\ninputs could be just M and φ, where the output would be all states s of the\nmodel M which satisfy φ.\nIt turns out that it is easier to provide an algorithm for solving the second\nof these two problems. This automatically gives us a solution to the ﬁrst one,\nsince we can simply check whether s0 is an element of the output set.\nThe labelling algorithm\nWe present an algorithm which, given a model\nand a CTL formula, outputs the set of states of the model that satisfy the\nformula. The algorithm does not need to be able to handle every CTL con-\nnective explicitly, since we have already seen that the connectives ⊥, ¬ and\n∧form an adequate set as far as the propositional connectives are concerned;\nand AF , EU and EX form an adequate set of temporal connectives. Given\nan arbitrary CTL formula φ, we would simply pre-process φ in order to write\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\nIt is possible to implement the check for such a path in terms of CTL\nmodel checking, and this is in fact what NuSMV does. The combined system\nM × A¬φ is represented as the system to be model checked in NuSMV,\nand the formula to be checked is simply EG ⊤. Thus, we ask the question:\ndoes the combined system have a path. The acceptance conditions of A¬φ\nare represented as implicit fairness conditions for the CTL model-checking\nprocedure. Explicitly, this amounts to asserting ‘FAIRNESS ¬(χ U ψ) ∨ψ’\nfor each formula χ U ψ occurring in C(φ).\n3.7 The fixed-point characterisation of CTL\nOn page 227, we presented an algorithm which, given a CTL formula φ and\na model M = (S, →, L), computes the set of states s ∈S satisfying φ. We\nwrite this set as [[φ]]. The algorithm works recursively on the structure of\nφ. For formulas φ of height 1 (⊥, ⊤or p), [[φ]] is computed directly. Other\n3.7 The fixed-point characterisation of CTL\n239\nformulas are composed of smaller subformulas combined by a connective of\nCTL. For example, if φ is ψ1 ∨ψ2, then the algorithm computes the sets\n[[ψ1]] and [[ψ2]] and combines them in a certain way (in this case, by taking\nthe union) in order to obtain [[ψ1 ∨ψ2]].\nThe more interesting cases arise when we deal with a formula such as\nEX ψ, involving a temporal operator. The algorithm computes the set [[ψ]]\nand then computes the set of all states which have a transition to a state in\n[[ψ]]. This is in accord with the semantics of EX ψ: M, s ⊨EX ψ iﬀthere is\na state s′ with s →s′ and M, s′ ⊨ψ.\nFor most of these logical operators, we may easily continue this discussion\nto see that the algorithms work just as expected. However, the cases EU,\nAF and EG (where we needed to iterate a certain labelling policy until it\nstabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\nveriﬁcation in the early 1990s, because they have allowed systems with much\nlarger state spaces to be veriﬁed. In this section, we describe in detail how\nthe model-checking algorithm presented in Chapter 3 can be implemented\nusing OBDDs as the basic data structure.\nThe pseudo-code presented in Figure 3.28 on page 227 takes as input a\nCTL formula φ and returns the set of states of the given model which satisfy\nφ. Inspection of the code shows that the algorithm consists of manipulating\nintermediate sets of states. We show in this section how the model and the\nintermediate sets of states can be stored as OBDDs; and how the operations\nrequired in that pseudo-code can be implemented in terms of the operations\non OBDDs which we have seen in this chapter.\nWe start by showing how sets of states are represented with OBDDs,\ntogether with some of the operations required. Then, we extend that to\nthe representation of the transition system; and ﬁnally, we show how the\nremainder of the required operations is implemented.\n6.3 Symbolic model checking\n383\nModel checking using OBDDs is called symbolic model checking. The term\nemphasises that individual states are not represented; rather, sets of states\nare represented symbolically, namely, those which satisfy the formula being\nchecked.\n6.3.1 Representing subsets of the set of states\nLet S be a ﬁnite set (we forget for the moment that it is a set of states). The\ntask is to represent the various subsets of S as OBDDs. Since OBDDs encode\nboolean functions, we need somehow to code the elements of S as boolean\nvalues. The way to do this in general is to assign to each element s ∈S a\nunique vector of boolean values (v1, v2, . . . , vn), each vi ∈{0, 1}. Then, we\nrepresent a subset T by the boolean function fT which maps (v1, v2, . . . , vn)\nonto 1 if s ∈T and maps it onto 0 otherwise.\nThere are 2n boolean vectors (v1, v2, . . . , vn) of length n. Therefore, n\nshould be chosen such that 2n−1 < |S| ≤2n, where |S| is the number of\nthat φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-6-subsection-2",
                            "title": "CTL Model Checking with Fairness",
                            "content": "It is possible to implement the check for such a path in terms of CTL\nmodel checking, and this is in fact what NuSMV does. The combined system\nM × A¬φ is represented as the system to be model checked in NuSMV,\nand the formula to be checked is simply EG ⊤. Thus, we ask the question:\ndoes the combined system have a path. The acceptance conditions of A¬φ\nare represented as implicit fairness conditions for the CTL model-checking\nprocedure. Explicitly, this amounts to asserting ‘FAIRNESS ¬(χ U ψ) ∨ψ’\nfor each formula χ U ψ occurring in C(φ).\n3.7 The fixed-point characterisation of CTL\nOn page 227, we presented an algorithm which, given a CTL formula φ and\na model M = (S, →, L), computes the set of states s ∈S satisfying φ. We\nwrite this set as [[φ]]. The algorithm works recursively on the structure of\nφ. For formulas φ of height 1 (⊥, ⊤or p), [[φ]] is computed directly. Other\n3.7 The fixed-point characterisation of CTL\n239\nformulas are composed of smaller subformulas combined by a connective of\nCTL. For example, if φ is ψ1 ∨ψ2, then the algorithm computes the sets\n[[ψ1]] and [[ψ2]] and combines them in a certain way (in this case, by taking\nthe union) in order to obtain [[ψ1 ∨ψ2]].\nThe more interesting cases arise when we deal with a formula such as\nEX ψ, involving a temporal operator. The algorithm computes the set [[ψ]]\nand then computes the set of all states which have a transition to a state in\n[[ψ]]. This is in accord with the semantics of EX ψ: M, s ⊨EX ψ iﬀthere is\na state s′ with s →s′ and M, s′ ⊨ψ.\nFor most of these logical operators, we may easily continue this discussion\nto see that the algorithms work just as expected. However, the cases EU,\nAF and EG (where we needed to iterate a certain labelling policy until it\nstabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\ncall such paths fair computation paths. The presence of fairness constraints\nmeans that, when evaluating the truth of CTL formulas in speciﬁcations,\nthe connectives A and E range only over fair paths.\n3.6 Model-checking algorithms\n231\nWe therefore impose the fairness constraint that !st=c be true inﬁnitely\noften. This means that, whatever state the process is in, there will be a\nstate in the future in which it is not in its critical section. Similar fairness\nconstraints were used for the Alternating Bit Protocol.\nFairness constraints of the form (where φ is a state formula)\nProperty φ is true inﬁnitely often\nare known as simple fairness constraints. Other types include those of the\nform\nIf φ is true inﬁnitely often, then ψ is also true inﬁnitely often.\nSMV can deal only with simple fairness constraints; but how does it do\nthat? To answer that, we now explain how we may adapt our model-checking\nalgorithm so that A and E are assumed to range only over fair computation\npaths.\nDeﬁnition 3.21 Let C\ndef\n= {ψ1, ψ2, . . . , ψn} be a set of n fairness constraints.\nA computation path s0 →s1 →. . . is fair with respect to these fairness\nconstraints iﬀfor each i there are inﬁnitely many j such that sj ⊨ψi, that\nis, each ψi is true inﬁnitely often along the path. Let us write AC and EC\nfor the operators A and E restricted to fair paths.\nFor example, M, s0 ⊨ACG φ iﬀφ is true in every state along all fair paths;\nand similarly for ACF, ACU, etc. Notice that these operators explicitly de-\npend on the chosen set C of fairness constraints. We already know that ECU,\nECG and ECX form an adequate set; this can be shown in the same man-\nner as was done for the temporal connectives without fairness constraints\n(Section 3.4.4). We also have that\nEC[φ U ψ] ≡E[φ U (ψ ∧ECG ⊤)]\nECX φ ≡EX (φ ∧ECG ⊤).\nTo see this, observe that a computation path is fair iﬀany suﬃx of it is\nfair. Therefore, we need only provide an algorithm for ECG φ. It is similar\nthat φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\n3.6.1 The CTL model-checking algorithm\nHumans may ﬁnd it easier to do model checks on the unwindings of models\ninto inﬁnite trees, given a designated initial state, for then all possible paths\nare plainly visible. However, if we think of implementing a model checker\non a computer, we certainly cannot unwind transition systems into inﬁ-\nnite trees. We need to do checks on ﬁnite data structures. For this reason,\nwe now have to develop new insights into the semantics of CTL. Such a\ndeeper understanding will provide the basis for an eﬃcient algorithm which,\ngiven M, s ∈S and φ, computes whether M, s ⊨φ holds. In the case that\nφ is not satisﬁed, such an algorithm can be augmented to produce an ac-\ntual path (= run) of the system demonstrating that M cannot satisfy φ.\nThat way, we may debug a system by trying to ﬁx what enables runs which\nrefute φ.\nThere are various ways in which one could consider\nM, s0\n?\n⊨φ\nas a computational problem. For example, one could have the model M, the\nformula φ and a state s0 as input; one would then expect a reply of the form\n‘yes’ (M, s0 ⊨φ holds), or ‘no’ (M, s0 ⊨φ does not hold). Alternatively, the\ninputs could be just M and φ, where the output would be all states s of the\nmodel M which satisfy φ.\nIt turns out that it is easier to provide an algorithm for solving the second\nof these two problems. This automatically gives us a solution to the ﬁrst one,\nsince we can simply check whether s0 is an element of the output set.\nThe labelling algorithm\nWe present an algorithm which, given a model\nand a CTL formula, outputs the set of states of the model that satisfy the\nformula. The algorithm does not need to be able to handle every CTL con-\nnective explicitly, since we have already seen that the connectives ⊥, ¬ and\n∧form an adequate set as far as the propositional connectives are concerned;\nand AF , EU and EX form an adequate set of temporal connectives. Given\nan arbitrary CTL formula φ, we would simply pre-process φ in order to write",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-6-subsection-3",
                            "title": "The LTL Model-Checking Algorithm",
                            "content": "that φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.\nThe NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\nquite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nThe subformulas of p W (q U r), e.g., are p, q, r, q U r and p W (q U r).\n3.2.2 Semantics of LTL\nThe kinds of systems we are interested in verifying using LTL may be\nmodelled as transition systems. A transition system models a system by\nmeans of states (static structure) and transitions (dynamic structure). More\nformally:\nDeﬁnition 3.4 A transition system M = (S, →, L) is a set of states S\nendowed with a transition relation\n→(a binary relation on S), such\nthat every s ∈S has some s′ ∈S with s →s′, and a labelling function\nL: S →P(Atoms).\nTransition systems are also simply called models in this chapter. So a model\nhas a collection of states S, a relation →, saying how the system can move\nfrom state to state, and, associated with each state s, one has the set of\natomic propositions L(s) which are true at that particular state. We write\nP(Atoms) for the power set of Atoms, a collection of atomic descriptions.\nFor example, the power set of {p, q} is {∅, {p}, {q}, {p, q}}. A good way of\nthinking about L is that it is just an assignment of truth values to all the\npropositional atoms, as it was the case for propositional logic (we called\nthat a valuation). The diﬀerence now is that we have more than one state,\nso this assignment depends on which state s the system is in: L(s) contains\nall atoms which are true in state s.\nWe may conveniently express all the information about a (ﬁnite) tran-\nsition system M using directed graphs whose nodes (which we call states)\ncontain all propositional atoms that are true in that state. For example, if\nour system has only three states s0, s1 and s2; if the only possible transi-\ntions between states are s0 →s1, s0 →s2, s1 →s0, s1 →s2 and s2 →s2;\nLiveness: Messages get through eventually. Thus, for any state there is\ninevitably a future state in which the current message has got through. In\nthe module sender, we speciﬁed G F st=sent. (This speciﬁcation could\nequivalently have been written in the main module, as G F S.st=sent.)\nSimilarly, acknowledgements get through eventually. In the module\nreceiver, we write G F st=received.\n3.4 Branching-time logic\nIn our analysis of LTL (linear-time temporal logic) in the preceding sections,\nwe noted that LTL formulas are evaluated on paths. We deﬁned that a state\nof a system satisﬁes an LTL formula if all paths from the given state satisfy\nit. Thus, LTL implicitly quantiﬁes universally over paths. Therefore, prop-\nerties which assert the existence of a path cannot be expressed in LTL. This\nproblem can partly be alleviated by considering the negation of the property\nin question, and interpreting the result accordingly. To check whether there\n208\n3 Verification by model checking\nexists a path from s satisfying the LTL formula φ, we check whether all paths\nsatisfy ¬φ; a positive answer to this is a negative answer to our original ques-\ntion, and vice versa. We used this approach when analysing the ferryman\npuzzle in the previous section. However, as already noted, properties which\nmix universal and existential path quantiﬁers cannot in general be model\nchecked using this approach, because the complement formula still has a mix.\nBranching-time logics solve this problem by allowing us to quantify ex-\nplicitly over paths. We will examine a logic known as Computation Tree\nLogic, or CTL. In CTL, as well as the temporal operators U, F, G and X of\nLTL we also have quantiﬁers A and E which express ‘all paths’ and ‘exists\na path’, respectively. For example, we can write:\nr There is a reachable state satisfying q: this is written EF q.\nr From all reachable states satisfying p, it is possible to maintain p continuously\n3.6.1 The CTL model-checking algorithm\nHumans may ﬁnd it easier to do model checks on the unwindings of models\ninto inﬁnite trees, given a designated initial state, for then all possible paths\nare plainly visible. However, if we think of implementing a model checker\non a computer, we certainly cannot unwind transition systems into inﬁ-\nnite trees. We need to do checks on ﬁnite data structures. For this reason,\nwe now have to develop new insights into the semantics of CTL. Such a\ndeeper understanding will provide the basis for an eﬃcient algorithm which,\ngiven M, s ∈S and φ, computes whether M, s ⊨φ holds. In the case that\nφ is not satisﬁed, such an algorithm can be augmented to produce an ac-\ntual path (= run) of the system demonstrating that M cannot satisfy φ.\nThat way, we may debug a system by trying to ﬁx what enables runs which\nrefute φ.\nThere are various ways in which one could consider\nM, s0\n?\n⊨φ\nas a computational problem. For example, one could have the model M, the\nformula φ and a state s0 as input; one would then expect a reply of the form\n‘yes’ (M, s0 ⊨φ holds), or ‘no’ (M, s0 ⊨φ does not hold). Alternatively, the\ninputs could be just M and φ, where the output would be all states s of the\nmodel M which satisfy φ.\nIt turns out that it is easier to provide an algorithm for solving the second\nof these two problems. This automatically gives us a solution to the ﬁrst one,\nsince we can simply check whether s0 is an element of the output set.\nThe labelling algorithm\nWe present an algorithm which, given a model\nand a CTL formula, outputs the set of states of the model that satisfy the\nformula. The algorithm does not need to be able to handle every CTL con-\nnective explicitly, since we have already seen that the connectives ⊥, ¬ and\n∧form an adequate set as far as the propositional connectives are concerned;\nand AF , EU and EX form an adequate set of temporal connectives. Given\nan arbitrary CTL formula φ, we would simply pre-process φ in order to write",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-7",
                    "title": "The Fixed-Point Characterisation of CTL",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-7-subsection-1",
                            "title": "Monotone Functions",
                            "content": "Now suppose that X is another ﬁxed point of F. We need to show that\nF n+1(∅) is a subset of X; but, since ∅⊆X, we conclude F(∅) ⊆F(X) =\nX, for F is monotone and X a ﬁxed point of F. By induction, we obtain\nF i(∅) ⊆X for all i ≥0. So, for i\ndef\n= n + 1, we get F n+1(∅) ⊆X.\nThe proof of the statements about the greatest ﬁxed point is dual to the\none above. Simply replace ⊆by ⊇, ∅by S and ‘bigger’ by ‘smaller.’\n2\n242\n3 Verification by model checking\nThis theorem about the existence of least and greatest ﬁxed points of\nmonotone functions F : P(S) →P(S) not only asserted the existence of\nsuch ﬁxed points; it also provided a recipe for computing them, and cor-\nrectly so. For example, in computing the least ﬁxed point of F, all we have\nto do is apply F to the empty set ∅and keep applying F to the result un-\ntil the latter becomes invariant under the application of F. The theorem\nabove further ensures that this process is guaranteed to terminate. More-\nover, we can specify an upper bound n + 1 to the worst-case number of\niterations necessary for reaching this ﬁxed point, assuming that S has n + 1\nelements.\n3.7.2 The correctness of SATEG\nWe saw at the end of the last section that [[EG φ]] = [[φ]] ∩pre∃([[EG φ]]). This\nimplies that EG φ is a ﬁxed point of the function F(X) = [[φ]] ∩pre∃(X). In\nfact, F is monotone, EG φ is its greatest ﬁxed point and therefore EG φ can\nbe computed using Theorem 3.24.\nTheorem 3.25 Let F be as deﬁned above and let S have n + 1 elements.\nThen F is monotone, [[EG φ]] is the greatest ﬁxed point of F, and [[EG φ]] =\nF n+1(S).\nPROOF:\n1.\nIn order to show that F is monotone, we take any two subsets X and Y of S\nsuch that X ⊆Y and we need to show that F(X) is a subset of F(Y ). Given s0\nsuch that there is some s1 ∈X with s0 →s1, we certainly have s0 →s1, where\ns1 ∈Y , for X is a subset of Y . Thus, we showed pre∃(X) ⊆pre∃(Y ) from which\nwe readily conclude that F(X) = [[φ]] ∩pre∃(X) ⊆[[φ]] ∩pre∃(Y ) = F(Y ).\n2.\nthat EG could be handled directly.\n240\n3 Verification by model checking\nfunction SATEG (φ)\n/* determines the set of states satisfying EG φ */\nlocal var X, Y\nbegin\nY := SAT (φ);\nX := ∅;\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∩pre∃(Y )\nend\nreturn Y\nend\nFigure 3.37. The pseudo-code for SATEG.\n3.7.1 Monotone functions\nDeﬁnition 3.22 Let S be a set of states and F : P(S) →P(S) a function\non the power set of S.\n1.\nWe say that F is monotone iﬀX ⊆Y implies F(X) ⊆F(Y ) for all subsets X\nand Y of S.\n2.\nA subset X of S is called a ﬁxed point of F iﬀF(X) = X.\nFor an example, let S\ndef\n= {s0, s1} and F(Y )\ndef\n= Y ∪{s0} for all subsets Y\nof S. Since Y ⊆Y ′ implies Y ∪{s0} ⊆Y ′ ∪{s0}, we see that F is monotone.\nThe ﬁxed points of F are all subsets of S containing s0. Thus, F has two\nﬁxed points, the sets {s0} and {s0, s1}. Notice that F has a least (= {s0})\nand a greatest (= {s0, s1}) ﬁxed point.\nAn example of a function G: P(S) →P(S), which is not monotone, is\ngiven by\nG(Y )\ndef\n= if Y = {s0} then {s1} else {s0}.\nSo G maps {s0} to {s1} and all other sets to {s0}. The function G is\nnot monotone since {s0} ⊆{s0, s1} but G({s0}) = {s1} is not a subset of\nG({s0, s1}) = {s0}. Note that G has no ﬁxed points whatsoever.\nThe reasons for exploring monotone functions on P(S) in the context of\nproving the correctness of SAT are:\n1.\nthat monotone functions always have a least and a greatest ﬁxed point;\n2.\nthat the meanings of EG, AF and EU can be expressed via greatest, respectively\nleast, ﬁxed points of monotone functions on P(S);\n3.7 The fixed-point characterisation of CTL\n241\n3.\nthat these ﬁxed-points can be easily computed, and;\n4.\nthat the procedures SATEU and SATAF code up such ﬁxed-point computations,\nand are correct by item 2.\nNotation 3.23 F i(X) means\nF(F(. . . F\n\u0001\n\u0002\u0003\n\u0004\ni times\n(X) . . . ))\nThus, the function F i is just ‘F applied i many times.’\nFor example, for the function F(Y )\ndef\n= Y ∪{s0}, we obtain F 2(Y ) =\nalence E[φ U ψ] ≡ψ ∨(φ ∧EX E[φ U ψ]) and we write it as [[E[φ U ψ]]] =\n[[ψ]] ∪([[φ]] ∩pre∃[[E[φ U ψ]]]). That tells us that [[E[φ U ψ]]] is a ﬁxed point\nof the function G(X) = [[ψ]] ∪([[φ]] ∩pre∃(X)). As before, we can prove that\nthis function is monotone. It turns out that [[E[φ U ψ]]] is its least ﬁxed\npoint and that the function SATEU is actually computing it in the manner of\nTheorem 3.24.\nTheorem 3.26 Let G be deﬁned as above and let S have n + 1 elements.\nThen G is monotone, [[E(φ U ψ)]] is the least ﬁxed point of G, and we have\n[[E(φ U ψ)]] = Gn+1(∅).\n2 If you are sceptical, try computing the values Y0, Y1, Y2, . . . , where Yi represents the value of Y\nafter i iterations round the loop. The program before the change computes as follows:\nY0 = SAT(φ)\nY1 = Y0 ∩pre∃(Y0)\nY2 = Y1 ∩pre∃(Y1)\n= Y0 ∩pre∃(Y0) ∩pre∃(Y0 ∩pre∃(Y0))\n= Y0 ∩pre∃(Y0 ∩pre∃(Y0)).\nThe last of these equalities follows from the monotonicity of pre∃.\nY3 = Y2 ∩pre∃(Y2)\n= Y0 ∩pre∃(Y0 ∩pre∃(Y0)) ∩pre∃(Y0 ∩pre∃(Y0 ∩pre∃(Y0)))\n= Y0 ∩pre∃(Y0 ∩pre∃(Y0 ∩pre∃(Y0))).\nAgain the last one follows by monotonicity. Now look at what the program does after the change:\nY0 = SAT(φ)\nY1 = SAT(φ) ∩pre∃(Y0)\n= Y0 ∩pre∃(Y0)\nY2 = Y0 ∩pre∃(Y1)\nY3 = Y0 ∩pre∃(Y1)\n= Y0 ∩pre∃(Y0 ∩pre∃(Y0)).\nA formal proof would follow by induction on i.\n244\n3 Verification by model checking\nPROOF:\n1.\nAgain, we need to show that X ⊆Y implies G(X) ⊆G(Y ); but that is essen-\ntially the same argument as for F, since the function which sends X to pre∃(X)\nis monotone and all that G now does is to perform the intersection and union\nof that set with constant sets [[φ]] and [[ψ]].\n2.\nIf S has n + 1 elements, then the least ﬁxed point of G equals Gn+1(∅) by\nTheorem 3.24. Therefore it suﬃces to show that this set equals [[E(φ U ψ)]].\nSimply observe what kind of states we obtain by iterating G on the empty set\n∅: G1(∅) = [[ψ]] ∪([[φ]] ∩pre∃([[∅]])) = [[ψ]] ∪([[φ]] ∩∅) = [[ψ]] ∪∅= [[ψ]], which are\n4.\nthat the procedures SATEU and SATAF code up such ﬁxed-point computations,\nand are correct by item 2.\nNotation 3.23 F i(X) means\nF(F(. . . F\n\u0001\n\u0002\u0003\n\u0004\ni times\n(X) . . . ))\nThus, the function F i is just ‘F applied i many times.’\nFor example, for the function F(Y )\ndef\n= Y ∪{s0}, we obtain F 2(Y ) =\nF(F(Y )) = (Y ∪{s0}) ∪{s0} = Y ∪{s0} = F(Y ). In this case, F 2 = F and\ntherefore F i = F for all i ≥1. It is not always the case that the sequence of\nfunctions (F 1, F 2, F 3, . . . ) stabilises in such a way. For example, this won’t\nhappen for the function G deﬁned above (see Exercise 1(d) on page 253).\nThe following fact is a special case of a fundamental insight, often referred\nto as the Knaster–Tarski Theorem.\nTheorem 3.24 Let S be a set {s0, s1, . . . , sn} with n + 1 elements. If\nF : P(S) →P(S) is a monotone function, then F n+1(∅) is the least ﬁxed\npoint of F and F n+1(S) is the greatest ﬁxed point of F.\nPROOF: Since ∅⊆F(∅), we get F(∅) ⊆F(F(∅)), i.e., F 1(∅) ⊆F 2(∅), for F\nis monotone. We can now use mathematical induction to show that\nF 1(∅) ⊆F 2(∅) ⊆F 3(∅) ⊆. . . ⊆F i(∅)\nfor all i ≥1. In particular, taking i\ndef\n= n + 1, we claim that one of the expres-\nsions F k(∅) above is already a ﬁxed point of F. Otherwise, F 1(∅) needs to\ncontain at least one element (for then ∅̸= F(∅)). By the same token, F 2(∅)\nneeds to have at least two elements since it must be bigger than F 1(∅). Con-\ntinuing this argument, we see that F n+2(∅) would have to contain at least\nn + 2 many elements. The latter is impossible since S has only n + 1 ele-\nments. Therefore, F(F k(∅)) = F k(∅) for some 0 ≤k ≤n + 1, which readily\nimplies that F n+1(∅) is a ﬁxed point of F as well.\nNow suppose that X is another ﬁxed point of F. We need to show that\nF n+1(∅) is a subset of X; but, since ∅⊆X, we conclude F(∅) ⊆F(X) =\nX, for F is monotone and X a ﬁxed point of F. By induction, we obtain\nF i(∅) ⊆X for all i ≥0. So, for i\ndef\n= n + 1, we get F n+1(∅) ⊆X.\neven number of complementation symbols ¯; such an f is said to be formally\nmonotone in Z. (In exercise 7 on page 410 we consider what happens if we\ndo not require formal monotonicity.)\n6.4 A relational mu-calculus\n391\nConvention 6.15 The binding priorities for the grammar in (6.10) are that\n¯, and [ˆx := ˆx′] have the highest priority; followed by ∃x and ∀y; then µZ\nand νZ; followed by · . The operators + and ⊕have the lowest binding\npriority.\nThe symbols µ and ν are called least ﬁxed-point and greatest ﬁxed-point\noperators, respectively. In the formula µZ.f, the interesting case is that in\nwhich f contains an occurrence of Z. In that case, f can be thought of as\na function, taking Z to f. The formula µZ.f is intended to mean the least\nﬁxed point of that function. Similarly, νZ.f is the greatest ﬁxed point of the\nfunction. We will see how this is done in the semantics.\nThe formula f[ˆx := ˆx′] expresses an explicit substitution which forces f\nto be evaluated using the values of x′\ni rather than xi. (Recall that the primed\nvariables refer to the next state.) Thus, this syntactic form is not a meta-\noperation denoting a substitution, but an explicit syntactic form in its own\nright. The substitution will be made on the semantic side, not the syntactic\nside. This diﬀerence will become clear when we present the semantics of ⊨.\nA valuation ρ for f is an assignment of values 0 or 1 to all variables v.\nWe deﬁne a satisfaction relation ρ ⊨f inductively over the structure of such\nformulas f, given a valuation ρ.\nDeﬁnition 6.16 Let ρ be a valuation and v a variable. We write ρ(v) for\nthe value of v assigned by ρ. We deﬁne ρ[v \u0011→0] to be the updated valuation\nwhich assigns 0 to v and ρ(w) to all other variables w. Dually, ρ[v \u0011→1]\nassigns 1 to v and ρ(w) to all other variables w.\nFor example, if ρ is the valuation represented by (x, y, Z) ⇒(1, 0, 1) –\nmeaning that ρ(x) = 1, ρ(y) = 0, ρ(Z) = 1 and ρ(v) = 0 for all other vari-",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-7-subsection-2",
                            "title": "The Correctness of SATEG",
                            "content": "nodes or use the rules in Figure 1.14. Give a semi-formal argument for why the\nanalysis results don’t depend on such an order.\n12. Find a formula φ such that our cubic SAT solver cannot decide the satisﬁability\nof T(φ).\n13. Advanced Project: Write a complete implementation of the cubic SAT solver\ndescribed in Section 1.6.2. It should read formulas from the keyboard or a ﬁle;\nshould assume right-associativity of ∨, ∧, and →(respectively); compute the\nDAG of T(φ); perform the cubic SAT solver next. Think also about including\nappropriate user output, diagnostics, and optimizations.\n14. Show that our cubic SAT solver speciﬁed in this section\n(a) terminates on all syntactically correct input;\n(b) satisﬁes the invariant (1.9) after the ﬁrst permanent marking;\n(c) preserves (1.9) for all permanent markings it makes;\n(d) computes only correct satisﬁability witnesses;\n(e) computes only correct ‘not satisﬁable’ replies; and\n(f) remains to be correct under the two modiﬁcations described on page 77 for\nhandling results of a node’s two test runs.\n1.8 Bibliographic notes\nLogic has a long history stretching back at least 2000 years, but the truth-\nvalue semantics of propositional logic presented in this and every logic text-\nbook today was invented only about 160 years ago, by G. Boole [Boo54].\nBoole used the symbols + and · for disjunction and conjunction.\nNatural deduction was invented by G. Gentzen [Gen69], and further de-\nveloped by D. Prawitz [Pra65]. Other proof systems existed before then, no-\ntably axiomatic systems which present a small number of axioms together\nwith the rule modus ponens (which we call →e). Proof systems often present\nas small a number of axioms as possible; and only for an adequate set of con-\nnectives such as →and ¬. This makes them hard to use in practice. Gentzen\nimproved the situation by inventing the idea of working with assumptions\n(used by the rules →i, ¬i and ∨e) and by treating all the connectives sepa-\nrately.\n92\n1 Propositional logic\nstabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\ncode in Figure 3.28, we see that most of these clauses just do the obvious\nand correct thing according to the semantics of CTL. For example, try out\nwhat SAT does when you call it with φ1 →φ2.\nOur aim in this section is to prove the termination and correctness\nof SATAF and SATEU. In fact, we will also write a procedure SATEG and\nprove its termination and correctness1. The procedure SATEG is given in\nFigure 3.37 and is based on the intuitions given in Section 3.6.1: note how\ndeleting the label if none of the successor states is labelled is coded as\nintersecting the labelled set with the set of states which have a labelled\nsuccessor.\nThe semantics of EG φ says that s0 ⊨EG φ holds iﬀthere exists a com-\nputation path s0 →s1 →s2 →. . . such that si ⊨φ holds for all i ≥0. We\ncould instead express it as follows: EG φ holds if φ holds and EG φ holds\nin one of the successor states to the current state. This suggests the equiv-\nalence EG φ ≡φ ∧EX EG φ which can easily be proved from the semantic\ndeﬁnitions of the connectives.\nObserving that [[EX ψ]] = pre∃([[ψ]]) we see that the equivalence above\ncan be written as [[EG φ]] = [[φ]] ∩pre∃([[EG φ]]). This does not look like a\nvery promising way of calculating EG φ, because we need to know EG φ in\norder to work out the right-hand side. Fortunately, there is a way around\nthis apparent circularity, known as computing ﬁxed points, and that is the\nsubject of this section.\n1 Section 3.6.1 handles EG φ by translating it into ¬AF ¬φ, but we already noted in Section 3.6.1\nthat EG could be handled directly.\n240\n3 Verification by model checking\nfunction SATEG (φ)\n/* determines the set of states satisfying EG φ */\nlocal var X, Y\nbegin\nY := SAT (φ);\nX := ∅;\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∩pre∃(Y )\nnow we are interested only in the mechanism in principle of the algorithm\nfor SAT; any (correct and eﬃcient) implementation of sets would do and\nwe study such an implementation in Chapter 6. We assume that SAT has\naccess to all the relevant parts of the model: S, →and L. In particular,\nwe ignore the fact that SAT would require a description of M as input as\nwell. We simply assume that SAT operates directly on any such given model.\nNote how SAT translates φ into an equivalent formula of the adequate set\nchosen.\n3.6 Model-checking algorithms\n227\nfunction SAT (φ)\n/* determines the set of states satisfying φ */\nbegin\ncase\nφ is ⊤: return S\nφ is ⊥: return ∅\nφ is atomic: return {s ∈S | φ ∈L(s)}\nφ is ¬φ1 : return S −SAT (φ1)\nφ is φ1 ∧φ2 : return SAT (φ1) ∩SAT (φ2)\nφ is φ1 ∨φ2 : return SAT (φ1) ∪SAT (φ2)\nφ is φ1 →φ2 : return SAT (¬φ1 ∨φ2)\nφ is AX φ1 : return SAT (¬EX ¬φ1)\nφ is EX φ1 : return SATEX(φ1)\nφ is A[φ1 U φ2] : return SAT(¬(E[¬φ2 U (¬φ1 ∧¬φ2)] ∨EG ¬φ2))\nφ is E[φ1 U φ2] : return SATEU(φ1, φ2)\nφ is EF φ1 : return SAT (E(⊤U φ1))\nφ is EG φ1 : return SAT(¬AF ¬φ1)\nφ is AF φ1 : return SATAF (φ1)\nφ is AG φ1 : return SAT (¬EF ¬φ1)\nend case\nend function\nFigure 3.28. The function SAT. It takes a CTL formula as input and\nreturns the set of states satisfying the formula. It calls the functions\nSATEX, SATEU and SATAF, respectively, if EX , EU or AF is the root of the\ninput’s parse tree.\nThe algorithm is presented in Figure 3.28 and its subfunctions in Fig-\nures 3.29–3.31. They use program variables X, Y , V and W which are sets\nof states. The program for SAT handles the easy cases directly and passes\nmore complicated cases on to special procedures, which in turn might call\nSAT recursively on subexpressions. These special procedures rely on imple-\nmentations of the functions\npre∃(Y ) = {s ∈S | exists s′, (s →s′ and s′ ∈Y )}\npre∀(Y ) = {s ∈S | for all s′, (s →s′ implies s′ ∈Y )}.\n‘Pre’ denotes travelling backwards along the transition relation. Both func-\nof the proof rule LEM; and the linear SAT solver does not employ any case\nanalysis.)\n4.\n*\nConsider the sequent p ∨q, p →r ⊢r. Determine a DAG which is not satisﬁable\niﬀthis sequent is valid. Tag the DAG’s root node with ‘1: T,’ apply the forcing\nlaws to it, and extract a witness to the DAG’s satisﬁability. Explain in what\nsense this witness serves as an explanation for the fact that p ∨q, p →r ⊢r is\nnot valid.\n5. Explain in what sense the SAT solving technique, as presented in this chapter,\ncan be used to check whether formulas are tautologies.\n6. For φ from (1.10), can one reverse engineer φ from the DAG of T(φ)?\n7. Consider a modiﬁcation of our method which initially tags a DAG’s root node\nwith ‘1: F.’ In that case,\n(a) are the forcing laws still sound? If so, state the invariant.\n(b) what can we say about the formula(s) a DAG represents if\ni. we detect contradictory constraints?\nii. we compute consistent forced constraints for each node?\n8. Given an arbitrary Horn formula φ, compare our linear SAT solver – applied\nto T(φ) –\nto the marking algorithm – applied to φ. Discuss similarities and\ndiﬀerences of these approaches.\n1.8 Bibliographic notes\n91\n9. Consider Figure 1.20 on page 77. Verify that\n(a) its test produces contradictory constraints\n(b) its cubic analysis does not decide satisﬁability, regardless of whether the\ntwo optimizations we described are present.\n10. Verify that the DAG of Figure 1.17 (page 74) is indeed the one obtained for\nT(φ), where φ is the formula in (1.11) on page 73.\n11.\n*\nAn implementor may be concerned with the possibility that the answers to the\ncubic SAT solver may depend on a particular order in which we test unmarked\nnodes or use the rules in Figure 1.14. Give a semi-formal argument for why the\nanalysis results don’t depend on such an order.\n12. Find a formula φ such that our cubic SAT solver cannot decide the satisﬁability\nof T(φ).\n13. Advanced Project: Write a complete implementation of the cubic SAT solver\nSAT recursively on subexpressions. These special procedures rely on imple-\nmentations of the functions\npre∃(Y ) = {s ∈S | exists s′, (s →s′ and s′ ∈Y )}\npre∀(Y ) = {s ∈S | for all s′, (s →s′ implies s′ ∈Y )}.\n‘Pre’ denotes travelling backwards along the transition relation. Both func-\ntions compute a pre-image of a set of states. The function pre∃(instrumental\nin SATEX and SATEU) takes a subset Y of states and returns the set of states\nwhich can make a transition into Y . The function pre∀, used in SATAF, takes\n228\n3 Verification by model checking\nfunction SATEX (φ)\n/* determines the set of states satisfying EX φ */\nlocal var X, Y\nbegin\nX := SAT (φ);\nY := pre∃(X);\nreturn Y\nend\nFigure 3.29. The function SATEX. It computes the states satisfying φ by\ncalling SAT. Then, it looks backwards along →to find the states satisfying\nEX φ.\nfunction SATAF (φ)\n/* determines the set of states satisfying AF φ */\nlocal var X, Y\nbegin\nX := S;\nY := SAT (φ);\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∪pre∀(Y )\nend\nreturn Y\nend\nFigure 3.30. The function SATAF. It computes the states satisfying φ by\ncalling SAT. Then, it accumulates states satisfying AF φ in the manner\ndescribed in the labelling algorithm.\na set Y and returns the set of states which make transitions only into Y .\nObserve that pre∀can be expressed in terms of complementation and pre∃,\nas follows:\npre∀(Y ) = S −pre∃(S −Y )\n(3.8)\nwhere we write S −Y for the set of all s ∈S which are not in Y .\nThe correctness of this pseudocode and the model checking algorithm is\ndiscussed in Section 3.7.\n3.6 Model-checking algorithms\n229\nfunction SATEU (φ, ψ)\n/* determines the set of states satisfying E[φ U ψ] */\nlocal var W, X, Y\nbegin\nW := SAT (φ);\nX := S;\nY := SAT (ψ);\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∪(W ∩pre∃(Y ))\nend\nreturn Y\nend\nFigure 3.31. The function SATEU. It computes the states satisfying φ by\ncalling SAT. Then, it accumulates states satisfying E[φ U ψ] in the manner\ndescribed in the labelling algorithm.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-7-subsection-3",
                            "title": "The Correctness of SATEU",
                            "content": "stabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\ncode in Figure 3.28, we see that most of these clauses just do the obvious\nand correct thing according to the semantics of CTL. For example, try out\nwhat SAT does when you call it with φ1 →φ2.\nOur aim in this section is to prove the termination and correctness\nof SATAF and SATEU. In fact, we will also write a procedure SATEG and\nprove its termination and correctness1. The procedure SATEG is given in\nFigure 3.37 and is based on the intuitions given in Section 3.6.1: note how\ndeleting the label if none of the successor states is labelled is coded as\nintersecting the labelled set with the set of states which have a labelled\nsuccessor.\nThe semantics of EG φ says that s0 ⊨EG φ holds iﬀthere exists a com-\nputation path s0 →s1 →s2 →. . . such that si ⊨φ holds for all i ≥0. We\ncould instead express it as follows: EG φ holds if φ holds and EG φ holds\nin one of the successor states to the current state. This suggests the equiv-\nalence EG φ ≡φ ∧EX EG φ which can easily be proved from the semantic\ndeﬁnitions of the connectives.\nObserving that [[EX ψ]] = pre∃([[ψ]]) we see that the equivalence above\ncan be written as [[EG φ]] = [[φ]] ∩pre∃([[EG φ]]). This does not look like a\nvery promising way of calculating EG φ, because we need to know EG φ in\norder to work out the right-hand side. Fortunately, there is a way around\nthis apparent circularity, known as computing ﬁxed points, and that is the\nsubject of this section.\n1 Section 3.6.1 handles EG φ by translating it into ¬AF ¬φ, but we already noted in Section 3.6.1\nthat EG could be handled directly.\n240\n3 Verification by model checking\nfunction SATEG (φ)\n/* determines the set of states satisfying EG φ */\nlocal var X, Y\nbegin\nY := SAT (φ);\nX := ∅;\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∩pre∃(Y )\nof the proof rule LEM; and the linear SAT solver does not employ any case\nanalysis.)\n4.\n*\nConsider the sequent p ∨q, p →r ⊢r. Determine a DAG which is not satisﬁable\niﬀthis sequent is valid. Tag the DAG’s root node with ‘1: T,’ apply the forcing\nlaws to it, and extract a witness to the DAG’s satisﬁability. Explain in what\nsense this witness serves as an explanation for the fact that p ∨q, p →r ⊢r is\nnot valid.\n5. Explain in what sense the SAT solving technique, as presented in this chapter,\ncan be used to check whether formulas are tautologies.\n6. For φ from (1.10), can one reverse engineer φ from the DAG of T(φ)?\n7. Consider a modiﬁcation of our method which initially tags a DAG’s root node\nwith ‘1: F.’ In that case,\n(a) are the forcing laws still sound? If so, state the invariant.\n(b) what can we say about the formula(s) a DAG represents if\ni. we detect contradictory constraints?\nii. we compute consistent forced constraints for each node?\n8. Given an arbitrary Horn formula φ, compare our linear SAT solver – applied\nto T(φ) –\nto the marking algorithm – applied to φ. Discuss similarities and\ndiﬀerences of these approaches.\n1.8 Bibliographic notes\n91\n9. Consider Figure 1.20 on page 77. Verify that\n(a) its test produces contradictory constraints\n(b) its cubic analysis does not decide satisﬁability, regardless of whether the\ntwo optimizations we described are present.\n10. Verify that the DAG of Figure 1.17 (page 74) is indeed the one obtained for\nT(φ), where φ is the formula in (1.11) on page 73.\n11.\n*\nAn implementor may be concerned with the possibility that the answers to the\ncubic SAT solver may depend on a particular order in which we test unmarked\nnodes or use the rules in Figure 1.14. Give a semi-formal argument for why the\nanalysis results don’t depend on such an order.\n12. Find a formula φ such that our cubic SAT solver cannot decide the satisﬁability\nof T(φ).\n13. Advanced Project: Write a complete implementation of the cubic SAT solver\nnodes or use the rules in Figure 1.14. Give a semi-formal argument for why the\nanalysis results don’t depend on such an order.\n12. Find a formula φ such that our cubic SAT solver cannot decide the satisﬁability\nof T(φ).\n13. Advanced Project: Write a complete implementation of the cubic SAT solver\ndescribed in Section 1.6.2. It should read formulas from the keyboard or a ﬁle;\nshould assume right-associativity of ∨, ∧, and →(respectively); compute the\nDAG of T(φ); perform the cubic SAT solver next. Think also about including\nappropriate user output, diagnostics, and optimizations.\n14. Show that our cubic SAT solver speciﬁed in this section\n(a) terminates on all syntactically correct input;\n(b) satisﬁes the invariant (1.9) after the ﬁrst permanent marking;\n(c) preserves (1.9) for all permanent markings it makes;\n(d) computes only correct satisﬁability witnesses;\n(e) computes only correct ‘not satisﬁable’ replies; and\n(f) remains to be correct under the two modiﬁcations described on page 77 for\nhandling results of a node’s two test runs.\n1.8 Bibliographic notes\nLogic has a long history stretching back at least 2000 years, but the truth-\nvalue semantics of propositional logic presented in this and every logic text-\nbook today was invented only about 160 years ago, by G. Boole [Boo54].\nBoole used the symbols + and · for disjunction and conjunction.\nNatural deduction was invented by G. Gentzen [Gen69], and further de-\nveloped by D. Prawitz [Pra65]. Other proof systems existed before then, no-\ntably axiomatic systems which present a small number of axioms together\nwith the rule modus ponens (which we call →e). Proof systems often present\nas small a number of axioms as possible; and only for an adequate set of con-\nnectives such as →and ¬. This makes them hard to use in practice. Gentzen\nimproved the situation by inventing the idea of working with assumptions\n(used by the rules →i, ¬i and ∨e) and by treating all the connectives sepa-\nrately.\n92\n1 Propositional logic\nFigure 1.14. Rules for flow of constraints in a formula’s DAG. Small\ncircles indicate arbitrary nodes (¬, ∧or atom). Note that the rules ∧ﬂl,\n∧frr and ∧ti require that the source constraints of both =⇒are present.\nrepresented by this DAG. A post-processing phase takes the marks for all\natoms and re-computes marks of all other nodes in a bottom-up manner, as\ndone in Section 1.4 on parse trees. Only if the resulting marks match the\nones we computed have we found a witness. Please verify that this is the\ncase in Figure 1.13.\nWe can apply SAT solvers to checking whether sequents are valid. For\nexample, the sequent p ∧q →r ⊢p →q →r is valid iﬀ(p ∧q →r) →p →\nq →r is a theorem (why?) iﬀφ = ¬((p ∧q →r) →p →q →r) is not satis-\nﬁable. The DAG of T(φ) is depicted in Figure 1.15. The annotations “1” etc\nindicate which nodes represent which sub-formulas. Notice that such DAGs\nmay be constructed by applying the translation clauses for T to sub-formulas\nin a bottom-up manner – sharing equal subgraphs were applicable.\nThe ﬁndings of our SAT solver can be seen in Figure 1.16. The solver\nconcludes that the indicated node requires the marks T and F for (1.9) to be\nmet. Such contradictory constraints therefore imply that all formulas T(φ)\nwhose DAG equals that of this ﬁgure are not satisﬁable. In particular, all\n72\n1 Propositional logic\np\nq\nr\n¬\n∧\n∧\n∧\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n¬\n= ”3” →”2”\n“5” = entire formula\n“4”\n“3” = p ∧q →r\n“2” = p →”1”\n“1” = q →r\n“2”\n“3”\n“1”\n“4”\n“5”\nFigure 1.15. The DAG for the translation of ¬((p ∧q →r) →p →q →\nr). Labels ‘‘1’’ etc indicate which nodes represent what subformulas.\nsuch φ are unsatisﬁable. This SAT solver has a linear running time in the\nsize of the DAG for T(φ). Since that size is a linear function of the length\nof φ – the translation T causes only a linear blow-up – our SAT solver has\na linear running time in the length of the formula. This linearity came with\na price: our linear solver fails for all formulas of the form ¬(φ1 ∧φ2).\n1.6.2 A cubic solver\n57\nDeﬁnition 1.44 Given a formula φ in propositional logic, we say that φ is\nsatisﬁable if it has a valuation in which is evaluates to T.\nFor example, the formula p ∨q →p is satisﬁable since it computes T if we\nassign T to p. Clearly, p ∨q →p is not valid. Thus, satisﬁability is a weaker\nconcept since every valid formula is by deﬁnition also satisﬁable but not vice\nversa. However, these two notions are just mirror images of each other, the\nmirror being negation.\nProposition 1.45 Let φ be a formula of propositional logic. Then φ is sat-\nisﬁable iﬀ¬φ is not valid.\nProof: First, assume that φ is satisﬁable. By deﬁnition, there exists a\nvaluation of φ in which φ evaluates to T; but that means that ¬φ evaluates\nto F for that same valuation. Thus, ¬φ cannot be valid.\nSecond, assume that ¬φ is not valid. Then there must be a valuation\nof ¬φ in which ¬φ evaluates to F. Thus, φ evaluates to T and is there-\nfore satisﬁable. (Note that the valuations of φ are exactly the valuations of\n¬φ.)\n2\nThis result is extremely useful since it essentially says that we need provide\na decision procedure for only one of these concepts. For example, let’s say\nthat we have a procedure P for deciding whether any φ is valid. We obtain a\ndecision procedure for satisﬁability simply by asking P whether ¬φ is valid.\nIf it is, φ is not satisﬁable; otherwise φ is satisﬁable. Similarly, we may\ntransform any decision procedure for satisﬁability into one for validity. We\nwill encounter both kinds of procedures in this text.\nThere is one scenario in which computing an equivalent formula in CNF\nis really easy; namely, when someone else has already done the work of\nwriting down a full truth table for φ. For example, take the truth table\nof (p →¬q) →(q ∨¬p) in Figure 1.8 (page 40). For each line where (p →\n¬q) →(q ∨¬p) computes F we now construct a disjunction of literals. Since\nthere is only one such line, we have only one conjunct ψ1. That conjunct",
                            "children": []
                        }
                    ]
                }
            ]
        },
        {
            "id": "chapter-1",
            "title": "Program Verification",
            "content": null,
            "children": [
                {
                    "id": "chapter-1-section-1",
                    "title": "Why Should We Specify and Verify Code?",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-2",
                    "title": "A Framework for Software Verification",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-2-subsection-1",
                            "title": "A Core Programming Language",
                            "content": "core language of most imperative programming languages. Modulo trivial\n260\n4 Program verification\nsyntactic variations, it is a subset of Pascal, C, C++ and Java. Our lan-\nguage consists of assignments to integer- and boolean-valued variables, if-\nstatements, while-statements and sequential compositions. Everything that\ncan be computed by large languages like C and Java can also be computed\nby our language, though perhaps not as conveniently, because it does not\nhave any objects, procedures, threads or recursive data structures. While\nthis makes it seem unrealistic compared with fully blown commercial lan-\nguages, it allows us to focus our discussion on the process of formal program\nveriﬁcation. The features missing from our language could be implemented\non top of it; that is the justiﬁcation for saying that they do not add to the\npower of the language, but only to the convenience of using it. Verifying\nprograms using those features would require non-trivial extensions of the\nproof calculus we present here. In particular, dynamic scoping of variables\npresents hard problems for program-veriﬁcation methods, but this is beyond\nthe scope of this book.\nOur core language has three syntactic domains: integer expressions,\nboolean expressions and commands – the latter we consider to be our\nprograms. Integer expressions are built in the familiar way from variables\nx, y, z, . . . , numerals 0, 1, 2, . . . , −1, −2, . . . and basic operations like addition\n(+) and multiplication (∗). For example,\n5\nx\n4 + (x −3)\nx + (x ∗(y −(5 + z)))\nare all valid integer expressions. Our grammar for generating integer expres-\nsions is\nE ::=\nn | x | (−E) | (E + E) | (E −E) | (E ∗E)\n(4.1)\nwhere n is any numeral in {. . . , −2, −1, 0, 1, 2, . . . } and x is any variable.\nNote that we write multiplication in ‘mathematics’ as 2 · 3, whereas our\ncore language writes 2 ∗3 instead.\nConvention 4.1 In the grammar above, negation −binds more tightly\nScience. Addison Wesley, 1991.\nSch92. U. Schoening. Logik f¨ur Informatiker. B. I. Wissenschaftsverlag, 1992.\nSch94. D. A. Schmidt. The Structure of Typed Programming Languages.\nFoundations of Computing. The MIT Press, 1994.\nSim94. A. K. Simpson. The Proof Theory and Semantics of Intuitionistic\nModal Logic. PhD thesis, The University of Edinburgh, Department of\nComputer Science, 1994.\nSS90. G. St˚almarck and M. S˚aﬂund. Modeling and verifying systems and\nsoftware in propositional logic. In B. K. Daniels, editor, Safety of\nComputer Control Systems (SAFECOMP’90), pages 31–36. Pergamon\nPress, 1990.\nBibliography\n417\nTay98. R. G. Taylor. Models of Computation and Formal Languages. Oxford\nUniversity Press, 1998.\nTen91. R. D. Tennent. Semantics of Programming Languages. Prentice Hall,\n1991.\nTur91. R. Turner. Constructive Foundations for Functional Languages.\nMcGraw Hill, 1991.\nvD89. D. van Dalen. Logic and Structure. Universitext. Springer-Verlag, 3rd\nedition, 1989.\nVW84. M. Y. Vardi and Pierre Wolper. Automata-theoretic techniques for\nmodal logics of programs. In Proc. 16th ACM Symposium on Theory\nof Computing, pages 446–456, 1984.\nWei98. M. A. Weiss. Data Structures and Problem Solving Using Java.\nAddison-Wesley, 1998.\nIndex\nABP, 203\nacknowledgement channel, 203\nalternating the control bit, 203\nfairness, 203\nmain SMV program, 207\nabsorption laws, 88\nabstract data type\nsets, 226\nabstraction, 175, 229, 247\nand non-determinism, 191\naccessibility relation, 309, 320, 336\nadequate set of connectives\nfor CTL, 216, 222, 231, 397\nfor LTL, 186\nfor propositional logic, 69, 87, 91\nagent, 307, 319, 327\nalgebraic speciﬁcation, 170\nalgorithm\ndeterministic, 59\nalgorithm apply, 373\ncomplexity, 380\ncontrol structure, 374\nrecursive descent, 375\nalgorithm CNF, 59\nalgorithm reduce, 372\ncomplexity, 380\nalgorithm restrict, 377\ncomplexity, 380\nalgorithm reduce\nexample execution, 373\nAlloy\n[], 153\nfun-statement, 155\nwith, 146\nassertion, 144\ncheck directive, 144\nconsistency check, 144\nsmall scope hypothesis, 143\nSMV, 254\nmain program for ABP, 207\nmodule, 193\nreceiver, 205\nsender, 204\nfor channel, 206\ninstantiation, 193\nprocess, 389\nprogram\nexample, 192\nfor Mutex, 195\nspeciﬁcation, 192\nsoftware\nlife-cycle, 142\nmicromodel, 142\nreliability, 149\nrequirements, 142\nspeciﬁcation, 142\nvalidation, 142\nsoundness\nof forall-elimination, 109\nof natural deduction\nbasic modal logic, 354\npredicate logic, 96, 122\npropositional logic, 45\nof program logics, 267\nof proof rule for while-statements,\n282\nof the substitution principle, 108\n426\nIndex\nspeciﬁcation\nfor ABP, 207\nformal, 259\ninformal, 259\nlanguage, 172\nof a predicate, 157\npatterns, 254\npractical pattern, 183, 215\ntruth table, 58\nspeciﬁcations, 191\nSpin, 254\nstate\ncritical, 188\nexplosion, 229\nexplosion problem, 254\nfair, 397\nﬁnal, 142\nformula, 218\nglobal, 188\ngraph, 180\ninitial, 142, 189, 222, 247, 252, 264\nnon-critical, 188\nof a system, 269\nof core program, 264\nreachable, 247\nresulting, 263, 299\nspace, 229\nsplitting states, 190\ntransition, 142\ntrying, 188\nstate machine, 142\nstorage\nlocation, 288\nstate, 261\nstore\nof core program, 264\nstring, 247, 307\nbinary, 126, 132\nempty, 126\nstrongly connected component, 225\nstructural equality, 153\nstructural induction, 44, 51\nsubformula, 178\nsubstitution\nin predicate logic, 105\ninstance, 323\ninstance of tautology, 314\nprinciple, 108\nsymbolic model checking, 383\nsyntactic\ndomain, 260, 261\nsyntax\nof basic modal logic, 307\nof boolean expressions, 261\nof boolean formulas, 398\nof CTL, 208\nof CTL*, 218\nof KT45n, 335\nof LTL, 175\nof predicate logic, 100\nof propositional logic, 33\nof relational mu-calculus, 390\nof terms, 99\nsystem\nasynchronous, 254\ninterleaving model, 389\nsimultaneous model, 389\naxiomatic, 91\ncommercially critical, 172, 257\ncomponent, 206\nconcurrent, 173\ndebugging, 174\ndescription, 193\ndesign, 174\ndevelopment, 173\nelevator, 184, 215\nﬁnite-state, 256\nhybrid, 277\ninﬁnite-state, 256\nmission-critical, 172\nmulti-agent, 331\nphysical, 175\nreactive, 173, 257, 358\ngramming language you used a list of features of its software development envi-\nronment (compiler, editor, linker, run-time environment etc) that may improve\nthe likelihood that your programs work correctly. Try to rate the eﬀectiveness of\neach such feature.\n2. Repeat the previous exercise by listing and rating features that may decrease\nthe likelihood of procuding correct and reliable programs.\nExercises 4.2\n1.\n*\nIn what circumstances would if (B) {C1} else {C2} fail to terminate?\n2.\n*\nA familiar command missing from our language is the for-statement. It may be\nused to sum the elements in an array, for example, by programming as follows:\ns = 0;\nfor (i = 0; i <= max; i = i+1) {\ns = s + a[i];\n}\nAfter performing the initial assignment s = 0, this executes i = 0 ﬁrst, then\nexecutes the body s = s + a[i] and the incrementation i = i + 1 continually\nuntil i <= max becomes false. Explain how for (C1; B; C2) {C3} can be deﬁned\nas a derived program in our core language.\n3. Suppose that you need a language construct repeat {C} until (B) which re-\npeats C until B becomes true, i.e.\ni. executes C in the current state of the store;\nii. evaluates B in the resulting state of the store;\niii. if B is false, the program resumes with (i); otherwise, the program\nrepeat {C} until (B) terminates.\nThis construct sometimes allows more elegant code than a corresponding while-\nstatement.\n300\n4 Program verification\n(a) Deﬁne repeat C until B as a derived expression using our core language.\n(b) Can one deﬁne every repeat expression in our core language extended with\nfor-statements? (You might need the empty command skip which does noth-\ning.)\nExercises 4.3\n1. For any store l as in Example 4.4 (page 264), determine which of the relations\nbelow hold; justify your answers:\n(a)\n*\nl ⊨(x + y < z) →¬(x ∗y = z)\n(b) l ⊨∀u (u < y) ∨(u ∗z < y ∗z)\n(c)\n*\nl ⊨x + y −z < x ∗y ∗z.\n2.\n*\nFor any φ, ψ and P explain why ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever the relation\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds.\n‘New Symbolic Model Veriﬁer.’ NuSMV is an Open Source product, is ac-\ntively supported and has a substantial user community. For details on how\nto obtain it, see the bibliographic notes at the end of the chapter.\nNuSMV (sometimes called simply SMV) provides a language for describ-\ning the models we have been drawing as diagrams and it directly checks the\nvalidity of LTL (and also CTL) formulas on those models. SMV takes as\ninput a text consisting of a program describing a model and some speciﬁca-\ntions (temporal logic formulas). It produces as output either the word ‘true’\nif the speciﬁcations hold, or a trace showing why the speciﬁcation is false\nfor the model represented by our program.\nSMV programs consist of one or more modules. As in the programming\nlanguage C, or Java, one of the modules must be called main. Modules can\ndeclare variables and assign to them. Assignments usually give the initial\nvalue of a variable and its next value as an expression in terms of the current\nvalues of variables. This expression can be non-deterministic (denoted by\nseveral expressions in braces, or no assignment at all). Non-determinism is\nused to model the environment and for abstraction.\n192\n3 Verification by model checking\nThe following input to SMV:\nMODULE main\nVAR\nrequest : boolean;\nstatus : {ready,busy};\nASSIGN\ninit(status) := ready;\nnext(status) := case\nrequest : busy;\n1 : {ready,busy};\nesac;\nLTLSPEC\nG(request -> F status=busy)\nconsists of a program and a speciﬁcation. The program has two variables,\nrequest of type boolean and status of enumeration type {ready, busy}:\n0 denotes ‘false’ and 1 represents ‘true.’ The initial and subsequent values\nof variable request are not determined within this program; this conserva-\ntively models that these values are determined by an external environment.\nThis under-speciﬁcation of request implies that the value of variable status\nis partially determined: initially, it is ready; and it becomes busy whenever",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-2",
                            "title": "Hoare Triples",
                            "content": "\u0002\nto more complex ones. The rule for assignment is an axiom as\nit has no premises. This allows us to construct some triples out of noth-\ning, to get the proof going. Complete proofs are trees, see page 274 for an\nexample.\nComposition.\nGiven speciﬁcations for the program fragments C1 and C2,\nsay\n\u0001\nφ\n\u0002\nC1\n\u0001\nη\n\u0002\nand\n\u0001\nη\n\u0002\nC2\n\u0001\nψ\n\u0002\n,\nwhere the postcondition of C1 is also the precondition of C2, the proof\nrule for sequential composition shown in Figure 4.1 allows us to derive a\nspeciﬁcation for C1; C2, namely\n\u0001\nφ\n\u0002\nC1; C2\n\u0001\nψ\n\u0002\n.\n270\n4 Program verification\n\u0001\nφ\n\u0002\nC1\n\u0001\nη\n\u0002\n\u0001\nη\n\u0002\nC2\n\u0001\nψ\n\u0002\n\u0001\nφ\n\u0002\nC1; C2\n\u0001\nψ\n\u0002\nComposition\n\u0001\nψ[E/x]\n\u0002\nx = E\n\u0001\nψ\n\u0002 Assignment\n\u0001\nφ ∧B\n\u0002\nC1\n\u0001\nψ\n\u0002\n\u0001\nφ ∧¬B\n\u0002\nC2\n\u0001\nψ\n\u0002\n\u0001\nφ\n\u0002\nif B {C1} else {C2}\n\u0001\nψ\n\u0002\nIf-statement\n\u0001\nψ ∧B\n\u0002\nC\n\u0001\nψ\n\u0002\n\u0001\nψ\n\u0002\nwhile B {C}\n\u0001\nψ ∧¬B\n\u0002 Partial-while\n⊢AR φ′ →φ\n\u0001\nφ\n\u0002\nC\n\u0001\nψ\n\u0002\n⊢AR ψ →ψ′\n\u0001\nφ′\u0002\nC\n\u0001\nψ′\u0002\nImplied\nFigure 4.1. Proof rules for partial correctness of Hoare triples.\nThus, if we know that C1 takes φ-states to η-states and C2 takes η-states\nto ψ-states, then running C1 and C2 in that sequence will take φ-states to\nψ-states.\nUsing the proof rules of Figure 4.1 in program veriﬁcation, we have to\nread them bottom-up: e.g. in order to prove\n\u0001\nφ\n\u0002\nC1; C2\n\u0001\nψ\n\u0002\n, we need to ﬁnd\nan appropriate η and prove\n\u0001\nφ\n\u0002\nC1\n\u0001\nη\n\u0002\nand\n\u0001\nη\n\u0002\nC2\n\u0001\nψ\n\u0002\n. If C1; C2 runs on\ninput satisfying φ and we need to show that the store satisﬁes ψ after its\nexecution, then we hope to show this by splitting the problem into two. After\nthe execution of C1, we have a store satisfying η which, considered as input\nfor C2, should result in an output satisfying ψ. We call η a midcondition.\nAssignment.\nThe rule for assignment has no premises and is therefore an\naxiom of our logic. It tells us that, if we wish to show that ψ holds in the state\nafter the assignment x = E, we must show that ψ[E/x] holds before the\nassignment; ψ[E/x] denotes the formula obtained by taking ψ and replacing\nall free occurrences of x with E as deﬁned on page 105. We read the stroke\nFinally, let’s consider a really big integer:\n32498723462509735034567279652376420563047563456356347563\\\\\n96598734085384756074086560785607840745067340563457640875\\\\\n62984573756306537856405634056245634578692825623542135761\\\\\n9519765129854122965424895465956457\nwhere \\\\ denotes concatenation of digits. Although this is a very large num-\nber indeed, our program Collatz requires only 4940 iterations to terminate.\nUnfortunately, nobody knows a suitable variant for this program that could\nprove the validity of ⊢tot\n\u0001\n0 < x\n\u0002\nCollatz\n\u0001\n⊤\n\u0002\n. Observe how the use of ⊤as\na postcondition emphasizes that this Hoare triple is merely concerned about\nprogram termination as such. Ironically, there is also no known initial value\nof x greater than 0 for which Collatz doesn’t terminate. In fact, things are\neven subtler than they may appear: if we replace 3*c + 1 in Collatz with a\ndiﬀerent such linear expression in c, the program may not terminate despite\nmeeting the precondition 0 < x; see exercise 6 on page 303.\n4.5 Programming by contract\nFor a valid sequent ⊢tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n, the triple\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nmay be seen as a\ncontract between a supplier and a consumer of a program P. The supplier\ninsists that consumers run P only on initial state satisﬁes φ. In that case,\nthe supplier promises the consumer that the ﬁnal state of that run satisﬁes\nψ. For a valid ⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n, the latter guarantee applies only when a run\nterminates.\nFor imperative programming, the validation of Hoare triples can be in-\nterpreted as the validation of contracts for method or procedure calls. For\nexample, our program fragment Fac1 may be the ... in the method body\nint factorial (x: int) { ... return y; }\nThe code for this method can be annotated with its contractual assumptions\nand guarantees. These annotations can be checked oﬀ-line by humans, during\ncompile-time or even at run-time in languages such as Eiﬀel. A possible\nformat for such contracts for the method factorial is given in Figure 4.4.\nwhich assigns 0 to v and ρ(w) to all other variables w. Dually, ρ[v \u0011→1]\nassigns 1 to v and ρ(w) to all other variables w.\nFor example, if ρ is the valuation represented by (x, y, Z) ⇒(1, 0, 1) –\nmeaning that ρ(x) = 1, ρ(y) = 0, ρ(Z) = 1 and ρ(v) = 0 for all other vari-\nables v – then ρ[x \u0011→0] is represented by (x, y, Z) ⇒(0, 0, 1), whereas\nρ[Z \u0011→0] is (x, y, Z) ⇒(1, 0, 0). The assumption that valuations assign val-\nues to all variables is rather mathematical, but avoids some complications\nwhich have to be addressed in implementations (see exercise 3 on page 409).\nUpdated valuations allow us to deﬁne the satisfaction relation for all for-\nmulas without ﬁxed points:\nDeﬁnition 6.17 We deﬁne a satisfaction relation ρ ⊨f for formulas f with-\nout ﬁxed-point subformulas with respect to a valuation ρ by structural in-\nduction:\nr ρ ̸⊨0\nr ρ ⊨1\nr ρ ⊨v iﬀρ(v) equals 1\n392\n6 Binary decision diagrams\nr ρ ⊨f iﬀρ ̸⊨f\nr ρ ⊨f + g iﬀρ ⊨f or ρ ⊨g\nr ρ ⊨f · g iﬀρ ⊨f and ρ ⊨g\nr ρ ⊨f ⊕g iﬀρ ⊨(f · g + f · g)\nr ρ ⊨∃x.f iﬀρ[x \u0011→0] ⊨f or ρ[x \u0011→1] ⊨f\nr ρ ⊨∀x.f iﬀρ[x \u0011→0] ⊨f and ρ[x \u0011→1] ⊨f\nr ρ ⊨f[ˆx := ˆx′] iﬀρ[ˆx := ˆx′] ⊨f,\nwhere ρ[ˆx := ˆx′] is the valuation which assigns the same values as ρ, but for\neach xi it assigns ρ(x′\ni).\nThe semantics of boolean quantiﬁcation closely resembles the one for the\nquantiﬁers of predicate logic. The crucial diﬀerence, however, is that boolean\nformulas are only interpreted over the ﬁxed universe of values {0, 1}, whereas\npredicate formulas may take on values in all sorts of ﬁnite or inﬁnite models.\nExample 6.18 Let ρ be such that ρ(x′\n1) equals 0 and ρ(x′\n2) is 1. We evaluate\nρ ⊨(x1 + x2)[ˆx := ˆx′] which holds iﬀρ[ˆx := ˆx′] ⊨(x1 + x2). Thus, we need\nρ[ˆx := ˆx′] ⊨x1 or ρ[ˆx := ˆx′] ⊨x2 to be the case. Now, ρ[ˆx := ˆx′] ⊨x1 cannot\nbe, for this would mean that ρ(x′\n1) equals 1. Since ρ[ˆx := ˆx′] ⊨x2 would\nimply that ρ[ˆx := ˆx′] ̸⊨x2, we infer that ρ[ˆx := ˆx′] ̸⊨x2 because ρ(x′\n2) equals\n1. In summary, we demonstrated that ρ ̸⊨(x1 + x2)[ˆx := ˆx′].\nwe make will therefore be triples, typically looking like\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n(4.5)\nwhich (roughly) means:\nIf the program P is run in a state that satisﬁes φ, then the state\nresulting from P’s execution will satisfy ψ.\nThe speciﬁcation of the program P, to calculate a number whose square is\nless than x, now looks like this:\n\u0001\nx > 0\n\u0002\nP\n\u0001\ny · y < x\n\u0002\n.\n(4.6)\nIt means that, if we run P in a state such that x > 0, then the resulting\nstate will be such that y · y < x. It does not tell us what happens if we run\nP in a state in which x ≤0, the client required nothing for non-positive\nvalues of x. Thus, the programmer is free to do what he or she wants in that\ncase. A program which produces ‘garbage’ in the case that x ≤0 satisﬁes\nthe speciﬁcation, as long as it works correctly for x > 0.\n264\n4 Program verification\nLet us make these notions more precise.\nDeﬁnition 4.3 1.\nThe form\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nof our speciﬁcation is called a Hoare\ntriple, after the computer scientist C. A. R. Hoare.\n2.\nIn (4.5), the formula φ is called the precondition of P and ψ is called the\npostcondition.\n3.\nA store or state of core programs is a function l that assigns to each variable\nx an integer l(x).\n4.\nFor a formula φ of predicate logic with function symbols −(unary), +, −, and ∗\n(binary); and a binary predicate symbols < and =, we say that a state l satisﬁes\nφ or l is a φ-state – written l ⊨φ – iﬀM ⊨l φ from page 128 holds, where l\nis viewed as a look-up table and the model M has as set A all integers and\ninterprets the function and predicate symbols in their standard manner.\n5.\nFor Hoare triples in (4.5), we demand that quantiﬁers in φ and ψ only bind\nvariables that do not occur in the program P.\nExample 4.4 For any state l for which l(x) = −2, l(y) = 5, and l(z) = −1,\nthe relation\n1.\nl ⊨¬(x + y < z) holds since x + y evaluates to −2 + 5 = 3, z evaluates to l(z) =\n−1, and 3 is not strictly less than −1;\n2.\nl ⊨y −x ∗z < z does not hold, since the lefthand expression evaluates to 5 −\npairs C\ndef\n= ((1, 101), (10, 00), (011, 11)) so\ns1\ndef\n= 1\ns2\ndef\n= 10\ns3\ndef\n= 011\nt1\ndef\n= 101\nt2\ndef\n= 00\nt3\ndef\n= 11.\nA solution to the problem is the sequence of indices (1, 3, 2, 3) since s1s3s2s3\nand t1t3t2t3 both equal 101110011. Maybe you think that this problem must\nsurely be solvable; but remember that a computational solution would have\n2.5 Undecidability of predicate logic\n133\nto be a program that solves all such problem instances. Things get a bit\ntougher already if we look at this (solvable) problem:\ns1\ndef\n= 001\ns2\ndef\n= 01\ns3\ndef\n= 01\ns4\ndef\n= 10\nt1\ndef\n= 0\nt2\ndef\n= 011\nt3\ndef\n= 101\nt4\ndef\n= 001\nwhich you are invited to solve by hand, or by writing a program for this\nspeciﬁc instance.\nNote that the same number can occur in the sequence of indices, as hap-\npened in the ﬁrst example in which 3 occurs twice. This means that the\nsearch space we are dealing with is inﬁnite, which should give us some indi-\ncation that the problem is unsolvable. However, we do not formally prove it\nin this book. The proof of the following theorem is due to the mathematician\nA. Church.\nTheorem 2.22 The decision problem of validity in predicate logic is unde-\ncidable: no program exists which, given any φ, decides whether ⊨φ.\nPROOF: As said before, we pretend that validity is decidable for predicate\nlogic and thereby solve the (insoluble) Post correspondence problem. Given\na correspondence problem instance C:\ns1 s2 . . . sk\nt1 t2 . . . tk\nwe need to be able to construct, within ﬁnite space and time and uniformly\nso for all instances, some formula φ of predicate logic such that ⊨φ holds\niﬀthe correspondence problem instance C above has a solution.\nAs function symbols, we choose a constant e and two function symbols\nf0 and f1 each of which requires one argument. We think of e as the empty\nstring, or word, and f0 and f1 symbolically stand for concatenation with 0,\nrespectively 1. So if b1b2 . . . bl is a binary string of bits, we can code that up",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-3",
                            "title": "Partial and Total Correctness",
                            "content": "below hold; justify your answers:\n(a)\n*\nl ⊨(x + y < z) →¬(x ∗y = z)\n(b) l ⊨∀u (u < y) ∨(u ∗z < y ∗z)\n(c)\n*\nl ⊨x + y −z < x ∗y ∗z.\n2.\n*\nFor any φ, ψ and P explain why ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever the relation\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds.\n3. Let the relation P ⊢l ; l′ hold iﬀP’s execution in store l terminates, resulting\nin store l′. Use this formal judgment P ⊢l ; l′ along with the relation l ⊨φ to\ndeﬁne ⊨par and ⊨tot symbolically.\n4. Another reason for proving partial correctness in isolation is that some program\nfragments have the form while (true) {C}. Give useful examples of such pro-\ngram fragments in application programming.\n5.\n*\nUse the proof rule for assignment and logical implication as appropriate to show\nthe validity of\n(a) ⊢par\n\u0001\nx > 0\n\u0002\ny = x + 1\n\u0001\ny > 1\n\u0002\n(b) ⊢par\n\u0001\n⊤\n\u0002\ny = x; y = x + x + y\n\u0001\ny = 3 · x\n\u0002\n(c) ⊢par\n\u0001\nx > 1\n\u0002\na = 1; y = x; y = y - a\n\u0001\ny > 0 ∧x > y\n\u0002\n.\n6.\n*\nWrite down a program P such that\n(a)\n\u0001\n⊤\n\u0002\nP\n\u0001\ny = x + 2\n\u0002\n(b)\n\u0001\n⊤\n\u0002\nP\n\u0001\nz > x + y + 4\n\u0002\nholds under partial correctness; then prove that this is so.\n7. For all instances of Implied in the proof on page 274, specify their corresponding\n⊢AR sequents.\n8. There is a safe way of relaxing the format of the proof rule for assignment: as\nlong as no variable occurring in E gets updated in between the assertion ψ[E/x]\nand the assignment x = E we may conclude ψ right after this assignment. Ex-\nplain why such a proof rule is sound.\n9. (a) Show, by means of an example, that the ‘reversed’ version of the rule Implied\n⊢AR φ →φ′\n\u0001\nφ\n\u0002\nC\n\u0001\nψ\n\u0002\n⊢AR ψ′ →ψ\n\u0001\nφ′\u0002\nC\n\u0001\nψ′\u0002\nImplied Reversed\nis unsound for partial correctness.\n(b) Explain why the modiﬁed rule If-Statement in (4.7) is sound with respect\nto the partial and total satisfaction relation.\n4.6 Exercises\n301\n(c)\n*\nShow that any instance of the modiﬁed rule If-Statement in a proof can\nbe replaced by an instance of the original If-statement and instances of the\nrule Implied. Is the converse true as well?\n10.\n*\nProve the validity of the sequent ⊢par\n\u0001\nin the partial-correctness calculus we develop in this chapter, we say that the\nsequent ⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid.\n2.\nSimilarly, if it can be proved in the total-correctness calculus to be developed\nin this chapter, we say that the sequent ⊢tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid.\nThus, ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds if P is partially correct, while the validity of\n⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nmeans that P can be proved to be partially-correct by our\ncalculus. The ﬁrst one means it is actually correct, while the second one\nmeans it is provably correct according to our calculus.\nIf our calculus is any good, then the relation ⊢par should be contained in\n⊨par! More precisely, we will say that our calculus is sound if, whenever it\ntells us something can be proved, that thing is indeed true. Thus, it is sound\nif it doesn’t tell us that false things can be proved. Formally, we write that\n⊢par is sound if\n⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever ⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid\nfor all φ, ψ and P; and, similarly, ⊢tot is sound if\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever ⊢tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid\nfor all φ, ψ and P. We say that a calculus is complete if it is able to prove\neverything that is true. Formally, ⊢par is complete if\n⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid whenever ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds\nfor all φ, ψ and P; and similarly for ⊢tot being complete.\nIn Chapters 1 and 2, we said that soundness is relatively easy to show,\nsince typically the soundness of individual proof rules can be established\nindependently of the others. Completeness, on the other hand, is harder to\n268\n4 Program verification\nshow since it depends on the entire set of proof rules cooperating together.\nThe same situation holds for the program logic we introduce in this chapter.\nEstablishing its soundness is simply a matter of considering each rule in\nturn – done in exercise 3 on page 303 – whereas establishing its (relative)\ncompleteness is harder and beyond the scope of this book.\n4.2.4 Program variables and logical variables\n\u0002\nwhile (B) {C}\n\u0001\nη ∧¬B\n\u0002\n, i.e. triples in which the postcon-\ndition is the same as the precondition conjoined with ¬B. Suppose that we\nare required to prove\n\u0001\nφ\n\u0002\nwhile (B) {C}\n\u0001\nψ\n\u0002\n(4.10)\nfor some φ and ψ which are not related in that way. How can we use\nPartial-while in a situation like this?\nThe answer is that we must discover a suitable η, such that\n1.\n⊢AR φ →η,\n2.\n⊢AR η ∧¬B →ψ and\n3.\n⊢par\n\u0001\nη\n\u0002\nwhile (B) {C}\n\u0001\nη ∧¬B\n\u0002\nare all valid, where the latter is shown by means of Partial-while. Then,\nImplied infers that (4.10) is a valid partial-correctness triple.\nThe crucial thing, then, is the discovery of a suitable invariant η. It is a\nnecessary step in order to use the proof rule Partial-while and in general it\nrequires intelligence and ingenuity. This contrasts markedly with the case of\nthe proof rules for if-statements and assignments, which are purely mechan-\nical in nature: their usage is just a matter of symbol-pushing and does not\nrequire any deeper insight.\nDiscovery of a suitable invariant requires careful thought about what the\nwhile-statement is really doing. Indeed the eminent computer scientist, the\nlate E. Dijkstra, said that to understand a while-statement is tantamount\nto knowing what its invariant is with respect to given preconditions and\npostconditions for that while-statement.\nThis is because a suitable invariant can be interpreted as saying that the\nintended computation performed by the while-statement is correct up to\nthe current step of the execution. It then follows that, when the execution\n284\n4 Program verification\nterminates, the entire computation is correct. Let us formalize invariants\nand then study how to discover them.\nDeﬁnition 4.15 An invariant of the while-statement while (B) {C} is a\nformula η such that ⊨par\n\u0001\nη ∧B\n\u0002\nC\n\u0001\nη\n\u0002\nholds; i.e. for all states l, if η and B\nare true in l and C is executed from state l and terminates, then η is again\ntrue in the resulting state.\nthing if P ‘loops’ indeﬁnitely. In this section, we extend our proof calculus\nfor partial correctness so that it also proves that programs terminate. In the\nprevious section, we already pointed out that only the syntactic construct\nwhile B {C} could be responsible for non-termination.\n4.4 Proof calculus for total correctness\n293\nTherefore, the proof calculus for total correctness is the same as\nfor partial correctness for all the rules except the rule for while-\nstatements.\nA proof of total correctness for a while-statement will consist of two parts:\nthe proof of partial correctness and a proof that the given while-statement\nterminates. Usually, it is a good idea to prove partial correctness ﬁrst since\nthis often provides helpful insights for a termination proof. However, some\nprograms require termination proofs as premises for establishing partial cor-\nrectness, as can be seen in exercise 1(d) on page 303.\nThe proof of termination usually has the following form. We identify an\ninteger expression whose value can be shown to decrease every time we\nexecute the body of the while-statement in question, but which is always\nnon-negative. If we can ﬁnd an expression with these properties, it follows\nthat the while-statement must terminate; because the expression can only\nbe decremented a ﬁnite number of times before it becomes 0. That is because\nthere is only a ﬁnite number of integer values between 0 and the initial value\nof the expression.\nSuch integer expressions are called variants. As an example, for the pro-\ngram Fac1 of Example 4.2, a suitable variant is x −z. The value of this\nexpression is decremented every time the body of the while-statement is\nexecuted. When it is 0, the while-statement terminates.\nWe can codify this intuition in the following rule for total correctness\nwhich replaces the rule for the while statement:\n\u0001\nη ∧B ∧0 ≤E = E0\n\u0002\nC\n\u0001\nη ∧0 ≤E < E0\n\u0002\n\u0001\nη ∧0 ≤E\n\u0002\nwhile B {C}\n\u0001\nη ∧¬B\n\u0002\nTotal-while.\n(4.15)\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis satisﬁed under partial correctness if, for all states which satisfy φ, the\nstate resulting from P’s execution satisﬁes the postcondition ψ, provided\nthat P actually terminates. In this case, the relation ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds.\nWe call ⊨par the satisfaction relation for partial correctness.\nThus, we insist on ψ being true of the resulting state only if the program P\nhas terminated on an input satisfying φ. Partial correctness is rather a weak\nrequirement, since any program which does not terminate at all satisﬁes its\n266\n4 Program verification\nspeciﬁcation. In particular, the program\nwhile true { x = 0; }\n– which endlessly ‘loops’ and never terminates – satisﬁes all speciﬁcations,\nsince partial correctness only says what must happen if the program termi-\nnates.\nTotal correctness, on the other hand, requires that the program terminates\nin order for it to satisfy a speciﬁcation.\nDeﬁnition 4.6 (Total correctness) We say that the triple\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis\nsatisﬁed under total correctness if, for all states in which P is executed which\nsatisfy the precondition φ, P is guaranteed to terminate and the resulting\nstate satisﬁes the postcondition ψ. In this case, we say that ⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds and call ⊨tot the satisfaction relation of total correctness.\nA program which ‘loops’ forever on all input does not satisfy any spec-\niﬁcation under total correctness. Clearly, total correctness is more useful\nthan partial correctness, so the reader may wonder why partial correctness\nis introduced at all. Proving total correctness usually beneﬁts from prov-\ning partial correctness ﬁrst and then proving termination. So, although our\nprimary interest is in proving total correctness, it often happens that we\nhave to or may wish to split this into separate proofs of partial correctness\nand of termination. Most of this chapter is devoted to the proof of partial\ncorrectness, though we return to the issue of termination in Section 4.4.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-4",
                            "title": "Program Variables and Logical Variables",
                            "content": "z = z + x;\nx = x - 1;\n}\nThis program adds up the ﬁrst x integers and stores the result in z.\nThus,\n\u0001\nx = 3\n\u0002\nSum\n\u0001\nz = 6\n\u0002\n,\n\u0001\nx = 8\n\u0002\nSum\n\u0001\nz = 36\n\u0002\netc. We know from The-\norem 1.31 on page 41 that 1 + 2 + · · · + x = x(x + 1)/2 for all x ≥0, so\n4.3 Proof calculus for partial correctness\n269\nwe would like to express, as a Hoare triple, that the value of z upon\ntermination is x0(x0 + 1)/2 where x0 is the initial value of x. Thus, we write\n\u0001\nx = x0 ∧x ≥0\n\u0002\nSum\n\u0001\nz = x0(x0 + 1)/2\n\u0002\n.\nVariables like x0 in these examples are called logical variables, because they\noccur only in the logical formulas that constitute the precondition and post-\ncondition; they do not occur in the code to be veriﬁed. The state of the\nsystem gives a value to each program variable, but not for the logical vari-\nables. Logical variables take a similar role to the dummy variables of the\nrules for ∀i and ∃e in Chapter 2.\nDeﬁnition 4.10 For a Hoare triple\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n, its set of logical variables\nare those variables that are free in φ or ψ; and don’t occur in P.\n4.3 Proof calculus for partial correctness\nThe proof calculus which we now present goes back to R. Floyd and C.\nA. R. Hoare. In the next subsection, we specify proof rules for each of the\ngrammar clauses for commands. We could go on to use these proof rules\ndirectly, but it turns out to be more convenient to present them in a diﬀerent\nform, suitable for the construction of proofs known as proof tableaux. This\nis what we do in the subsection following the next one.\n4.3.1 Proof rules\nThe proof rules for our calculus are given in Figure 4.1. They should be\ninterpreted as rules that allow us to pass from simple assertions of the form\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nto more complex ones. The rule for assignment is an axiom as\nit has no premises. This allows us to construct some triples out of noth-\ning, to get the proof going. Complete proofs are trees, see page 274 for an\nexample.\nComposition.\nGiven speciﬁcations for the program fragments C1 and C2,\nsay\n\u0001\nφ\n2 Please note the diﬀerence between the formula x! = y, saying that the factorial of x is equal to\ny, and the piece of code x != y which says that x is not equal to y.\n4.2 A framework for software verification\n263\nlanguage does not have any procedures or local variables, the ‘state’ of the\nmachine can be represented simply as a vector of values of all the variables\nused in the program.\nWhat syntax should we use for φR, the formal speciﬁcations of require-\nments for such programs? Because we are interested in the output of the\nprogram, the language should allow us to talk about the variables in the\nstate after the program has executed, using operators like = to express\nequality and < for less than. You should be aware of the overloading of\n=. In code, it represents an assignment instruction; in logical formulas, it\nstands for equality, which we write == within program code.\nFor example, if the informal requirement R says that we should\nCompute a number y whose square is less than the input x.\nthen an appropriate speciﬁcation may be y · y < x. But what if the input x\nis −4? There is no number whose square is less than a negative number, so\nit is not possible to write the program in a way that it will work with all\npossible inputs. If we go back to the client and say this, he or she is quite\nlikely to respond by saying that the requirement is only that the program\nwork for positive numbers; i.e., he or she revises the informal requirement\nso that it now says\nIf the input x is a positive number, compute a number whose square\nis less than x.\nThis means we need to be able to talk not just about the state after the\nprogram executes, but also about the state before it executes. The assertions\nwe make will therefore be triples, typically looking like\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n(4.5)\nwhich (roughly) means:\nIf the program P is run in a state that satisﬁes φ, then the state\nresulting from P’s execution will satisfy ψ.\nThe speciﬁcation of the program P, to calculate a number whose square is\nEstablishing its soundness is simply a matter of considering each rule in\nturn – done in exercise 3 on page 303 – whereas establishing its (relative)\ncompleteness is harder and beyond the scope of this book.\n4.2.4 Program variables and logical variables\nThe variables which we have seen so far in the programs that we verify\nare called program variables. They can also appear in the preconditions and\npostconditions of speciﬁcations. Sometimes, in order to formulate speciﬁca-\ntions, we need to use other variables which do not appear in programs.\nExamples 4.9\n1.\nAnother version of the factorial program might have been Fac2:\ny = 1;\nwhile (x != 0) {\ny = y * x;\nx = x - 1;\n}\nUnlike the previous version, it ‘consumes’ the input x. Nevertheless, it cor-\nrectly calculates the factorial of x and stores the value in y; and we would\nlike to express that as a Hoare triple. However, it is not a good idea to write\n\u0001\nx ≥0\n\u0002\nFac2\n\u0001\ny = x!\n\u0002\nbecause, if the program terminates, then x will be 0 and\ny will be the factorial of the initial value of x.\nWe need a way of remembering the initial value of x, to cope with the fact\nthat it is modiﬁed by the program. Logical variables achieve just that: in the\nspeciﬁcation\n\u0001\nx = x0 ∧x ≥0\n\u0002\nFac2\n\u0001\ny = x0!\n\u0002\nthe x0 is a logical variable and\nwe read it as being universally quantiﬁed in the precondition. Therefore, this\nspeciﬁcation reads: for all integers x0, if x equals x0, x ≥0 and we run the\nprogram such that it terminates, then the resulting state will satisfy y equals\nx0!. This works since x0 cannot be modiﬁed by Fac2 as x0 does not occur in\nFac2.\n2.\nConsider the program Sum:\nz = 0;\nwhile (x > 0) {\nz = z + x;\nx = x - 1;\n}\nThis program adds up the ﬁrst x integers and stores the result in z.\nThus,\n\u0001\nx = 3\n\u0002\nSum\n\u0001\nz = 6\n\u0002\n,\n\u0001\nx = 8\n\u0002\nSum\n\u0001\nz = 36\n\u0002\netc. We know from The-\norem 1.31 on page 41 that 1 + 2 + · · · + x = x(x + 1)/2 for all x ≥0, so\n4.3 Proof calculus for partial correctness\n269\ncore language of most imperative programming languages. Modulo trivial\n260\n4 Program verification\nsyntactic variations, it is a subset of Pascal, C, C++ and Java. Our lan-\nguage consists of assignments to integer- and boolean-valued variables, if-\nstatements, while-statements and sequential compositions. Everything that\ncan be computed by large languages like C and Java can also be computed\nby our language, though perhaps not as conveniently, because it does not\nhave any objects, procedures, threads or recursive data structures. While\nthis makes it seem unrealistic compared with fully blown commercial lan-\nguages, it allows us to focus our discussion on the process of formal program\nveriﬁcation. The features missing from our language could be implemented\non top of it; that is the justiﬁcation for saying that they do not add to the\npower of the language, but only to the convenience of using it. Verifying\nprograms using those features would require non-trivial extensions of the\nproof calculus we present here. In particular, dynamic scoping of variables\npresents hard problems for program-veriﬁcation methods, but this is beyond\nthe scope of this book.\nOur core language has three syntactic domains: integer expressions,\nboolean expressions and commands – the latter we consider to be our\nprograms. Integer expressions are built in the familiar way from variables\nx, y, z, . . . , numerals 0, 1, 2, . . . , −1, −2, . . . and basic operations like addition\n(+) and multiplication (∗). For example,\n5\nx\n4 + (x −3)\nx + (x ∗(y −(5 + z)))\nare all valid integer expressions. Our grammar for generating integer expres-\nsions is\nE ::=\nn | x | (−E) | (E + E) | (E −E) | (E ∗E)\n(4.1)\nwhere n is any numeral in {. . . , −2, −1, 0, 1, 2, . . . } and x is any variable.\nNote that we write multiplication in ‘mathematics’ as 2 · 3, whereas our\ncore language writes 2 ∗3 instead.\nConvention 4.1 In the grammar above, negation −binds more tightly\n‘New Symbolic Model Veriﬁer.’ NuSMV is an Open Source product, is ac-\ntively supported and has a substantial user community. For details on how\nto obtain it, see the bibliographic notes at the end of the chapter.\nNuSMV (sometimes called simply SMV) provides a language for describ-\ning the models we have been drawing as diagrams and it directly checks the\nvalidity of LTL (and also CTL) formulas on those models. SMV takes as\ninput a text consisting of a program describing a model and some speciﬁca-\ntions (temporal logic formulas). It produces as output either the word ‘true’\nif the speciﬁcations hold, or a trace showing why the speciﬁcation is false\nfor the model represented by our program.\nSMV programs consist of one or more modules. As in the programming\nlanguage C, or Java, one of the modules must be called main. Modules can\ndeclare variables and assign to them. Assignments usually give the initial\nvalue of a variable and its next value as an expression in terms of the current\nvalues of variables. This expression can be non-deterministic (denoted by\nseveral expressions in braces, or no assignment at all). Non-determinism is\nused to model the environment and for abstraction.\n192\n3 Verification by model checking\nThe following input to SMV:\nMODULE main\nVAR\nrequest : boolean;\nstatus : {ready,busy};\nASSIGN\ninit(status) := ready;\nnext(status) := case\nrequest : busy;\n1 : {ready,busy};\nesac;\nLTLSPEC\nG(request -> F status=busy)\nconsists of a program and a speciﬁcation. The program has two variables,\nrequest of type boolean and status of enumeration type {ready, busy}:\n0 denotes ‘false’ and 1 represents ‘true.’ The initial and subsequent values\nof variable request are not determined within this program; this conserva-\ntively models that these values are determined by an external environment.\nThis under-speciﬁcation of request implies that the value of variable status\nis partially determined: initially, it is ready; and it becomes busy whenever",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-3",
                    "title": "Proof Calculus for Partial Correctness",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-3-subsection-1",
                            "title": "Proof Rules",
                            "content": "of proof, which states rules for transforming valid sequents into valid sequents.\nFor example, if we have already a proof for the sequent Γ, φ ⊢ψ, then we ob-\ntain a proof of the sequent Γ ⊢φ →ψ by augmenting this very proof with one\napplication of the rule →i. The new approach expresses this as an inference rule\nbetween sequents:\nΓ, φ ⊢ψ\nΓ ⊢φ →ψ →i.\nThe rule ‘assumption’ is written as\nφ ⊢φ assumption\ni.e. the premise is empty. Such rules are called axioms.\n(a) Express all remaining proof rules of Figure 1.2 in such a form. (Hint: some\nof your rules may have more than one premise.)\n(b) Explain why proofs of Γ ⊢ψ in this new system have a tree-like structure\nwith Γ ⊢ψ as root.\n(c) Prove p ∨(p ∧q) ⊢p in your new proof system.\n1.7 Exercises\n81\n7. Show that\n√\n2 cannot be a rational number. Proceed by proof by contradiction:\nassume that\n√\n2 is a fraction k/l with integers k and l ̸= 0. On squaring both sides\nwe get 2 = k2/l2, or equivalently 2l2 = k2. We may assume that any common 2\nfactors of k and l have been cancelled. Can you now argue that 2l2 has a diﬀerent\nnumber of 2 factors from k2? Why would that be a contradiction and to what?\n8. There is an alternative approach to treating negation. One could simply ban the\noperator ¬ from propositional logic and think of φ →⊥as ‘being’ ¬φ. Naturally,\nsuch a logic cannot rely on the natural deduction rules for negation. Which of\nthe rules ¬i, ¬e, ¬¬e and ¬¬i can you simulate with the remaining proof rules\nby letting ¬φ be φ →⊥?\n9. Let us introduce a new connective φ ↔ψ which should abbreviate (φ →ψ) ∧\n(ψ →φ). Design introduction and elimination rules for ↔and show that they\nare derived rules if φ ↔ψ is interpreted as (φ →ψ) ∧(ψ →φ).\nExercises 1.3\nIn order to facilitate reading these exercises we assume below the usual\nconventions about binding priorities agreed upon in Convention 1.3.\n1. Given the following formulas, draw their corresponding parse tree:\n(a) p\n(b)\n*\np ∧q\n(c) p ∧¬q →¬p\n(d)\n*\np ∧(¬q →¬p)\n(e) p →(¬q ∨(q →p))\n(f)\nIn the second rule it is just the other way around: the conclusion ψ has to\nmatch the second conjunct ψ and φ can be any formula. It is important\nto engage in this kind of pattern matching before the application of proof\nrules.\nExample 1.4 Let’s use these rules to prove that p ∧q, r |−q ∧r is valid.\nWe start by writing down the premises; then we leave a gap and write the\n1.2 Natural deduction\n7\nconclusion:\np ∧q\nr\nq ∧r\nThe task of constructing the proof is to ﬁll the gap between the premises\nand the conclusion by applying a suitable sequence of proof rules. In this\ncase, we apply ∧e2 to the ﬁrst premise, giving us q. Then we apply ∧i to this\nq and to the second premise, r, giving us q ∧r. That’s it! We also usually\nnumber all the lines, and write in the justiﬁcation for each line, producing\nthis:\n1\np ∧q\npremise\n2\nr\npremise\n3\nq\n∧e2 1\n4\nq ∧r\n∧i 3, 2\nDemonstrate to yourself that you’ve understood this by trying to show on\nyour own that (p ∧q) ∧r, s ∧t |−q ∧s is valid. Notice that the φ and ψ can\nbe instantiated not just to atomic sentences, like p and q in the example we\njust gave, but also to compound sentences. Thus, from (p ∧q) ∧r we can\ndeduce p ∧q by applying ∧e1, instantiating φ to p ∧q and ψ to r.\nIf we applied these proof rules literally, then the proof above would actu-\nally be a tree with root q ∧r and leaves p ∧q and r, like this:\np ∧q\n∧e2\nq\nr\n∧i\nq ∧r\nHowever, we ﬂattened this tree into a linear presentation which necessitates\nthe use of pointers as seen in lines 3 and 4 above. These pointers allow\nus to recreate the actual proof tree. Throughout this text, we will use the\nﬂattened version of presenting proofs. That way you have to concentrate only\non ﬁnding a proof, not on how to ﬁt a growing tree onto a sheet of paper.\nIf a sequent is valid, there may be many diﬀerent ways of proving it. So if\nyou compare your solution to these exercises with those of others, they need\nnot coincide. The important thing to realise, though, is that any putative\npremise\n2\n∃x (P(x) ∧Q(x))\npremise\nx0\n3\nP(x0) ∧Q(x0)\nassumption\n4\nQ(x0) →R(x0)\n∀x e 1\n5\nQ(x0)\n∧e2 3\n6\nR(x0)\n→e 4, 5\n7\nP(x0)\n∧e1 3\n8\nP(x0) ∧R(x0)\n∧i 7, 6\n9\n∃x (P(x) ∧R(x))\n∃x i 8\n10\n∃x (P(x) ∧R(x))\n∃x e 2, 3−9\nNote the strategy of this proof: We list the two premises. The second premise\nis of use here only if we apply ∃x e to it. This sets up the proof box in\nlines 3−9 as well as the fresh parameter name x0. Since we want to prove\n∃x (P(x) ∧R(x)), this formula has to be the last one in the box (our goal)\nand the rest involves ∀x e and ∃x i.\nThe rules ∀i and ∃e both have the side condition that the dummy variable\ncannot occur outside the box in the rule. Of course, these rules may still be\nnested, by choosing another fresh name (e.g. y0) for the dummy variable. For\nexample, consider the sequent ∃x P(x), ∀x ∀y (P(x) →Q(y)) ⊢∀y Q(y).\n(Look how strong the second premise is, by the way: given any x, y, if P(x),\nthen Q(y). This means that, if there is any object with the property P, then\nall objects shall have the property Q.) Its proof goes as follows: We take an\narbitrary y0 and prove Q(y0); this we do by observing that, since some x\n116\n2 Predicate logic\nsatisﬁes P, so by the second premise any y satisﬁes Q:\n1\n∃x P(x)\npremise\n2\n∀x∀y (P(x) →Q(y))\npremise\ny0\n3\nx0\n4\nP(x0)\nassumption\n5\n∀y (P(x0) →Q(y))\n∀x e 2\n6\nP(x0) →Q(y0)\n∀y e 5\n7\nQ(y0)\n→e 6, 4\n8\nQ(y0)\n∃x e 1, 4−7\n9\n∀y Q(y)\n∀y i 3−8\nThere is no special reason for picking x0 as a name for the dummy variable\nwe use for ∀x and ∃x and y0 as a name for ∀y and ∃y. We do this only\nbecause it makes it easier for us humans. Again, study the strategy of this\nproof. We ultimately have to show a ∀y formula which requires us to use\n∀y i, i.e. we need to open up a proof box (lines 3−8) whose subgoal is to\nprove a generic instance Q(y0). Within that box we want to make use of the\npremise ∃x P(x) which results in the proof box set-up of lines 4−7. Notice\nthat, in line 8, we may well move Q(y0) out of the box controlled by x0.\nNote that the rule Implied allows the precondition to be strengthened (thus,\nwe assume more than we need to), while the postcondition is weakened (i.e.\nwe conclude less than we are entitled to). If we tried to do it the other way\naround, weakening the precondition or strengthening the postcondition, then\nwe would conclude things which are incorrect – see exercise 9(a) on page 300.\nThe rule Implied acts as a link between program logic and a suitable\nextension of predicate logic. It allows us to import proofs in predicate logic\nenlarged with the basic facts of arithmetic, which are required for reasoning\nabout integer expressions, into the proofs in program logic.\n4.3.2 Proof tableaux\nThe proof rules presented in Figure 4.1 are not in a form which is easy\nto use in examples. To illustrate this point, we present an example of a\nproof in Figure 4.2; it is a proof of the triple\n\u0001\n⊤\n\u0002\nFac1\n\u0001\ny = x!\n\u0002\nwhere Fac1\nis the factorial program given in Example 4.2. This proof abbreviates rule\nnames; and drops the bars and names for Assignment as well as sequents\nfor ⊢AR in all applications of the Implied rule. We have not yet presented\nenough information for the reader to complete such a proof on her own,\nbut she can at least use the proof rules in Figure 4.1 to check whether all\nrule instances of that proof are permissible, i.e. match the required pat-\ntern.\n274\n4 Program verification\n\u0001\n1 = 1\u0002\ny = 1\u0001\ny = 1\u0002\ni\n\u0001\n⊤\u0002\ny = 1\u0001\ny = 1\u0002\n\u0001\ny = 1 ∧0 = 0\u0002\nz = 0\u0001\ny = 1 ∧z = 0\u0002\ni\n\u0001\ny = 1\u0002\nz = 0\u0001\ny = 1 ∧z = 0\u0002\nc\n\u0001\n⊤\u0002\ny = 1; z = 0\u0001\ny = 1 ∧z = 0\u0002\n\u0001\ny · (z + 1) = (z + 1)!\u0002\nz = z+1\u0001\ny · z = z!\u0002\ni\n\u0001\ny = z! ∧z ̸= x\u0002\nz = z+1\u0001\ny · z = z!\u0002\n\u0001\ny · z = z!\u0002\ny = y*z\u0001\ny = z!\u0002\nc\n\u0001\ny = z! ∧z ̸= x\u0002\nz = z+1; y = y*z\u0001\ny = z!\u0002\nw\n\u0001\ny = z!\u0002\nwhile (z\n!=\nx) {z = z+1; y = y*z}\u0001\ny = z! ∧z = x\u0002\ni\n\u0001\ny = 1 ∧z = 0\u0002\nwhile (z\n!=\nx) {z = z+1; y = y*z}\u0001\ny = x!\u0002\nc\n\u0001\n⊤\u0002\ny = 1; z = 0; while (z\n!=\nx) {z = z+1; y = y*z}\u0001\ny = x!\u0002\nFigure 4.2. A partial-correctness proof for Fac1 in tree form.\n1\np →q\npremise\n2\n¬p ∨p\nLEM\n3\n¬p\nassumption\n4\n¬p ∨q\n∨i1 3\n5\np\nassumption\n6\nq\n→e 1, 5\n7\n¬p ∨q\n∨i2 6\n8\n¬p ∨q\n∨e 2, 3−4, 5−7\nIt can be diﬃcult to decide which instance of LEM would beneﬁt the progress\nof a proof. Can you re-do the example above with q ∨¬q as LEM?\n1.2.3 Natural deduction in summary\nThe proof rules for natural deduction are summarised in Figure 1.2. The\nexplanation of the rules we have given so far in this chapter is declarative;\nwe have presented each rule and justiﬁed it in terms of our intuition about\nthe logical connectives. However, when you try to use the rules yourself,\nyou’ll ﬁnd yourself looking for a more procedural interpretation; what does\na rule do and how do you use it? For example,\nr ∧i says: to prove φ ∧ψ, you must ﬁrst prove φ and ψ separately and then use\nthe rule ∧i.\nr ∧e1 says: to prove φ, try proving φ ∧ψ and then use the rule ∧e1. Actually,\nthis doesn’t sound like very good advice because probably proving φ ∧ψ will\nbe harder than proving φ alone. However, you might ﬁnd that you already have\nφ ∧ψ lying around, so that’s when this rule is useful. Compare this with the\nexample sequent in Example 1.15.\nr ∨i1 says: to prove φ ∨ψ, try proving φ. Again, in general it is harder to prove\nφ than it is to prove φ ∨ψ, so this will usually be useful only if you’ve already\nmanaged to prove φ. For example, if you want to prove q |−p ∨q, you certainly\nwon’t be able simply to use the rule ∨i1, but ∨i2 will work.\nr ∨e has an excellent procedural interpretation. It says: if you have φ ∨ψ, and you\nwant to prove some χ, then try to prove χ from φ and from ψ in turn. (In those\nsubproofs, of course you can use the other prevailing premises as well.)\nr Similarly, →i says, if you want to prove φ →ψ, try proving ψ from φ (and the\nother prevailing premises).\nr ¬i says: to prove ¬φ, prove ⊥from φ (and the other prevailing premises).\n1.2 Natural deduction\n27\nThe basic rules of natural deduction:\nintroduction\nelimination\n∧\nφ\nψ\nφ ∧ψ\n∧i\nφ ∧ψ\nφ\n∧e1\nφ ∧ψ\nψ\n∧e2\n∨\nφ",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-2",
                            "title": "Proof Tableaux",
                            "content": "Note that the rule Implied allows the precondition to be strengthened (thus,\nwe assume more than we need to), while the postcondition is weakened (i.e.\nwe conclude less than we are entitled to). If we tried to do it the other way\naround, weakening the precondition or strengthening the postcondition, then\nwe would conclude things which are incorrect – see exercise 9(a) on page 300.\nThe rule Implied acts as a link between program logic and a suitable\nextension of predicate logic. It allows us to import proofs in predicate logic\nenlarged with the basic facts of arithmetic, which are required for reasoning\nabout integer expressions, into the proofs in program logic.\n4.3.2 Proof tableaux\nThe proof rules presented in Figure 4.1 are not in a form which is easy\nto use in examples. To illustrate this point, we present an example of a\nproof in Figure 4.2; it is a proof of the triple\n\u0001\n⊤\n\u0002\nFac1\n\u0001\ny = x!\n\u0002\nwhere Fac1\nis the factorial program given in Example 4.2. This proof abbreviates rule\nnames; and drops the bars and names for Assignment as well as sequents\nfor ⊢AR in all applications of the Implied rule. We have not yet presented\nenough information for the reader to complete such a proof on her own,\nbut she can at least use the proof rules in Figure 4.1 to check whether all\nrule instances of that proof are permissible, i.e. match the required pat-\ntern.\n274\n4 Program verification\n\u0001\n1 = 1\u0002\ny = 1\u0001\ny = 1\u0002\ni\n\u0001\n⊤\u0002\ny = 1\u0001\ny = 1\u0002\n\u0001\ny = 1 ∧0 = 0\u0002\nz = 0\u0001\ny = 1 ∧z = 0\u0002\ni\n\u0001\ny = 1\u0002\nz = 0\u0001\ny = 1 ∧z = 0\u0002\nc\n\u0001\n⊤\u0002\ny = 1; z = 0\u0001\ny = 1 ∧z = 0\u0002\n\u0001\ny · (z + 1) = (z + 1)!\u0002\nz = z+1\u0001\ny · z = z!\u0002\ni\n\u0001\ny = z! ∧z ̸= x\u0002\nz = z+1\u0001\ny · z = z!\u0002\n\u0001\ny · z = z!\u0002\ny = y*z\u0001\ny = z!\u0002\nc\n\u0001\ny = z! ∧z ̸= x\u0002\nz = z+1; y = y*z\u0001\ny = z!\u0002\nw\n\u0001\ny = z!\u0002\nwhile (z\n!=\nx) {z = z+1; y = y*z}\u0001\ny = z! ∧z = x\u0002\ni\n\u0001\ny = 1 ∧z = 0\u0002\nwhile (z\n!=\nx) {z = z+1; y = y*z}\u0001\ny = x!\u0002\nc\n\u0001\n⊤\u0002\ny = 1; z = 0; while (z\n!=\nx) {z = z+1; y = y*z}\u0001\ny = x!\u0002\nFigure 4.2. A partial-correctness proof for Fac1 in tree form.\nwhile-statements was presented in the following form in Figure 4.1 – here\nwe have written η instead of ψ:\n\u0001\nη ∧B\n\u0002\nC\n\u0001\nη\n\u0002\n\u0001\nη\n\u0002\nwhile B {C}\n\u0001\nη ∧¬B\n\u0002 Partial-while.\n(4.9)\nBefore we look at how Partial-while will be represented in proof tableaux,\nlet us look in more detail at the ideas behind this proof rule. The formula η is\nchosen to be an invariant of the body C of the while-statement: provided the\nboolean guard B is true, if η is true before we start C, and C terminates,\nthen it is also true at the end. This is what the premise\n\u0001\nη ∧B\n\u0002\nC\n\u0001\nη\n\u0002\nexpresses.\nNow suppose the while-statement executes a terminating run from a state\nthat satisﬁes η; and that the premise of (4.9) holds.\nr If B is false as soon as we embark on the while-statement, then we do not execute\nC at all. Nothing has happened to change the truth value of η, so we end the\nwhile-statement with η ∧¬B.\n4.3 Proof calculus for partial correctness\n283\nr If B is true when we embark on the while-statement, we execute C. By the\npremise of the rule in (4.9), we know η is true at the end of C.\n– if B is now false, we stop with η ∧¬B.\n– if B is true, we execute C again; η is again re-established. No matter how\nmany times we execute C in this way, η is re-established at the end of each\nexecution of C. The while-statement terminates if, and only if, B is false after\nsome ﬁnite (zero including) number of executions of C, in which case we have\nη ∧¬B.\nThis argument shows that Partial-while is sound with respect to the sat-\nisfaction relation for partial correctness, in the sense that anything we prove\nusing it is indeed true. However, as it stands it allows us to prove only things\nof the form\n\u0001\nη\n\u0002\nwhile (B) {C}\n\u0001\nη ∧¬B\n\u0002\n, i.e. triples in which the postcon-\ndition is the same as the precondition conjoined with ¬B. Suppose that we\nare required to prove\n\u0001\nφ\n\u0002\nwhile (B) {C}\n\u0001\nψ\n\u0002\n(4.10)\nfor some φ and ψ which are not related in that way. How can we use\nPartial-while in a situation like this?\n6.5 Exercises\nExercises 6.1\n1. Write down the truth tables for the boolean formulas in Example 6.2 on page 359.\nIn your table, you may use 0 and 1, or F and T, whatever you prefer. What truth\nvalue does the boolean formula of item (4) on page 359 compute?\n2. ⊕is the exclusive-or: x ⊕y\ndef\n= 1 if the values of x and y are diﬀerent; otherwise,\nx ⊕y\ndef\n= 0. Express this in propositional logic, i.e. ﬁnd a formula φ having the\nsame truth table as ⊕.\n3.\n*\nWrite down a boolean formula f(x, y) in terms of ·, +, ¯, 0 and 1, such that f\nhas the same truth table as p →q.\n4. Write down a BNF for the syntax of boolean formulas based on the operations\nin Deﬁnition 6.1.\nExercises 6.2\n1.\n*\nSuppose we swap all dashed and solid lines in the binary decision tree of Fig-\nure 6.2. Write out the truth table of the resulting binary decision tree and ﬁnd\na formula for it.\n6.5 Exercises\n399\n2.\n*\nConsider the following truth table:\np\nq\nr\nφ\nT\nT\nT\nT\nT\nT\nF\nF\nT\nF\nT\nF\nT\nF\nF\nF\nF\nT\nT\nT\nF\nT\nF\nF\nF\nF\nT\nT\nF\nF\nF\nF\nWrite down a binary decision tree which represents the boolean function speciﬁed\nin this truth table.\n3. Construct a binary decision tree for the boolean function speciﬁed in Figure 6.2,\nbut now the root should be a y-node and its two successors should be x-nodes.\n4. Consider the following boolean function given by its truth table:\nx\ny\nz\nf(x, y, z)\n1\n1\n1\n0\n1\n1\n0\n1\n1\n0\n1\n0\n1\n0\n0\n1\n0\n1\n1\n0\n0\n1\n0\n0\n0\n0\n1\n0\n0\n0\n0\n1\n(a) Construct a binary decision tree for f(x, y, z) such that the root is an x-node\nfollowed by y- and then z-nodes.\n(b) Construct another binary decision tree for f(x, y, z), but now let its root be\na z-node followed by y- and then x-nodes.\n5. Let T be a binary decision tree for a boolean function f(x1, x2, . . . , xn) of n\nboolean variables. Suppose that every variable occurs exactly once as one travels\ndown on any path of the tree T. Use mathematical induction to show that T has\n2n+1 −1 nodes.\nExercises 6.3\n1.\n*\nBefore a discussion of how to ﬁnd invariants for while-statement, we now\nlook at the assignment and the if-statement to see how the weakest precon-\ndition is calculated for each one.\nAssignment.\nThe assignment axiom is easily adapted to work for proof\ntableaux. We write it thus:\n4 φ is weaker than ψ means that φ is implied by ψ in predicate logic enlarged with the basic\nfacts about arithmetic: the sequent ⊢AR ψ →φ is valid. We want the weakest formula, because\nwe want to impose as few constraints as possible on the preceding code. In some cases, espe-\ncially those involving while-statements, it might not be possible to extract the logically weakest\nformula. We just need one which is suﬃciently weak to allow us to complete the proof at hand.\n4.3 Proof calculus for partial correctness\n277\n\u0001\nψ[E/x]\n\u0002\nx = E\n\u0001\nψ\n\u0002\nAssignment\nThe justiﬁcation is written against the ψ, since, once the proof has been con-\nstructed, we want to read it in a forwards direction. The construction itself\nproceeds in a backwards direction, because that is the way the assignment\naxiom facilitates.\nImplied.\nIn tableau form, the Implied rule allows us to write one formula φ2\ndirectly underneath another one φ1 with no code in between, provided that\nφ1 implies φ2 in that the sequent ⊢AR φ1 →φ2 is valid. Thus, the Implied\nrule acts as an interface between predicate logic with arithmetic and program\nlogic. This is a surprising and crucial insight. Our proof calculus for partial\ncorrectness is a hybrid system which interfaces with another proof calculus\nvia the Implied proof rule only.\nWhen we appeal to the Implied rule, we will usually not explicitly write\nout the proof of the implication in predicate logic, for this chapter focuses\non the program logic. Mostly, the implications we typically encounter will\nbe easy to verify.\nThe Implied rule is often used to simplify formulas that are generated by\napplications of the other rules. It is also used when the weakest precondition\n*\n∀x P(a, x, x), ∀x ∀y ∀z (P(x, y, z) →P(f(x), y, f(z)))\n|−∃z P(f(a), z, f(f(a)))\n(c)\n*\n∀y Q(b, y), ∀x ∀y (Q(x, y) →Q(s(x), s(y)))\n|−∃z (Q(b, z) ∧Q(z, s(s(b))))\n(d) ∀x ∀y ∀z (S(x, y) ∧S(y, z) →S(x, z)), ∀x ¬S(x, x)\n⊢∀x ∀y (S(x, y) →¬S(y, x))\n(e) ∀x (P(x) ∨Q(x)), ∃x ¬Q(x), ∀x (R(x) →¬P(x)) ⊢∃x ¬R(x)\n(f) ∀x (P(x) →(Q(x) ∨R(x))), ¬∃x (P(x) ∧R(x)) ⊢∀x (P(x) →Q(x))\n(g) ∃x ∃y (S(x, y) ∨S(y, x)) ⊢∃x ∃y S(x, y)\n(h) ∃x (P(x) ∧Q(x)), ∀y (P(x) →R(x)) ⊢∃x (R(x) ∧Q(x)).\n14. Translate the following argument into a sequent in predicate logic using a suit-\nable set of predicate symbols:\nIf there are any tax payers, then all politicians are tax payers.\nIf there are any philanthropists, then all tax payers are philan-\nthropists. So, if there are any tax-paying philanthropists, then\nall politicians are philanthropists.\nNow come up with a proof of that sequent in predicate logic.\n2.8 Exercises\n163\n15. Discuss in what sense the equivalences of Theorem 2.13 (page 117) form the\nbasis of an algorithm which, given φ, pushes quantiﬁers to the top of the for-\nmula’s parse tree. If the result is ψ, what can you say about commonalities and\ndiﬀerences between φ and ψ?\nExercises 2.4\n1.\n*\nConsider the formula φ\ndef\n= ∀x ∀y Q(g(x, y), g(y, y), z), where Q and g have arity\n3 and 2, respectively. Find two models M and M′ with respective environments\nl and l′ such that M ⊨l φ but M′ ̸⊨l′ φ.\n2. Consider the sentence φ\ndef\n= ∀x ∃y ∃z (P(x, y) ∧P(z, y) ∧(P(x, z) →P(z, x))).\nWhich of the following models satisﬁes φ?\n(a) The model M consists of the set of natural numbers with P M def\n= {(m, n) |\nm < n}.\n(b) The model M′ consists of the set of natural numbers with P M′ def\n= {(m, 2 ∗\nm) | m natural number}.\n(c) The model M′′ consists of the set of natural numbers with P M′′ def\n= {(m, n) |\nm < n + 1}.\n3. Let P be a predicate with two arguments. Find a model which satisﬁes the\nsentence ∀x ¬P(x, x); also ﬁnd one which doesn’t.\n4. Consider the sentence ∀x(∃yP(x, y) ∧(∃zP(z, x) →∀yP(x, y))). Please simu-",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-3",
                            "title": "A Case Study: Minimal-Sum Section",
                            "content": "this has to be taken into account by the calculus.\n288\n4 Program verification\nwrite Si,j for the sum of that section: a[i] + a[i + 1] + · · · + a[j]. A minimal-\nsum section is a section a[i], . . . , a[j] of a such that the sum Si,j is less than\nor equal to the sum Si′,j′ of any other section a[i′], . . . , a[j′] of a.\nExample 4.19 Let us illustrate these concepts on the example integer array\n[−1, 3, 15, −6, 4, −5]. Both [3, 15, −6] and [−6] are sections, but [3, −6, 4]\nisn’t since 15 is missing. A minimal-sum section for this particular array is\n[−6, 4, −5] with sum −7; it is the only minimal-sum section in this case.\nIn general, minimal-sum sections need not be unique. For example, the\narray [1, −1, 3, −1, 1] has two minimal-sum sections [1, −1] and [−1, 1] with\nminimal sum 0.\nThe task at hand is to\nr write a program Min Sum, written in our core programming language extended\nwith integer arrays, which computes the sum of a minimal-sum section of a given\narray;\nr make the informal requirement of this problem, given in the previous item, into\na formal speciﬁcation about the behaviour of Min Sum;\nr use our proof calculus for partial correctness to show that Min Sum satisﬁes those\nformal speciﬁcations provided that it terminates.\nThere is an obvious program to do the job: we could list all the possible\nsections of a given array, then traverse that list to compute the sum of\neach section and keep the recent minimal sum in a storage location. For the\nexample array [−1, 3, −2], this results in the list\n[−1], [−1, 3], [−1, 3, −2], [3], [3, −2], [−2]\nand we see that only the last section [−2] produces the minimal sum −2.\nThis idea can easily be coded in our core programming language, but it\nhas a serious drawback: the number of sections of a given array of size n is\nproportional to the square of n; if we also have to sum all those, then our task\nhas worst-case time complexity of the order n · n2 = n3. Computationally,\nthe range of indexes of the array and t stores the minimal sum of sections\nthat end at a[k] – whenever the control ﬂow of the program is about to\nevaluate the boolean expression of its while-statement. As each new value is\nexamined, we can either add it to the current minimal sum, or decide that a\nlower minimal sum can be obtained by starting a new section. The variable\ns stores the minimal sum seen so far; it is computed as the minimum we\nhave seen so far in the last step, or the minimal sum of sections that end at\nthe current point.\nAs you can see, it not intuitively clear that this program is correct, war-\nranting the use of our partial-correctness calculus to prove its correctness.\nTesting the program with a few examples is not suﬃcient to ﬁnd all mis-\ntakes, however, and the reader would rightly not be convinced that this\nprogram really does compute the minimal-sum section in all cases. So let\nus try to use the partial-correctness calculus introduced in this chapter to\nprove it.\n290\n4 Program verification\nWe formalise our requirement of the program as two speciﬁcations6, writ-\nten as Hoare triples.\nS1.\n\u0001\n⊤\n\u0002\nMin Sum\n\u0001\n∀i, j (0 ≤i ≤j < n →s ≤Si,j)\n\u0002\n.\nIt says that, after the program terminates, s is less than or equal to, the\nsum of any section of the array. Note that i and j are logical variables\nin that they don’t occur as program variables.\nS2.\n\u0001\n⊤\n\u0002\nMin Sum\n\u0001\n∃i, j (0 ≤i ≤j < n ∧s = Si,j)\n\u0002\n,\nwhich says that there is a section whose sum is s.\nIf there is a section whose sum is s and no section has a sum less than s,\nthen s is the sum of a minimal-sum section: the ‘conjunction’ of S1 and S2\ngive us the property we want.\nLet us ﬁrst prove S1. This begins with seeking a suitable invariant. As\nalways, the following characteristics of invariants are a useful guide:\nr Invariants express the fact that the computation performed so far by the while-\nstatement is correct.\nr Invariants typically have the same form as the desired postcondition of the while-\nstatement.\nhas a serious drawback: the number of sections of a given array of size n is\nproportional to the square of n; if we also have to sum all those, then our task\nhas worst-case time complexity of the order n · n2 = n3. Computationally,\nthis is an expensive price to pay, so we should inspect the problem more\nclosely in order to see whether we can do better.\nCan we compute the minimal sum over all sections in time proportional\nto n, by passing through the array just once? Intuitively, this seems diﬃcult,\nsince if we store just the minimal sum seen so far as we pass through the\narray, we may miss the opportunity of some large negative numbers later on\nbecause of some large positive numbers we encounter en route. For example,\n4.3 Proof calculus for partial correctness\n289\nsuppose the array is\n[−8, 3, −65, 20, 45, −100, −8, 17, −4, −14].\nShould we settle for −8 + 3 −65, or should we try to take advantage of the\n−100 – remembering that we can pass through the array only once? In this\ncase, the whole array is a section that gives us the smallest sum, but it\nis diﬃcult to see how a program which passes through the array just once\ncould detect this.\nThe solution is to store two values during the pass: the minimal sum seen\nso far (s in the program below) and also the minimal sum seen so far of\nall sections which end at the current point in the array (t below). Here is a\nprogram that is intended to do this:\nk = 1;\nt = a[0];\ns = a[0];\nwhile (k != n) {\nt = min(t + a[k], a[k]);\ns = min(s,t);\nk = k + 1;\n}\nwhere min is a function which computes the minimum of its two arguments\nas speciﬁed in exercise 10 on page 301. The variable k proceeds through\nthe range of indexes of the array and t stores the minimal sum of sections\nthat end at a[k] – whenever the control ﬂow of the program is about to\nevaluate the boolean expression of its while-statement. As each new value is\nexamined, we can either add it to the current minimal sum, or decide that a\n\u0001\nassume\n\u0002\nmethod\n\u0001\nguarantee\n\u0002\nvery\nmuch in the style developed in this chapter, except that for all method\ninvocations within that body we can assume that their Hoare triples are\ncorrect.\nExample 4.21 We have already used program validation by contract in our\nveriﬁcation of the program that computes the minimal sum for all sections\nof an array in Figure 4.3 on page 291. Let us focus on the proof fragment\n(Inv1(min(s, min(t + a[k], a[k])), k + 1) ∧Inv2(min(t + a[k], a[k]), k + 1))\nImplied (Lemma 4.20)\nt = min(t + a[k], a[k]);\n(Inv1(min(s, t), k + 1) ∧Inv2(t, k + 1))\nAssignment\ns = min(s,t);\n(Inv1(s, k + 1) ∧Inv2(t, k + 1))\nAssignment\nIts last line serves as the postcondition which gets pushed through the as-\nsignment s = min(s,t). But min(s,t) is a method call whose guarantees\nare speciﬁed as ‘result equals min(s, t),’ where min(s, t) is a mathematical\nnotation for the smaller of the numbers s and t. Thus, the rule Assignment\ndoes not substitute the syntax of the method invocation min(s,t) for all\noccurrences of s in Inv1(s, k + 1) ∧Inv2(t, k + 1), but changes all such s to\nthe guarantee min(s, t) of the method call min(s,t) – program validation\n4.6 Exercises\n299\nby contract in action! A similar comment applies for the assignment t =\nmin(t + a[k], a[k]).\nProgram validation by contract has to be used wisely to avoid circular\nreasoning. If each method is a node in a graph, let’s draw an edge from\nmethod n to method m iﬀwithin the body of n there is a call to method m.\nFor program validation by contract to be sound, we require that there be\nno cycles in this method-dependency graph.\n4.6 Exercises\nExercises 4.1\n1.\n*\nIf you already have written computer programs yourself, assemble for each pro-\ngramming language you used a list of features of its software development envi-\nronment (compiler, editor, linker, run-time environment etc) that may improve\nthe likelihood that your programs work correctly. Try to rate the eﬀectiveness of\neach such feature.\nan array.\n(a) Adapt the program from page 289 so that it computes the maximal sum of\nthese sections.\n(b) Prove the partial correctess of your modiﬁed program.\n(c) Which aspects of the correctness proof given in Figure 4.3 (page 291) can\nbe ‘re-used?’\nExercises 4.4\n1. Prove the validity of the following total-correctness sequents:\n(a)\n*\n⊢tot\n\u0001\nx ≥0\n\u0002\nCopy1\n\u0001\nx = y\n\u0002\n(b)\n*\n⊢tot\n\u0001\ny ≥0\n\u0002\nMulti1\n\u0001\nz = x · y\n\u0002\n(c) ⊢tot\n\u0001\n(y = y0) ∧(y ≥0)\n\u0002\nMulti2\n\u0001\nz = x · y0\n\u0002\n(d)\n*\n⊢tot\n\u0001\nx ≥0\n\u0002\nDownfac\n\u0001\ny = x!\n\u0002\n(e)\n*\n⊢tot\n\u0001\nx ≥0\n\u0002\nCopy2\n\u0001\nx = y\n\u0002\n, does your invariant have an active part in secur-\ning correctness?\n(f) ⊢tot\n\u0001\n¬(y = 0)\n\u0002\nDiv\n\u0001\n(x = d · y + r) ∧(r < y)\n\u0002\n.\n2. Prove total correctness of S1 and S2 for Min Sum.\n3. Prove that ⊢par is sound for ⊨par. Just like in Section 1.4.3, it suﬃces to assume\nthat the premises of proof rules are instances of ⊨par. Then, you need to prove\nthat their respective conclusion must be an instance of ⊨par as well.\n4. Prove that ⊢tot is sound for ⊨tot.\n5. Implement program Collatz in a programming language of your choice such\nthat the value of x is the program’s input and the ﬁnal value of c its output.\nTest your program on a range of inputs. Which is the biggest integer for which\nyour program terminates without raising an exception or dumping the core?\n6. A function over integers f : I →I is aﬃne iﬀthere are integers a and b such that\nf(x) = a · x + b for all x ∈I. The else-branch of the program Collatz assigns to\nc the value f(c), where f is an aﬃne function with a = 3 and b = 1.\n(a) Write an parameterized implementation of Collatz in which you can initially\nspecify the values of a and b either statically or through keyboard input such\nthat the else-branch assigns to c the value of f(c).\n(b) Determine for which pairs (a, b) ∈I × I the set Pos\ndef\n= {x ∈I | 0 < x} is in-\nvariant under the aﬃne function f(x) = a · x + b: for all x ∈Pos, f(x) ∈Pos.\n(c)\n*\nFind an aﬃne function that leaves Pos invariant, but not the set Odd\ndef\n= {x ∈",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-4",
                    "title": "Proof Calculus for Total Correctness",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-5",
                    "title": "Programming by Contract",
                    "content": null,
                    "children": []
                }
            ]
        },
        {
            "id": "chapter-1",
            "title": "Modal Logics and Agents",
            "content": null,
            "children": [
                {
                    "id": "chapter-1-section-1",
                    "title": "Modes of Truth",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-2",
                    "title": "Basic Modal Logic",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-2-subsection-1",
                            "title": "Syntax",
                            "content": "(4.1)\nwhere n is any numeral in {. . . , −2, −1, 0, 1, 2, . . . } and x is any variable.\nNote that we write multiplication in ‘mathematics’ as 2 · 3, whereas our\ncore language writes 2 ∗3 instead.\nConvention 4.1 In the grammar above, negation −binds more tightly\nthan multiplication ∗, which binds more tightly than subtraction −and\naddition +.\nSince if-statements and while-statements contain conditions in them, we\nalso need a syntactic domain B of boolean expressions. The grammar in\n4.2 A framework for software verification\n261\nBackus Naur form\nB ::= true | false | (!B) | (B & B)\n| (B || B) | (E < E)\n(4.2)\nuses ! for the negation, & for conjunction and || for disjunction of\nboolean expressions. This grammar may be freely expanded by operators\nwhich are deﬁnable in terms of the above. For example, the test for equal-\nity1 E1 == E2 may be expressed via !(E1 < E2) & !(E2 < E1). We gener-\nally make use of shorthand notation whenever this is convenient. We also\nwrite (E1 != E2) to abbreviate !(E1 == E2). We will also assume the usual\nbinding priorities for logical operators stated in Convention 1.3 on page 5.\nBoolean expressions are built on top of integer expressions since the last\nclause of (4.2) mentions integer expressions.\nHaving integer and boolean expressions at hand, we can now deﬁne the\nsyntactic domain of commands. Since commands are built from simpler com-\nmands using assignments and the control structures, you may think of com-\nmands as the actual programs. We choose as grammar for commands\nC\n::=\nx = E | C; C | if B {C} else {C} | while B {C}\n(4.3)\nwhere the braces { and } are to mark the extent of the blocks of code in the\nif-statement and the while-statement, as in languages such as C and Java.\nThey can be omitted if the blocks consist of a single statement. The intuitive\nmeaning of the programming constructs is the following:\n1.\nThe atomic command x = E is the usual assignment statement; it evaluates\n2 Please note the diﬀerence between the formula x! = y, saying that the factorial of x is equal to\ny, and the piece of code x != y which says that x is not equal to y.\n4.2 A framework for software verification\n263\nlanguage does not have any procedures or local variables, the ‘state’ of the\nmachine can be represented simply as a vector of values of all the variables\nused in the program.\nWhat syntax should we use for φR, the formal speciﬁcations of require-\nments for such programs? Because we are interested in the output of the\nprogram, the language should allow us to talk about the variables in the\nstate after the program has executed, using operators like = to express\nequality and < for less than. You should be aware of the overloading of\n=. In code, it represents an assignment instruction; in logical formulas, it\nstands for equality, which we write == within program code.\nFor example, if the informal requirement R says that we should\nCompute a number y whose square is less than the input x.\nthen an appropriate speciﬁcation may be y · y < x. But what if the input x\nis −4? There is no number whose square is less than a negative number, so\nit is not possible to write the program in a way that it will work with all\npossible inputs. If we go back to the client and say this, he or she is quite\nlikely to respond by saying that the requirement is only that the program\nwork for positive numbers; i.e., he or she revises the informal requirement\nso that it now says\nIf the input x is a positive number, compute a number whose square\nis less than x.\nThis means we need to be able to talk not just about the state after the\nprogram executes, but also about the state before it executes. The assertions\nwe make will therefore be triples, typically looking like\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\n(4.5)\nwhich (roughly) means:\nIf the program P is run in a state that satisﬁes φ, then the state\nresulting from P’s execution will satisfy ψ.\nThe speciﬁcation of the program P, to calculate a number whose square is\ntype Number. The symbol ^ can be applied to a binary relation r : T -> T\nsuch that ^r has again type T -> T and denotes the transitive closure of r.\nIn this case, T equals Number and r equals Ord[Number].prev.\n156\n2 Predicate logic\nBut what shall me make of the latter expression? It assumes that the mod-\nule contains a statement open std/ord which opens the signature speciﬁca-\ntions from another module in ﬁle ord.als of the library std. That module\ncontains a signature named Ord which has a type variable as a parameter; it\nis polymorphic. The expression Ord[Number] instantiates that type variable\nwith the type Number, and then invokes the prev relation of that signa-\nture with that type, where prev is constrained in std/ord to be a linear\norder. The net eﬀect is that we create a linear order on Number such that\nn.prev is the previous element of n with respect to that order. Therefore,\nn.^prev lists all elements that are smaller than n in that order. Please reread\nthe body of that fun-statement to convince yourself that it states what is\nintended.\nSince fun-statements can be invoked with instances of their parameters,\nwe can write the desired simulation based on HighestVersionPolicy:\nfun AGuidedSimulation(P,P’,P’’ : PDS, c1, c2 : Component) {\nAddComponent(P,P’,c1)\nRemoveComponent(P,P’’,c2)\nHighestVersionPolicy(P)\nHighestVersionPolicy(P’) HighestVersionPolicy(P’’)\n} run AGuidedSimulation for 3\nAlloy’s analyzer generates a scenario for this simulation, which amounts\nto two diﬀerent operation snapshots originating in P such that all three\nparticipating PDSs schedule according to HighestVersionPolicy. Can you\nspot why we had to work with two components c1 and c2?\nWe conclude this case study by pointing out limitations of Alloy and its\nanalyzer. In order to be able to use a SAT solver for propositional logic\nas an analysis engine, we can only check or run formulas of existential or\nuniversal second-order logic in the bodies of assertions or in the bodies of\nreplaced by every student’s name in turn. Similarly, when trying to codify\na sentence having to do with the execution of a program, it would be rather\nlaborious to have to write down every state of the computer. Therefore,\nwe employ the concept of a variable. Variables are written u, v, w, x, y, z, . . .\nor x1, y3, u5, . . . and can be thought of as place holders for concrete values\n(like a student, or a program state). Using variables, we can now specify the\nmeanings of S, I and Y more formally:\nS(x) :\nx is a student\nI(x) :\nx is an instructor\nY (x, y) :\nx is younger than y.\nNote that the names of the variables are not important, provided that we\nuse them consistently. We can state the intended meaning of I by writing\nI(y) :\ny is an instructor\nor, equivalently, by writing\nI(z) :\nz is an instructor.\nVariables are mere place holders for objects. The availability of variables is\nstill not suﬃcient for capturing the essence of the example sentence above.\nWe need to convey the meaning of ‘Every student x is younger than some\ninstructor y.’ This is where we need to introduce quantiﬁers ∀(read: ‘for\nall’) and ∃(read: ‘there exists’ or ‘for some’) which always come attached\nto a variable, as in ∀x (‘for all x’) or in ∃z (‘there exists z’, or ‘there is some\nz’). Now we can write the example sentence in an entirely symbolic way as\n∀x (S(x) →(∃y (I(y) ∧Y (x, y)))).\n2.1 The need for a richer language\n95\nActually, this encoding is rather a paraphrase of the original sentence. In\nour example, the re-translation results in\nFor every x, if x is a student, then there is some y which is an\ninstructor such that x is younger than y.\nDiﬀerent predicates can have a diﬀerent number of arguments. The predi-\ncates S and I have just one (they are called unary predicates), but predicate\nY requires two arguments (it is called a binary predicate). Predicates with\nany ﬁnite number of arguments are possible in predicate logic.\nAnother example is the sentence\nNot all birds can ﬂy.\nr If φ is a formula and x is a variable, then (∀x φ) and (∃x φ) are formulas.\nr Nothing else is a formula.\nNote how the arguments given to predicates are always terms. This can also\nbe seen in the Backus Naur form (BNF) for predicate logic:\nφ ::= P(t1, t2, . . . , tn) | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (∀x φ) | (∃x φ)\n(2.2)\nwhere P ∈P is a predicate symbol of arity n ≥1, ti are terms over F and x\nis a variable. Recall that each occurrence of φ on the right-hand side of the\n::= stands for any formula already constructed by these rules. (What role\ncould predicate symbols of arity 0 play?)\n2.2 Predicate logic as a formal language\n101\n∀x\n∧\n→\nS\nP\nQ\nx\ny\nx\nx\nFigure 2.1. A parse tree of a predicate logic formula.\nConvention 2.4 For convenience, we retain the usual binding priorities\nagreed upon in Convention 1.3 and add that ∀y and ∃y bind like ¬. Thus,\nthe order is:\nr ¬, ∀y and ∃y bind most tightly;\nr then ∨and ∧;\nr then →, which is right-associative.\nWe also often omit brackets around quantiﬁers, provided that doing so in-\ntroduces no ambiguities.\nPredicate logic formulas can be represented by parse trees. For example,\nthe parse tree in Figure 2.1 represents the formula ∀x ((P(x) →Q(x)) ∧\nS(x, y)).\nExample 2.5 Consider translating the sentence\nEvery son of my father is my brother.\ninto predicate logic. As before, the design choice is whether we represent\n‘father’ as a predicate or as a function symbol.\n1.\nAs a predicate. We choose a constant m for ‘me’ or ‘I,’ so m is a term, and we\nchoose further {S, F, B} as the set of predicates with meanings\n102\n2 Predicate logic\nS(x, y) :\nx is a son of y\nF(x, y) :\nx is the father of y\nB(x, y) :\nx is a brother of y.\nThen the symbolic encoding of the sentence above is\n∀x ∀y (F(x, m) ∧S(y, x) →B(y, m))\n(2.3)\nsaying: ‘For all x and all y, if x is a father of m and if y is a son of x, then y is\na brother of m.’\n2.\nAs a function. We keep m, S and B as above and write f for the function which,",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-2",
                            "title": "Semantics",
                            "content": "set of n-tuples over A, to A; and\n4.\nfor each P ∈P with arity n > 0, a subset P M ⊆An of n-tuples over A.\n2.4 Semantics of predicate logic\n125\nThe distinction between f and fM and between P and P M is most im-\nportant. The symbols f and P are just that: symbols, whereas fM and\nP M denote a concrete function (or element) and relation in a model M,\nrespectively.\nExample 2.15 Let F\ndef\n= {i} and P\ndef\n= {R, F}; where i is a constant, F a\npredicate symbol with one argument and R a predicate symbol with two\narguments. A model M contains a set of concrete elements A – which may be\na set of states of a computer program. The interpretations iM, RM, and F M\nmay then be a designated initial state, a state transition relation, and a set\nof ﬁnal (accepting) states, respectively. For example, let A\ndef\n= {a, b, c}, iM def\n=\na, RM def\n= {(a, a), (a, b), (a, c), (b, c), (c, c)}, and F M def\n= {b, c}. We informally\ncheck some formulas of predicate logic for this model:\n1.\nThe formula\n∃y R(i, y)\nsays that there is a transition from the initial state to some state; this is true\nin our model, as there are transitions from the initial state a to a, b, and c.\n2.\nThe formula\n¬F(i)\nstates that the initial state is not a ﬁnal, accepting state. This is true in our\nmodel as b and c are the only ﬁnal states and a is the intitial one.\n3.\nThe formula\n∀x∀y∀z (R(x, y) ∧R(x, z) →y = z)\nmakes use of the equality predicate and states that the transition relation is\ndeterministic: all transitions from any state can go to at most one state (there\nmay be no transitions from a state as well). This is false in our model since\nstate a has transitions to b and c.\n4.\nThe formula\n∀x∃y R(x, y)\nstates that the model is free of states that deadlock: all states have a transition\nto some state. This is true in our model: a can move to a, b or c; and b and c\ncan move to c.\nExample 2.16 Let F\ndef\n= {e, ·} and P\ndef\n= {≤}, where e is a constant, · is a\nto predicate logic, let’s now look at how the semantics of predicate logic\nworks. Just like in the propositional case, the semantics should provide a\nseparate, but ultimately equivalent, characterisation of the logic. By ‘sepa-\nrate,’ we mean that the meaning of the connectives is deﬁned in a diﬀerent\nway; in proof theory, they were deﬁned by proof rules providing an oper-\native explanation. In semantics, we expect something like truth tables. By\n‘equivalent,’ we mean that we should be able to prove soundness and com-\npleteness, as we did for propositional logic – although a fully ﬂedged proof\nof soundness and completeness for predicate logic is beyond the scope of this\nbook.\nBefore we begin describing the semantics of predicate logic, let us look\nmore closely at the real diﬀerence between a semantic and a proof-theoretic\naccount. In proof theory, the basic object which is constructed is a proof.\nLet us write Γ as a shorthand for lists of formulas φ1, φ2, . . . , φn. Thus, to\nshow that Γ ⊢ψ is valid, we need to provide a proof of ψ from Γ. Yet,\nhow can we show that ψ is not a consequence of Γ? Intuitively, this is\nharder; how can you possibly show that there is no proof of something?\nYou would have to consider every ‘candidate’ proof and show it is not one.\nThus, proof theory gives a ‘positive’ characterisation of the logic; it pro-\nvides convincing evidence for assertions like ‘Γ ⊢ψ is valid,’ but it is not\nvery useful for establishing evidence for assertions of the form ‘Γ ⊢φ is not\nvalid.’\n2.4 Semantics of predicate logic\n123\nSemantics, on the other hand, works in the opposite way. To show that ψ\nis not a consequence of Γ is the ‘easy’ bit: ﬁnd a model in which all φi are\ntrue, but ψ isn’t. Showing that ψ is a consequence of Γ, on the other hand,\nis harder in principle. For propositional logic, you need to show that every\nvaluation (an assignment of truth values to all atoms involved) that makes\n9. Let φ and ψ and η be sentences of predicate logic.\n(a) If ψ is semantically entailed by φ, is it necessarily the case that ψ is not\nsemantically entailed by ¬φ?\n(b)\n*\nIf ψ is semantically entailed by φ ∧η, is it necessarily the case that ψ is\nsemantically entailed by φ and semantically entailed by η?\n(c) If ψ is semantically entailed by φ or by η, is it necessarily the case that ψ\nis semantically entailed by φ ∨η?\n(d) Explain why ψ is semantically entailed by φ iﬀφ →ψ is valid.\n10. Is ∀x (P(x) ∨Q(x)) ⊨∀x P(x) ∨∀x Q(x) a semantic entailment? Justify your\nanswer.\n11. For each set of formulas below show that they are consistent:\n(a) ∀x ¬S(x, x), ∃x P(x), ∀x ∃y S(x, y), ∀x (P(x) →∃y S(y, x))\n(b)\n*\n∀x ¬S(x, x), ∀x ∃y S(x, y),\n∀x ∀y ∀z ((S(x, y) ∧S(y, z)) →S(x, z))\n(c) (∀x (P(x) ∨Q(x))) →∃y R(y), ∀x (R(x) →Q(x)), ∃y (¬Q(y) ∧P(y))\n(d)\n*\n∃x S(x, x), ∀x ∀y (S(x, y) →(x = y)).\n12. For each of the formulas of predicate logic below, either ﬁnd a model which\ndoes not satisfy it, or prove it is valid:\n(a) (∀x ∀y (S(x, y) →S(y, x))) →(∀x ¬S(x, x))\n(b)\n*\n∃y ((∀x P(x)) →P(y))\n(c) (∀x (P(x) →∃y Q(y))) →(∀x ∃y (P(x) →Q(y)))\n(d) (∀x ∃y (P(x) →Q(y))) →(∀x (P(x) →∃y Q(y)))\n(e) ∀x ∀y (S(x, y) →(∃z (S(x, z) ∧S(z, y))))\n(f) (∀x ∀y (S(x, y) →(x = y))) →(∀z ¬S(z, z))\n(g)\n*\n(∀x ∃y (S(x, y) ∧((S(x, y) ∧S(y, x)) →(x = y)))) →\n(¬∃z ∀w (S(z, w))).\n(h) ∀x ∀y ((P(x) →P(y)) ∧(P(y) →P(x)))\n(i) (∀x ((P(x) →Q(x)) ∧(Q(x) →P(x)))) →((∀x P(x)) →(∀x Q(x)))\n(j) ((∀x P(x)) →(∀x Q(x))) →(∀x ((P(x) →Q(x)) ∧(Q(x) →P(x))))\n(k) Diﬃcult: (∀x ∃y (P(x) →Q(y))) →(∃y ∀x (P(x) →Q(y))).\nExercises 2.5\n1. Assuming that our proof calculus for predicate logic is sound (see exercise 3\nbelow), show that the validity of the following sequents cannot be proved by\nﬁnding for each sequent a model such that all formulas to the left of ⊢evaluate\nto T and the sole formula to the right of ⊢evaluates to F (explain why this\nguarantees the non-existence of a proof):\n2.8 Exercises\n165\n(a) ∀x (P(x) ∨Q(x)) ⊢∀x P(x) ∨∀x Q(x)\n(b)\n*\nC4 says that any R-edge is also a P-edge, C1 states that P is reﬂexive, C2\nspeciﬁes that P is transitive, and C3 ensures that there is no P-path from\nthe node associated to u to the node associated to v.\nGiven a model M with interpretations for all function and predicate sym-\nbols of φ in (2.11), except P, let MT be that same model augmented with\nan interpretation T ⊆A × A of P, i.e. P MT = T. For any look-up table l,\nthe semantics of ∃P φ is then\nM ⊨l ∃P φ\niﬀ\nfor some T ⊆A × A, MT ⊨l φ.\n(2.13)\n4 Meaning, a Horn clause after all atomic subformulas are replaced with propositional atoms.\n140\n2 Predicate logic\nExample 2.27 Let ∃P φ be the formula in (2.12) and consider the model\nM of Example 2.23 and Figure 2.5. Let l be a look-up table with l(u) = s0\nand l(v) = s3. Does M ⊨l ∃P φ hold? For that, we need an interpretation\nT ⊆A × A of P such that MT ⊨l ∀x∀y∀x (C1 ∧C2 ∧C3 ∧C4) holds. That\nis, we need to ﬁnd a reﬂexive and transitive relation T ⊆A × A that con-\ntains RM but not (s0, s3). Please verify that T\ndef\n= {(s, s′) ∈A × A | s′ ̸= s3}\n∪{(s3, s3)} is such a T. Therefore, M ⊨l ∃P φ holds.\nIn the exercises you are asked to show that the formula in (2.12) holds in\na directed graph iﬀthere isn’t a ﬁnite path from node l(u) to node l(v) in\nthat graph. Therefore, this formula speciﬁes unreachability.\n2.6.2 Universal second-order logic\nOf course, we can negate (2.12) and obtain\n∀P ∃x∃y∃z (¬C1 ∨¬C2 ∨¬C3 ∨¬C4)\n(2.14)\nby relying on the familiar de Morgan laws. This is a formula of universal\nsecond-order logic. This formula expresses reachability.\nTheorem 2.28 Let M = (A, RM) be any model. Then the formula\nin (2.14) holds under look-up table l in M iﬀl(v) is R-reachable from l(u)\nin M.\nPROOF:\n1.\nFirst, assume that MT ⊨l ∃x∃y∃z (¬C1 ∨¬C2 ∨¬C3 ∨¬C4) holds for all inter-\npretations T of P. Then it also holds for the interpretation which is the re-\nﬂexive, transitive closure of RM. But for that T, MT ⊨l ∃x∃y∃z (¬C1 ∨¬C2 ∨\nany other variable y to l(y).\nFinally, we are able to give a semantics to formulas of predicate logic. For\npropositional logic, we did this by computing a truth value. Clearly, it suﬃces\nto know in which cases this value is T.\n128\n2 Predicate logic\nDeﬁnition 2.18 Given a model M for a pair (F, P) and given an environ-\nment l, we deﬁne the satisfaction relation M ⊨l φ for each logical formula\nφ over the pair (F, P) and look-up table l by structural induction on φ. If\nM ⊨l φ holds, we say that φ computes to T in the model M with respect to\nthe environment l.\nP:\nIf φ is of the form P(t1, t2, . . . , tn), then we interpret the terms t1, t2, . . . , tn in\nour set A by replacing all variables with their values according to l. In this way\nwe compute concrete values a1, a2, . . . , an of A for each of these terms, where\nwe interpret any function symbol f ∈F by f M. Now M ⊨l P(t1, t2, . . . , tn)\nholds iﬀ(a1, a2, . . . , an) is in the set P M.\n∀x:\nThe relation M ⊨l ∀x ψ holds iﬀM ⊨l[x\u0005→a] ψ holds for all a ∈A.\n∃x:\nDually, M ⊨l ∃x ψ holds iﬀM ⊨l[x\u0005→a] ψ holds for some a ∈A.\n¬:\nThe relation M ⊨l ¬ψ holds iﬀit is not the case that M ⊨l ψ holds.\n∨:\nThe relation M ⊨l ψ1 ∨ψ2 holds iﬀM ⊨l ψ1 or M ⊨l ψ2 holds.\n∧:\nThe relation M ⊨l ψ1 ∧ψ2 holds iﬀM ⊨l ψ1 and M ⊨l ψ2 hold.\n→:\nThe relation M ⊨l ψ1 →ψ2 holds iﬀM ⊨l ψ2 holds whenever M ⊨l ψ1 holds.\nWe sometimes write M ̸⊨l φ to denote that M ⊨l φ does not hold.\nThere is a straightforward inductive argument on the height of the parse\ntree of a formula which says that M ⊨l φ holds iﬀM ⊨l′ φ holds, whenever\nl and l′ are two environments which are identical on the set of free variables\nof φ. In particular, if φ has no free variables at all, we then call φ a sentence;\nwe conclude that M ⊨l φ holds, or does not hold, regardless of the choice of\nl. Thus, for sentences φ we often elide l and write M ⊨φ since the choice of\nan environment l is then irrelevant.\nExample 2.19 Let us illustrate the deﬁnitions above by means of an-",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-3",
                    "title": "Logic Engineering",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-3-subsection-1",
                            "title": "The Stock of Valid Formulas",
                            "content": "φ1, φ2, . . . , φn ⊨ψ holds, we have already shown that ⊨φ1 →(φ2 →(φ3 →\n· · · →(φn →ψ))) follows in step 1 of our completeness proof.\n2\nFor our current purposes, we want to transform formulas into ones which\ndon’t contain →at all and the occurrences of ∧and ∨are conﬁned to\nseparate layers such that validity checks are easy. This is being done by\n1.\nusing the equivalence φ →ψ ≡¬φ ∨ψ to remove all occurrences of →from a\nformula and\n2.\nby specifying an algorithm that takes a formula without any →into a normal\nform (still without →) for which checking validity is easy.\nNaturally, we have to specify which forms of formulas we think of as being\n‘normal.’ Again, there are many such notions, but in this text we study only\ntwo important ones.\nDeﬁnition 1.42 A literal L is either an atom p or the negation of an atom\n¬p. A formula C is in conjunctive normal form (CNF) if it is a conjunction\nof clauses, where each clause D is a disjunction of literals:\nL ::= p | ¬p\nD ::= L | L ∨D\n(1.6)\nC ::= D | D ∧C.\n56\n1 Propositional logic\nExamples of formulas in conjunctive normal form are\n(i)\n(¬q ∨p ∨r) ∧(¬p ∨r) ∧q\n(ii)\n(p ∨r) ∧(¬p ∨r) ∧(p ∨¬r).\nIn the ﬁrst case, there are three clauses of type D: ¬q ∨p ∨r, ¬p ∨r, and q –\nwhich is a literal promoted to a clause by the ﬁrst rule of clauses in (1.6).\nNotice how we made implicit use of the associativity laws for ∧and ∨,\nsaying that φ ∨(ψ ∨η) ≡(φ ∨ψ) ∨η and φ ∧(ψ ∧η) ≡(φ ∧ψ) ∧η, since\nwe omitted some parentheses. The formula (¬(q ∨p) ∨r) ∧(q ∨r) is not in\nCNF since q ∨p is not a literal.\nWhy do we care at all about formulas φ in CNF? One of the reasons\nfor their usefulness is that they allow easy checks of validity which other-\nwise take times exponential in the number of atoms. For example, consider\nthe formula in CNF from above: (¬q ∨p ∨r) ∧(¬p ∨r) ∧q. The semantic\nentailment ⊨(¬q ∨p ∨r) ∧(¬p ∨r) ∧q holds iﬀall three relations\n⊨¬q ∨p ∨r\n⊨¬p ∨r\n⊨q\nhold, by the semantics of ∧. But since all of these formulas are disjunctions\nsince R(x, y). The latter and R(y, z) then render z ⊩p, a contradiction. Thus,\nwe must have R(x, z).\n2\nThis picture is completed in Table 5.12, which shows, for a collection of\nformulas, the corresponding property of R. What this table means mathe-\nmatically is the following:\nTheorem 5.14 A frame F = (W, R) satisﬁes a formula scheme in Table\n5.12 iﬀR has the corresponding property in that table.\nThe names of the formulas in the left-hand column are historical, but have\nstuck and are still used widely in books.\n326\n5 Modal logics and agents\n5.3.4 Some modal logics\nThe logic engineering approach of this section encourages us to design logics\nby picking and choosing a set L of formula schemes, according to the ap-\nplication at hand. Some examples of formula schemes that we may wish to\nconsider for a given application are those in Tables 5.7 and 5.12.\nDeﬁnition 5.15 Let L be a set of formula schemes of modal logic and\nΓ ∪{ψ} a set of formulas of basic modal logic.\n1.\nThe set Γ is closed under substitution instances iﬀwhenever φ ∈Γ, then any\nsubstitution instance of φ is also in Γ.\n2.\nLet Lc be the smallest set containing all instances of L.\n3.\nΓ semantically entails ψ in L iﬀΓ ∪Lc semantically entails ψ in basic modal\nlogic. In that case, we say that Γ ⊨L ψ holds.\nThus, we have Γ ⊨L ψ if every Kripke model and every world x satisfying\nΓ ∪Lc therein also satisﬁes ψ. Note that for L = ∅this deﬁnition is consistent\nwith the one of Deﬁnition 5.7, since we then have Γ ∪Lc = Γ. For logic\nengineering, we require that L be\nr closed under substitution instances; otherwise, we won’t be able to characterize\nLc in terms of properties of the accessibility relation; and\nr consistent in that there is a frame F such that F ⊨φ holds for all φ ∈L; oth-\nerwise, Γ ⊨L ψ holds for all Γ and ψ! In most applications of logic engineering,\nconsistency is easy to establish.\nWe now study a few important modal logics that extend basic modal logic\nwith a consistent set of formula schemes L.\nlong as they match the pattern required by the respective rule. For example,\n32\n1 Propositional logic\nthe application of the proof rule →e in\n1\np →q\npremise\n2\np\npremise\n3\nq\n→e 1, 2\nis equally valid if we substitute p with p ∨¬r and q with r →p:\n1\np ∨¬r →(r →p)\npremise\n2\np ∨¬r\npremise\n3\nr →p\n→e 1, 2\nThis is why we expressed such rules as schemes with Greek symbols stand-\ning for generic formulas. Yet, it is time that we make precise the notion of\n‘any formula we may form.’ Because this text concerns various logics, we will\nintroduce in (1.3) an easy formalism for specifying well-formed formulas. In\ngeneral, we need an unbounded supply of propositional atoms p, q, r, . . ., or\np1, p2, p3, . . . You should not be too worried about the need for inﬁnitely\nmany such symbols. Although we may only need ﬁnitely many of these\npropositions to describe a property of a computer program successfully, we\ncannot specify how many such atomic propositions we will need in any con-\ncrete situation, so having inﬁnitely many symbols at our disposal is a cheap\nway out. This can be compared with the potentially inﬁnite nature of En-\nglish: the number of grammatically correct English sentences is inﬁnite, but\nﬁnitely many such sentences will do in whatever situation you might be in\n(writing a book, attending a lecture, listening to the radio, having a dinner\ndate, . . . ).\nFormulas in our propositional logic should certainly be strings over the\nalphabet {p, q, r, . . . } ∪{p1, p2, p3, . . . } ∪{¬, ∧, ∨, →, (, )}. This is a trivial\nobservation and as such is not good enough for what we are trying to capture.\nFor example, the string (¬)() ∨pq →is a word over that alphabet, yet, it\ndoes not seem to make a lot of sense as far as propositional logic is concerned.\nSo what we have to deﬁne are those strings which we want to call formulas.\nWe call such formulas well-formed.\nDeﬁnition 1.27 The well-formed formulas of propositional logic are those\nr If φ is a formula and x is a variable, then (∀x φ) and (∃x φ) are formulas.\nr Nothing else is a formula.\nNote how the arguments given to predicates are always terms. This can also\nbe seen in the Backus Naur form (BNF) for predicate logic:\nφ ::= P(t1, t2, . . . , tn) | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (∀x φ) | (∃x φ)\n(2.2)\nwhere P ∈P is a predicate symbol of arity n ≥1, ti are terms over F and x\nis a variable. Recall that each occurrence of φ on the right-hand side of the\n::= stands for any formula already constructed by these rules. (What role\ncould predicate symbols of arity 0 play?)\n2.2 Predicate logic as a formal language\n101\n∀x\n∧\n→\nS\nP\nQ\nx\ny\nx\nx\nFigure 2.1. A parse tree of a predicate logic formula.\nConvention 2.4 For convenience, we retain the usual binding priorities\nagreed upon in Convention 1.3 and add that ∀y and ∃y bind like ¬. Thus,\nthe order is:\nr ¬, ∀y and ∃y bind most tightly;\nr then ∨and ∧;\nr then →, which is right-associative.\nWe also often omit brackets around quantiﬁers, provided that doing so in-\ntroduces no ambiguities.\nPredicate logic formulas can be represented by parse trees. For example,\nthe parse tree in Figure 2.1 represents the formula ∀x ((P(x) →Q(x)) ∧\nS(x, y)).\nExample 2.5 Consider translating the sentence\nEvery son of my father is my brother.\ninto predicate logic. As before, the design choice is whether we represent\n‘father’ as a predicate or as a function symbol.\n1.\nAs a predicate. We choose a constant m for ‘me’ or ‘I,’ so m is a term, and we\nchoose further {S, F, B} as the set of predicates with meanings\n102\n2 Predicate logic\nS(x, y) :\nx is a son of y\nF(x, y) :\nx is the father of y\nB(x, y) :\nx is a brother of y.\nThen the symbolic encoding of the sentence above is\n∀x ∀y (F(x, m) ∧S(y, x) →B(y, m))\n(2.3)\nsaying: ‘For all x and all y, if x is a father of m and if y is a son of x, then y is\na brother of m.’\n2.\nAs a function. We keep m, S and B as above and write f for the function which,\ni. The formula ∃x.f depends on all those variables that f depends upon,\nexcept x.\nii. If f computes to 1 with respect to a valuation ρ, then ∃x.f computes 1\nwith respect to the same valuation.\niii. If ∃x.f computes to 1 with respect to a valuation ρ, then there is a valuation\nρ′ for f which agrees with ρ for all variables other than x such that f\ncomputes to 1 under ρ′.\n(b) Can the statements above be shown for the function value 0?\n3. Let φ be a boolean formula.\n(a)\n*\nShow that φ is satisﬁable if, and only if, ∃x.φ is satisﬁable.\n(b) Show that φ is valid if, and only if, ∀x.φ is valid.\n(c) Generalise the two facts above to nested quantiﬁcations ∃ˆx and ∀ˆx. (Use\ninduction on the number of quantiﬁed variables.)\n4. Show that ∀ˆx.f and ∃ˆx.f are semantically equivalent. Use induction on the\nnumber of arguments in the vector ˆx.\nExercises 6.10\n(For those who know about complexity classes.)\n1. Show that 3SAT can be reduced to nested existential boolean quantiﬁcation.\nGiven an instance of 3SAT, we may think of it as a boolean formula f in product-\nof-sums form g1 · g2 · · · · · gn, where each gi is of the form (l1 + l2 + l3) with each\nlj being a boolean variable or its complementation. For example, f could be\n(x + y + z) · (x5 + x + x7) · (x2 + z + x) · (x4 + x2 + x4).\n(a) Show that you can represent each function gi with an OBDD of no more\nthan three non-terminals, independently of the chosen ordering.\n(b) Introduce n new boolean variables z1, z2, . . . , zn. We write \n1≤i≤n fi for\nthe expression f1 + f2 + · · · + fn and \u0002\n1≤i≤n fi for f1 · f2 · · · · · fn. Consider\nthe boolean formula h, deﬁned as\n\u0003\n1≤i≤n\n\ngi · zi ·\n\u0001\n1≤j<i\nzj\n\n.\n(6.28)\nChoose any ordering of variables whose list begins as in [z1, z2, . . . , zn, . . . ].\nDraw the OBDD for h (draw only the root nodes for gi).\n(c) Argue that the OBDD above has at most 4n non-terminal nodes.\n(d) Show that f is satisﬁable if, and only if, the OBDD for ∃z1.∃z2. . . . .∃zn.h is\nnot equal to B1.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-2",
                            "title": "Important Properties of the Accessibility Relation",
                            "content": "terms of the Ki and CG is deﬁned in terms of EG.\nMany of the results we had for basic modal logic with a single accessi-\nbility relation also hold in this more general setting of several accessibility\nrelations. Summarising,\nr a frame F for KT45n (W, (Ri)i∈A) for the modal logic KT45n is a set W of\nworlds and, for each i ∈A, an equivalence relation Ri on W.\nr a frame F = (W, (Ri)i∈A) for KT45n is said to satisfy φ if, for each labelling\nfunction L: W →P(Atoms) and each w ∈W, we have M, w ⊩φ holds, where\nM = (W, (Ri)i∈A, L). In that case, we say that F ⊨φ holds.\nThe following theorem is useful for answering questions about formu-\nlas involving E and C. Let M = (W, (Ri)i∈A, L) be a model for KT45n\n338\n5 Modal logics and agents\nand x, y ∈W. We say that y is G-reachable in k steps from x if there are\nw1, w2, . . . , wk−1 ∈W and i1, i2, . . . , ik in G such that\nx Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y\nmeaning Ri1(x, w1), Ri2(w1, w2), . . . , Rik(wk, y). We also say that y is G-\nreachable from x if there is some k such that it is G-reachable in k steps.\nTheorem 5.26\n1.\nx ⊩Ek\nGφ iﬀ, for all y that are G-reachable from x in k steps, we have y ⊩φ.\n2.\nx ⊩CG φ iﬀ, for all y that are G-reachable from x, we have y ⊩φ.\nPROOF:\n1.\nFirst, suppose y ⊩φ for all y G-reachable from x in k steps. We will prove\nthat x ⊩Ek\nGφ holds. It is suﬃcient to show that x ⊩Ki1Ki2 . . . Kik φ for any\ni1, i2, . . . , ik ∈G. Take any i1, i2, . . . , ik ∈G and any w1, w2,. . . , wk−1 and y\nsuch that there is a path of the form x Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y. Since\ny is G-reachable from x in k steps, we have y ⊩φ by our assumption, so x ⊩\nKi1Ki2 . . . Kik φ as required.\nConversely, suppose x ⊩Ek\nGφ holds and y is G-reachable from x in k steps. We\nmust show that y ⊩φ holds. Take i1, i2, . . . , ik by G-reachability; since x ⊩Ek\nGφ\nimplies x ⊩Ki1Ki2 . . . Kik φ, we have y ⊩φ.\n2.\nThis argument is similar.\nSome valid formulas in KT45n\nThe formula K holds for the connec-\n{x1, x2, x3, x4, x5, x6} is shown in Figure 5.13. The links between the worlds\nhave to be labelled with the name of the accessibility relation, since we have\nseveral relations. For example, x1 and x2 are related by R1, whereas x4 and\n5.5 Reasoning about knowledge in a multi-agent system\n337\nx5 are related both by R1 and by R2. We simplify by no longer requiring ar-\nrows on the links. This is because we know that the relations are symmetric,\nso the links are bi-directional. Moreover, the relations are also reﬂexive, so\nthere should be loops like the one on x4 in Figure 5.11 in all the worlds and\nfor all of the relations. We can simply omit these from the diagram, since we\ndon’t need to distinguish between worlds which are self-related and those\nwhich are not.\nDeﬁnition 5.25 Take a model M = (W, (Ri)i∈A, L) of KT45n and a world\nx ∈W. We deﬁne when φ is true in x via a satisfaction relation x ⊩φ by\ninduction on φ:\nx ⊩p iﬀp ∈L(x)\nx ⊩¬φ iﬀx ̸⊩φ\nx ⊩φ ∧ψ\niﬀx ⊩φ and x ⊩ψ\nx ⊩φ ∨ψ\niﬀx ⊩φ or x ⊩ψ\nx ⊩φ →ψ\niﬀx ⊩ψ whenever we have x ⊩φ\nx ⊩Ki ψ\niﬀ, for each y ∈W, Ri(x, y) implies y ⊩ψ\nx ⊩EG ψ\niﬀ, for each i ∈G, x ⊩Ki ψ\nx ⊩CG ψ\niﬀ, for each k ≥1, we have x ⊩Ek\nGψ,\nwhere Ek\nG means EGEG . . . EG – k times\nx ⊩DG ψ\niﬀ, for each y ∈W, we have y ⊩ψ,\nwhenever Ri(x, y) for all i ∈G.\nAgain, we write M, x ⊩φ if we want to emphasise the model M.\nCompare this with Deﬁnition 5.4. The cases for the boolean connectives\nare the same as for basic modal logic. Each Ki behaves like a 2, but refers to\nits own accessibility relation Ri. As already stated, there are no equivalents\nof 3, but we can recover them as ¬Ki¬. The connective EG is deﬁned in\nterms of the Ki and CG is deﬁned in terms of EG.\nMany of the results we had for basic modal logic with a single accessi-\nbility relation also hold in this more general setting of several accessibility\nrelations. Summarising,\nr a frame F for KT45n (W, (Ri)i∈A) for the modal logic KT45n is a set W of\nunder logical consequence. This means that the agent knows all the\n320\n5 Modal logics and agents\nconsequences of anything he knows, which is unfortunately (or fortu-\nnately?) true only for idealised agents, not humans.\nExecution of programs. Not many of our formulas seem to hold in this\ncase. The scheme 2φ →22φ says that running the program twice is the\nsame as running it once, which is plainly wrong in the case of a program\nwhich deducts money from your bank account. The formula 3⊤says\nthat there is an execution of the program which terminates; this is false\nfor some programs.\nThe formula schemes 3⊤and 2φ →3φ were seen to be equivalent in the\npreceding section and, indeed, we see that they get the same pattern of ticks\nand crosses. We can also show that 2φ →φ entails 3⊤– i.e. (2φ →φ) →\n3⊤is valid – so whenever the former gets a tick, so should the latter. This\nis indeed the case, as you can verify in Table 5.7.\n5.3.2 Important properties of the accessibility relation\nSo far, we have been engineering logics at the level of deciding what formulas\nshould be valid for the various readings of 2. We can also engineer logics\nat the level of Kripke models. For each of our six readings of 2, there is a\ncorresponding reading of the accessibility relation R which will then suggest\nthat R enjoys certain properties such as reﬂexivity or transitivity.\nLet us start with necessity. The clauses\nx ⊩2ψ\niﬀfor each y ∈W with R(x, y) we have y ⊩ψ\nx ⊩3ψ\niﬀthere is a y ∈W such that R(x, y) and y ⊩ψ\nfrom Deﬁnition 5.4 tell us that φ is necessarily true at x if φ is true in all\nworlds y accessible from x in a certain way; but accessible in what way?\nIntuitively, necessarily φ is true if φ is true in all possible worlds; so R(x, y)\nshould be interpreted as meaning that y is a possible world according to the\ninformation in x.\nIn the case of knowledge, we think of R(x, y) as saying: y could be the\nactual world according to agent Q’s knowledge at x. In other words, if the\nWe saw in the preceding section that there appeared to be a correspondence\nbetween the validity of 2φ →φ and the property that the accessibility re-\nlation R is reﬂexive. The connection between them is that both relied on\nthe intuition that anything which is known by an agent is true. Moreover,\nthere also seemed to be a correspondence between 2φ →22φ and R being\ntransitive; they both seem to assert the property of positive introspection,\ni.e. that which is known is known to be known.\nIn this section, we will see that there is a precise mathematical relation-\nship between these formulas and properties of R. Indeed, to every formula\nscheme there corresponds a property of R. From the point of view of logic\nengineering, it is important to see this relationship, because it helps one to\nunderstand the logic being studied. For example, if you believe that a cer-\ntain formula scheme should be accepted in the system of modal logic you are\nengineering, then it is well worth looking at the corresponding property of\nR and checking that this property makes sense for the application, too. Al-\nternatively, the meaning of some formulas may seem diﬃcult to understand,\nso looking at their corresponding properties of R can help.\nTo state the relationship between formula schemes and their correspond-\ning properties, we need the notion of a (modal) frame.\nDeﬁnition 5.10 A frame F = (W, R) is a set W of worlds and a binary\nrelation R on W.\nA frame is like a Kripke model (Deﬁnition 5.3), except that it has no la-\nbelling function. From any model we can extract a frame, by just forgetting\nabout the labelling function; for example, Figure 5.9 shows the frame ex-\ntracted from the Kripke model of Figure 5.3. A frame is just a set of worlds\nand an accessibility relationship between them. It has no information about\nwhat atomic formulas are true at the various worlds. However, it is useful to\nsay sometimes that the frame, as a whole, satisﬁes a formula. This is deﬁned\nas follows.\nfunction and world which does satisfy p →23p in your frame?\n15. Give two examples of frames which are Euclidean – i.e. their accessibility rela-\ntion is Euclidean – and two which are not. Explain intuitively why 3p →23p\nholds on the ﬁrst two, but not on the latter two.\n16. For each of the following formulas, ﬁnd the property of R which corresponds to\nit.\n(a) φ →2φ\n(b)\n*\n2⊥\n(c)\n*\n32φ →23φ.\n17.\n*\nFind a formula whose corresponding property is density: for all x, z ∈W such\nthat R(x, z), there exists y ∈W such that R(x, y) and R(y, z).\n18. The modal logic KD45 is used to model belief; see Table 5.12 for the axiom\nschemes D, 4, and 5.\n(a) Explain how it diﬀers from KT45.\n(b) Show that ⊨KD45 2p →3p is valid. What is the signiﬁcance of this, in terms\nof knowledge and belief?\n(c) Explain why the condition of seriality is relevant to belief.\n19. Recall Deﬁnition 5.7. How would you deﬁne ≡L for a modal logic L?\nExercises 5.4\n1. Find natural deduction proofs for the following sequents over the basic modal\nlogic K.\n(a)\n*\n⊢K 2(p →q) |−2p →2q\n(b) ⊢K 2(p →q) |−3p →3q\n(c)\n*\n⊢K|−2(p →q) ∧2(q →r) →2(p →r)\n(d) ⊢K 2(p ∧q) |−2p ∧2q\n(e) ⊢K|−3⊤→(2p →3p)\n(f)\n*\n⊢K 3(p →q) |−2p →3q\n(g) ⊢K 3(p ∨q) |−3p ∨3q.\n354\n5 Modal logics and agents\n2. Find natural deduction proofs for the following, in modal logic KT45.\n(a) p →23p\n(b) 23p ↔3p\n(c)\n*\n32p ↔2p\n(d) 2(2p →2q) ∨2(2q →2p)\n(e) 2(3p →q) ↔2(p →2q).\n3. Study the proofs you gave for the previous exercise to see whether any of\nthese formula schemes could be valid in basic modal logic. Inspect where and\nhow these proofs used the axioms T, 4 and 5 to see whether you can ﬁnd a\ncounter example, i.e. a Kripke model and a world which does not satisfy the\nformula.\n4. Provide a sketch of an argument which shows that the natural deduction rules\nfor basic modal logic are sound with respect to the semantics x ⊩φ over Kripke\nstructures.\nExercises 5.5\n1. This exercise is about the wise-men puzzle. Justify your answers.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-3",
                            "title": "Correspondence Theory",
                            "content": "The interpretation of P on M is just what we expect it to be:\nP M def\n= {(s, t) | there is a sequence of indices (i1, i2, . . . , im) such that\ns equals si1si2 . . . sim and t equals ti1ti2 . . . tim}\nwhere s and t are binary strings and the si and ti are the data of the\ncorrespondence problem C. A pair of strings (s, t) lies in P M iﬀ, using the\nsame sequence of indices (i1, i2, . . . , im), s is built using the corresponding\nsi and t is built using the respective ti.\nSince ⊨φ holds we infer that M ⊨φ holds, too. We claim that M ⊨\nφ2 holds as well, which says that whenever the pair (s, t) is in P M, then\nthe pair (s si, t ti) is also in P M for i = 1, 2, . . . , k (you can verify that is\nsays this by inspecting the deﬁnition of P M). Now (s, t) ∈P M implies that\nthere is some sequence (i1, i2, . . . , im) such that s equals si1si2 . . . sim and t\nequals ti1ti2 . . . tim. We simply choose the new sequence (i1, i2, . . . , im, i) and\nobserve that s si equals si1si2 . . . simsi and t ti equals ti1ti2 . . . timti and so\nM ⊨φ2 holds as claimed. (Why does M ⊨φ1 hold?)\nSince M ⊨φ1 ∧φ2 →φ3 and M ⊨φ1 ∧φ2 hold, it follows that M ⊨φ3\nholds as well. By deﬁnition of φ3 and P M, this tells us there is a solution\nto C.\nConversely, let us assume that the Post correspondence problem C has\nsome solution, namely the sequence of indices (i1, i2, . . . , in). Now we have to\nshow that, if M′ is any model having a constant eM′, two unary functions,\n2.5 Undecidability of predicate logic\n135\nfM′\n0\nand fM′\n1\n, and a binary predicate P M′, then that model has to satisfy\nφ. Notice that the root of the parse tree of φ is an implication, so this is\nthe crucial clause for the deﬁnition of M′ ⊨φ. By that very deﬁnition, we\nare already done if M′ ̸⊨φ1, or if M′ ̸⊨φ2. The harder part is therefore the\none where M′ ⊨φ1 ∧φ2, for in that case we need to verify M′ ⊨φ3 as well.\nThe way we proceed here is by interpreting ﬁnite, binary strings in the\n{x1, x2, x3, x4, x5, x6} is shown in Figure 5.13. The links between the worlds\nhave to be labelled with the name of the accessibility relation, since we have\nseveral relations. For example, x1 and x2 are related by R1, whereas x4 and\n5.5 Reasoning about knowledge in a multi-agent system\n337\nx5 are related both by R1 and by R2. We simplify by no longer requiring ar-\nrows on the links. This is because we know that the relations are symmetric,\nso the links are bi-directional. Moreover, the relations are also reﬂexive, so\nthere should be loops like the one on x4 in Figure 5.11 in all the worlds and\nfor all of the relations. We can simply omit these from the diagram, since we\ndon’t need to distinguish between worlds which are self-related and those\nwhich are not.\nDeﬁnition 5.25 Take a model M = (W, (Ri)i∈A, L) of KT45n and a world\nx ∈W. We deﬁne when φ is true in x via a satisfaction relation x ⊩φ by\ninduction on φ:\nx ⊩p iﬀp ∈L(x)\nx ⊩¬φ iﬀx ̸⊩φ\nx ⊩φ ∧ψ\niﬀx ⊩φ and x ⊩ψ\nx ⊩φ ∨ψ\niﬀx ⊩φ or x ⊩ψ\nx ⊩φ →ψ\niﬀx ⊩ψ whenever we have x ⊩φ\nx ⊩Ki ψ\niﬀ, for each y ∈W, Ri(x, y) implies y ⊩ψ\nx ⊩EG ψ\niﬀ, for each i ∈G, x ⊩Ki ψ\nx ⊩CG ψ\niﬀ, for each k ≥1, we have x ⊩Ek\nGψ,\nwhere Ek\nG means EGEG . . . EG – k times\nx ⊩DG ψ\niﬀ, for each y ∈W, we have y ⊩ψ,\nwhenever Ri(x, y) for all i ∈G.\nAgain, we write M, x ⊩φ if we want to emphasise the model M.\nCompare this with Deﬁnition 5.4. The cases for the boolean connectives\nare the same as for basic modal logic. Each Ki behaves like a 2, but refers to\nits own accessibility relation Ri. As already stated, there are no equivalents\nof 3, but we can recover them as ¬Ki¬. The connective EG is deﬁned in\nterms of the Ki and CG is deﬁned in terms of EG.\nMany of the results we had for basic modal logic with a single accessi-\nbility relation also hold in this more general setting of several accessibility\nrelations. Summarising,\nr a frame F for KT45n (W, (Ri)i∈A) for the modal logic KT45n is a set W of\n324\n5 Modal logics and agents\nx4\nx5\nx6\np\np\nFigure 5.11. A model.\ngive a generic argument: let x be any world. Suppose that x ⊩2p; we want to\nshow x ⊩p. We know that R(x, x) because each x is accessible from itself in the\ndiagram; so, it follows from the clause for 2 in Deﬁnition 5.4 that x ⊩p.\n2.\nTherefore, our frame F satisﬁes any formula of this shape, i.e. it satisﬁes the\nformula scheme 2φ →φ.\n3.\nThe frame does not satisfy the formula 2p →22p. For suppose we take the\nlabelling of Figure 5.11; then x4 ⊩2p, but x4 ̸⊩22p.\nIf you think about why the frame of Figure 5.10 satisﬁed 2p →p and why\nit did not satisfy 2p →22p, you will probably guess the following:\nTheorem 5.13 Let F = (W, R) be a frame.\n1.\nThe following statements are equivalent:\n– R is reﬂexive;\n– F satisﬁes 2φ →φ;\n– F satisﬁes 2p →p;\n2.\nThe following statements are equivalent:\n– R is transitive;\n– F satisﬁes 2φ →22φ;\n– F satisﬁes 2p →22p.\nPROOF: Each item 1 and 2 requires us to prove three things: (a) that, if R\nhas the property, then the frame satisﬁes the formula scheme; and (b) that,\nif the frame satisﬁes the formula scheme, it satisﬁes the instance of it; and\n(c) that, if the frame satisﬁes a formula instance, then R has the property.\n1.\n(a) Suppose R is reﬂexive. Let L be a labelling function, so now M = (W, R, L)\nis a model of basic modal logic. We need to show M ⊨2φ →φ. That means\nwe need to show x ⊩2φ →φ for any x ∈W, so pick any x. Use the clause\nfor implication in Deﬁnition 5.4. Suppose x ⊩2φ; since R(x, x), it immediately\nfollows from the clause for 2 in Deﬁnition 5.4 that x ⊩p. Therefore, we have\nshown x ⊩2φ →φ.\n(b) We just set φ to be p.\n5.3 Logic engineering\n325\nTable 5.12. Properties of R corresponding to some formulas.\nname\nformula scheme\nproperty of R\nT\n2φ →φ\nreﬂexive\nB\nφ →23φ\nsymmetric\nD\n2φ →3φ\nserial\n4\n2φ →22φ\ntransitive\n5\n3φ →23φ\nEuclidean\n2φ ↔3φ\nfunctional\n2(φ ∧2φ →ψ) ∨2(ψ ∧2ψ →φ)\nlinear\n(c) Suppose the frame satisﬁes 2p →p. Take any x; we’re going to show R(x, x).\nterms of the Ki and CG is deﬁned in terms of EG.\nMany of the results we had for basic modal logic with a single accessi-\nbility relation also hold in this more general setting of several accessibility\nrelations. Summarising,\nr a frame F for KT45n (W, (Ri)i∈A) for the modal logic KT45n is a set W of\nworlds and, for each i ∈A, an equivalence relation Ri on W.\nr a frame F = (W, (Ri)i∈A) for KT45n is said to satisfy φ if, for each labelling\nfunction L: W →P(Atoms) and each w ∈W, we have M, w ⊩φ holds, where\nM = (W, (Ri)i∈A, L). In that case, we say that F ⊨φ holds.\nThe following theorem is useful for answering questions about formu-\nlas involving E and C. Let M = (W, (Ri)i∈A, L) be a model for KT45n\n338\n5 Modal logics and agents\nand x, y ∈W. We say that y is G-reachable in k steps from x if there are\nw1, w2, . . . , wk−1 ∈W and i1, i2, . . . , ik in G such that\nx Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y\nmeaning Ri1(x, w1), Ri2(w1, w2), . . . , Rik(wk, y). We also say that y is G-\nreachable from x if there is some k such that it is G-reachable in k steps.\nTheorem 5.26\n1.\nx ⊩Ek\nGφ iﬀ, for all y that are G-reachable from x in k steps, we have y ⊩φ.\n2.\nx ⊩CG φ iﬀ, for all y that are G-reachable from x, we have y ⊩φ.\nPROOF:\n1.\nFirst, suppose y ⊩φ for all y G-reachable from x in k steps. We will prove\nthat x ⊩Ek\nGφ holds. It is suﬃcient to show that x ⊩Ki1Ki2 . . . Kik φ for any\ni1, i2, . . . , ik ∈G. Take any i1, i2, . . . , ik ∈G and any w1, w2,. . . , wk−1 and y\nsuch that there is a path of the form x Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y. Since\ny is G-reachable from x in k steps, we have y ⊩φ by our assumption, so x ⊩\nKi1Ki2 . . . Kik φ as required.\nConversely, suppose x ⊩Ek\nGφ holds and y is G-reachable from x in k steps. We\nmust show that y ⊩φ holds. Take i1, i2, . . . , ik by G-reachability; since x ⊩Ek\nGφ\nimplies x ⊩Ki1Ki2 . . . Kik φ, we have y ⊩φ.\n2.\nThis argument is similar.\nSome valid formulas in KT45n\nThe formula K holds for the connec-\n3.\nA function L : W →P(Atoms), called the labelling function.\nWe write R(x, y) to denote that (x, y) is in R.\nThese models are often called Kripke models, in honour of S. Kripke who\ninvented them and worked extensively in modal logic in the 1950s and 1960s.\nIntuitively, w ∈W stands for a possible world and R(w, w′) means that w′\nis a world accessible from world w. The actual nature of that relationship\ndepends on what we intend to model. Although the deﬁnition of models\nlooks quite complicated, we can use an easy graphical notation to depict\nﬁnite models. We illustrate the graphical notation by an example. Suppose\nW equals {x1, x2, x3, x4, x5, x6} and the relation R is given as follows:\nr R(x1, x2), R(x1, x3), R(x2, x2), R(x2, x3), R(x3, x2), R(x4, x5), R(x5, x4),\nR(x5, x6); and no other pairs are related by R.\nSuppose further that the labelling function behaves as follows:\nx\nx1 x2\nx3\nx4 x5 x6\nL(x) {q} {p, q} {p} {q} ∅{p}\n310\n5 Modal logics and agents\nThen, the Kripke model is illustrated in Figure 5.3. The set W is drawn as\na set of circles, with arrows between them showing the relation R. Within\neach circle is the value of the labelling function in that world. If you have\nread Chapter 3, then you might have noticed that Kripke structures are also\nthe models for CTL, where W is S, the set of states; R is →, the relation\nof state transitions; and L is the labelling function.\nDeﬁnition 5.4 Let M = (W, R, L) be a model of basic modal logic. Sup-\npose x ∈W and φ is a formula of (5.1). We will deﬁne when formula φ is true\nin the world x. This is done via a satisfaction relation x ⊩φ by structural\ninduction on φ:\nx ⊩⊤\nx ̸⊩⊥\nx ⊩p iﬀp ∈L(x)\nx ⊩¬φ iﬀx ̸⊩φ\nx ⊩φ ∧ψ\niﬀx ⊩φ and x ⊩ψ\nx ⊩φ ∨ψ\niﬀx ⊩φ , or x ⊩ψ\nx ⊩φ →ψ\niﬀx ⊩ψ , whenever we have x ⊩φ\nx ⊩φ ↔ψ\niﬀ(x ⊩φ iﬀx ⊩ψ)\nx ⊩2ψ\niﬀ, for each y ∈W with R(x, y), we have y ⊩ψ\nx ⊩3ψ\niﬀthere is a y ∈W such that R(x, y) and y ⊩ψ.\nWhen x ⊩φ holds, we say ‘x satisﬁes φ,’ or ‘φ is true in world x.’ We write",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-4",
                            "title": "Some Modal Logics",
                            "content": "knowledge.\nModal logic adds unary connectives to express one, or more, of these\ndiﬀerent modes of truth. The simplest modal logics just deal with one con-\ncept – such as knowledge, necessity, or time. More sophisticated modal logics\nhave connectives for expressing several modes of truth in the same logic; we\nwill see some of these towards the end of this chapter.\nWe take a logic engineering approach in this chapter, in which we address\nthe following question: given a particular mode of truth, how may we develop\na logic capable of expressing and formalising that concept? To answer this\nquestion, we need to decide what properties the logic should have and what\nexamples of reasoning it should be able to express. Our main case study will\nbe the logic of knowledge in a multi-agent system. But ﬁrst, we look at the\nsyntax and semantics of basic modal logic.\n5.2 Basic modal logic\n5.2.1 Syntax\nThe language of basic modal logic is that of propositional logic with two\nextra connectives, 2 and 3. Like negation (¬), they are unary connectives\nas they apply themselves to a single formula only. As done in Chapters 1\nand 3, we write p, q, r, p3 . . . to denote atomic formulas.\nDeﬁnition 5.1 The formulas of basic modal logic φ are deﬁned by the\nfollowing Backus Naur form (BNF):\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (φ ↔φ) | (2φ) | (3φ)\n(5.1)\nwhere p is any atomic formula.\nExample formulas of basic modal logic are (p ∧3(p →2¬r)) and 2((3q ∧\n¬r) →2p), having the parse trees shown in Figure 5.1. The following strings\nare not formulas, because they cannot be constructed using the grammar\nin (5.1): (p2 →q) and (p →3(q 3 r)).\nConvention 5.2 As done in Chapter 1, we assume that the unary connec-\ntives (¬, 2 and 3) bind most closely, followed by ∧and ∨and then followed\nby →and ↔.\n308\n5 Modal logics and agents\n∧\np\n3\n→\np\n2\n¬\nr\n2\n→\n2\n¬\n3\n∧\nr\np\nq\nFigure 5.1. Parse trees for (p ∧3(p →2¬r)) and 2((3q ∧¬r) →2p).\nThis convention allows us to remove many sets of brackets, retaining them\nin various ways to give us the properties appropriate for the intended ap-\nplications. Logic engineering is the subject of engineering logics to ﬁt new\napplications. It is potentially a very broad subject, drawing on all branches\nof logic, computer science and mathematics. In this chapter, however, we\nare restricting ourselves to the particular engineering of modal logics.\nWe will consider how to re-engineer basic modal logic to ﬁt the following\nreadings of 2φ:\nr It is necessarily true that φ\nr It will always be true that φ\nr It ought to be that φ\nr Agent Q believes that φ\nr Agent Q knows that φ\nr After any execution of program P, φ holds.\nAs modal logic automatically gives us the connective 3, which is equivalent\nto ¬2¬, we can ﬁnd out what the corresponding readings of 3 in our system\nwill be. For example, ‘it is not necessarily true that not φ’ means that it is\npossibly true that φ. You could work this out in steps:\nIt is not necessarily true that φ\n= it is possible that not φ.\nTherefore,\nIt is not necessarily true that not φ\n= it is possible that not not φ\n= it is possible that φ.\nLet us work this out with the reading ‘agent Q knows φ’ for 2φ. Then, 3φ\nis read as\nagent Q does not know not φ\n= as far as Q’s knowledge is concerned, φ could be the case\n= φ is consistent with what agent Q knows\n= for all agent Q knows, φ.\nThe readings for 3 for the other modes are given in Table 5.6.\n5.3 Logic engineering\n317\nTable 5.6. The readings of 3 corresponding to each reading of 2.\n2φ\n3φ\nIt is necessarily true that φ\nIt is possibly true that φ\nIt will always be true that φ\nSometime in the future φ\nIt ought to be that φ\nIt is permitted to be that φ\nAgent Q believes that φ\nφ is consistent with Q’s beliefs\nAgent Q knows that φ\nFor all Q knows, φ\nAfter any execution of program P, φ holds\nAfter some execution of P, φ holds\n5.3.1 The stock of valid formulas\nWe saw in the last section some valid formulas of basic modal logic, such\nerwise, Γ ⊨L ψ holds for all Γ and ψ! In most applications of logic engineering,\nconsistency is easy to establish.\nWe now study a few important modal logics that extend basic modal logic\nwith a consistent set of formula schemes L.\nThe modal logic K\nThe weakest modal logic doesn’t have any chosen\nformula schemes, like those of Tables 5.7 and 5.12. So L = ∅and this modal\nlogic is called K as it satisﬁes all instances of the formula scheme K; modal\nlogics with this property are called normal and all modal logics we study in\nthis text are normal.\nThe modal logic KT45\nA well-known modal logic is KT45 – also called\nS5 in the technical literature – where L = {T, 4, 5} with T, 4 and 5 from\nTable 5.12. This logic is used to reason about knowledge; 2φ means that\nthe agent Q knows φ. Table 5.12 tell us, respectively, that\nT. Truth: the agent Q knows only true things.\n4. Positive introspection: if the agent Q knows something, then she knows\nthat she knows it.\n5. Negative introspection: if the agent Q doesn’t know something, then\nshe knows that she doesn’t know it.\n5.3 Logic engineering\n327\nIn this application, the formula scheme K means logical omniscience: the\nagent’s knowledge is closed under logical consequence. Note that these prop-\nerties represent idealisations of knowledge. Human knowledge has none of\nthese properties! Even computer agents may not have them all. There are\nseveral attempts in the literature to deﬁne logics of knowledge that are more\nrealistic, but we will not consider them here.\nThe semantics of the logic KT45 must consider only relations R which\nare: reﬂexive (T), transitive (4) and Euclidean (5).\nFact 5.16 A relation is reﬂexive, transitive and Euclidean iﬀit is reﬂexive,\ntransitive and symmetric, i.e. if it is an equivalence relation.\nKT45 is simpler than K in the sense that it has few essentially diﬀerent ways\nof composing modalities.\nTheorem 5.17 Any sequence of modal operators and negations in KT45\ntems has been done in [FHMV95] and [MvdH95] and other work by those\nauthors. Many examples in this chapter are taken from this literature (some\nof them are attributed to other people there), though our treatment of them\nis original.\nThe natural deduction proof system for modal logic presented in this\nchapter is based on ideas in [Fit93].\n2 www.cis.ksu.edu/~allen/porgi.html\n5.7 Bibliographic notes\n357\nAn application of the modal logic KT4 (more precisely, its fragment with-\nout negation) as a type system for staged computation in a functional pro-\ngramming language can be found in [DP96].\nWe should stress that our framework was deliberately ‘classical;’ the thesis\n[Sim94] is a good source for discussions of intuitionistic modal logics; it also\ncontains a gentle introduction to basic ﬁrst-order modal logic.\n6\nBinary decision diagrams\n6.1 Representing boolean functions\nBoolean functions are an important descriptive formalism for many hard-\nware and software systems, such as synchronous and asynchronous circuits,\nreactive systems and ﬁnite-state programs. Representing those systems in a\ncomputer in order to reason about them requires an eﬃcient representation\nfor boolean functions. We look at such a representation in this chapter and\ndescribe in detail how the systems discussed in Chapter 3 can be veriﬁed\nusing the representation.\nDeﬁnition 6.1 A boolean variable x is a variable ranging over the values\n0 and 1. We write x1, x2, . . . and x, y, z, . . . to denote boolean variables. We\ndeﬁne the following functions on the set {0, 1}:\nr 0\ndef\n= 1 and 1\ndef\n= 0;\nr x · y\ndef\n= 1 if x and y have value 1; otherwise x · y\ndef\n= 0;\nr x + y\ndef\n= 0 if x and y have value 0; otherwise x + y\ndef\n= 1;\nr x ⊕y\ndef\n= 1 if exactly one of x and y equals 1.\nA boolean function f of n arguments is a function from {0, 1}n to {0, 1}.\nWe write f(x1, x2, . . . , xn), or f(V ), to indicate that a syntactic representa-\ntion of f depends on the boolean variables in V only.\nsince R(x, y). The latter and R(y, z) then render z ⊩p, a contradiction. Thus,\nwe must have R(x, z).\n2\nThis picture is completed in Table 5.12, which shows, for a collection of\nformulas, the corresponding property of R. What this table means mathe-\nmatically is the following:\nTheorem 5.14 A frame F = (W, R) satisﬁes a formula scheme in Table\n5.12 iﬀR has the corresponding property in that table.\nThe names of the formulas in the left-hand column are historical, but have\nstuck and are still used widely in books.\n326\n5 Modal logics and agents\n5.3.4 Some modal logics\nThe logic engineering approach of this section encourages us to design logics\nby picking and choosing a set L of formula schemes, according to the ap-\nplication at hand. Some examples of formula schemes that we may wish to\nconsider for a given application are those in Tables 5.7 and 5.12.\nDeﬁnition 5.15 Let L be a set of formula schemes of modal logic and\nΓ ∪{ψ} a set of formulas of basic modal logic.\n1.\nThe set Γ is closed under substitution instances iﬀwhenever φ ∈Γ, then any\nsubstitution instance of φ is also in Γ.\n2.\nLet Lc be the smallest set containing all instances of L.\n3.\nΓ semantically entails ψ in L iﬀΓ ∪Lc semantically entails ψ in basic modal\nlogic. In that case, we say that Γ ⊨L ψ holds.\nThus, we have Γ ⊨L ψ if every Kripke model and every world x satisfying\nΓ ∪Lc therein also satisﬁes ψ. Note that for L = ∅this deﬁnition is consistent\nwith the one of Deﬁnition 5.7, since we then have Γ ∪Lc = Γ. For logic\nengineering, we require that L be\nr closed under substitution instances; otherwise, we won’t be able to characterize\nLc in terms of properties of the accessibility relation; and\nr consistent in that there is a frame F such that F ⊨φ holds for all φ ∈L; oth-\nerwise, Γ ⊨L ψ holds for all Γ and ψ! In most applications of logic engineering,\nconsistency is easy to establish.\nWe now study a few important modal logics that extend basic modal logic\nwith a consistent set of formula schemes L.",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-4",
                    "title": "Natural Deduction",
                    "content": null,
                    "children": []
                },
                {
                    "id": "chapter-1-section-5",
                    "title": "Reasoning About Knowledge in a Multi-Agent System",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-5-subsection-1",
                            "title": "Some Examples",
                            "content": "variable, 227, 268\nveriﬁcation, 270\nformal, 260\nprogram execution, 316, 319\nprogramming by contract, 296\nEiﬀel, 296\nprogramming language\nimperative, 259\nproof\nbox\nfor →i, 11\nfor forall-introduction, 110\nfor modal logic, 329\nopening, 28\nside by side, 22\nby contradiction, 24\ncalculus, 256, 260\nconstruction, 269\nconstructive, 120\ndashed box, 329, 340\nfragment, 278\nindirect, 29\nof correctness, 239\nof termination, 266\npartial, 281\npartial correctness, 269, 300\nsearch, 49\nsolid box, 329\nstrategy, 115, 265\nsubproof, 272\ntableaux, 269\ntheory, 93, 122, 174\ntotal correctness, 292\nproof rules, 5\nfor implication, 273\nfor assignment, 269\nfor conjunction, 6\nfor disjunction, 16\nfor double negation, 8\nfor equality, 108\nfor existential quantiﬁcation, 112\nfor if-statements, 272, 280\nmodiﬁed, 281\nfor implication, 12, 277\nfor KT45n, 339\nfor negation, 20\nfor quantiﬁers, 112\nfor sequential composition, 269, 275\nfor universal quantiﬁcation, 109\nfor while-statements, 272, 282, 287\nschema, 111\nsubformula property, 113\nproof tableaux\ncomplete, 291\nproof-based veriﬁcation, 172, 256\nproposition, 2\npropositional logic, 93\nprotocol, 187, 188\nprovability\nundecidability of predicate logic, 136\nquantiﬁer, 310, 313\nequivalences, 185\nin predicate logic, 94\nbinding priorities, 101\nequivalences, 130\nmeaning, 123\nQuielle, J., 254\nreachability, 136, 137\nreasoning\nabout knowledge, 326, 331\nconstructive, 29\nin an arbitrary accessible world, 329\ninformal, 343\nquantitative, 259\nunsound, 280\nrecord\nﬁeld, 193\nrecursion\nmutual, 218\nrecursive call, 280\nreductio ad absurdum, 24, 119\nreduction to absurdity, 24\nreﬂexive, transitive closure, 167\nIndex\n425\nregular language, 405\nrelation\nbinary, 178\nEuclidean, 321, 327\nfunctional, 321\nlinear, 321\nreﬂexive, 140, 320, 324\nas formula, 109\nserial, 320, 353\nsymmetric, 320\nas formula, 109\ntotal, 321\ntransition, 178\ntransitive, 140, 320, 324\nas formula, 109\nrelational mu-calculus\nﬁxed-point operators, 392\nrequirement\ninformal, 258, 263, 288\nrequirements, 142\n3.\nA function L : W →P(Atoms), called the labelling function.\nWe write R(x, y) to denote that (x, y) is in R.\nThese models are often called Kripke models, in honour of S. Kripke who\ninvented them and worked extensively in modal logic in the 1950s and 1960s.\nIntuitively, w ∈W stands for a possible world and R(w, w′) means that w′\nis a world accessible from world w. The actual nature of that relationship\ndepends on what we intend to model. Although the deﬁnition of models\nlooks quite complicated, we can use an easy graphical notation to depict\nﬁnite models. We illustrate the graphical notation by an example. Suppose\nW equals {x1, x2, x3, x4, x5, x6} and the relation R is given as follows:\nr R(x1, x2), R(x1, x3), R(x2, x2), R(x2, x3), R(x3, x2), R(x4, x5), R(x5, x4),\nR(x5, x6); and no other pairs are related by R.\nSuppose further that the labelling function behaves as follows:\nx\nx1 x2\nx3\nx4 x5 x6\nL(x) {q} {p, q} {p} {q} ∅{p}\n310\n5 Modal logics and agents\nThen, the Kripke model is illustrated in Figure 5.3. The set W is drawn as\na set of circles, with arrows between them showing the relation R. Within\neach circle is the value of the labelling function in that world. If you have\nread Chapter 3, then you might have noticed that Kripke structures are also\nthe models for CTL, where W is S, the set of states; R is →, the relation\nof state transitions; and L is the labelling function.\nDeﬁnition 5.4 Let M = (W, R, L) be a model of basic modal logic. Sup-\npose x ∈W and φ is a formula of (5.1). We will deﬁne when formula φ is true\nin the world x. This is done via a satisfaction relation x ⊩φ by structural\ninduction on φ:\nx ⊩⊤\nx ̸⊩⊥\nx ⊩p iﬀp ∈L(x)\nx ⊩¬φ iﬀx ̸⊩φ\nx ⊩φ ∧ψ\niﬀx ⊩φ and x ⊩ψ\nx ⊩φ ∨ψ\niﬀx ⊩φ , or x ⊩ψ\nx ⊩φ →ψ\niﬀx ⊩ψ , whenever we have x ⊩φ\nx ⊩φ ↔ψ\niﬀ(x ⊩φ iﬀx ⊩ψ)\nx ⊩2ψ\niﬀ, for each y ∈W with R(x, y), we have y ⊩ψ\nx ⊩3ψ\niﬀthere is a y ∈W such that R(x, y) and y ⊩ψ.\nWhen x ⊩φ holds, we say ‘x satisﬁes φ,’ or ‘φ is true in world x.’ We write\nAF , 395\nEF , 394\nEG , 395\nEU , 395\nEX , 394\nexamples of symbolic evaluation, 395\nfair EG , 398\nfair EU , 397\nfair EX , 397\nset of fair states, 397\ncommand, 261\natomic, 261\ncompound, 261\ncommon knowledge, 332, 335\nas invariant, 390\n420\nIndex\ncommunicating processes, 256\ncommunication protocol, 194\nCompactness Theorem, 137\ncompleteness\nof natural deduction for predicate logic, 96\nof natural deduction for propositional logic,\n54\ncomplexity\nexponential, 229\nof apply, 404\nof brute force minimal-sum section\nalgorithm, 288\nof fairness, 397\nof labelling algorithm, 224, 225\nof labelling EGC, 232\ncomposition\nsequential, 278\nsynchronous, 194\ncompositional semantics, 39\ncompositionality\nin model checking, 230\ncomputability, 131\ncomputation\nintractable, 49\ncomputation path, 180, 212\nfair, 231\ncomputation trace, 285\ncomputation tree logic, 175\ncomputation tree logic, 306, 318\ncomputational behaviour, 306\ncomputer program, 103\nconcatenation, 126, 132\nconclusion, 4, 273\nconcurrency, 257\nconjunct, 56\nconjunction, 4, 291\ninﬁnite, 335\nconnective\nadequate set, 226\nunary, 177, 209\nconsistency, 308, 316\nconsistency checking, 143\nconstant symbol, 157\nconstraints\ninconsistent, 74\nSAT solver, 69\ncontradiction, 20, 118, 319, 325\ncontrol structure, 261, 262\ncontrolling value, 404\ncopy rule, 20, 329\ncore programming language, 259, 287\ncorrespondence theory, 325\ncounter example, 123, 130, 317, 354\ncounter trace, 174\ncritical section, 187\nCTL, 175, 254, 306, 318\nas a subset of CTL*, 218\nexpressive power, 220\nmodalities, 306\nwith boolean combinations of path\nformulas, 220, 251\nCTL connectives\nfair, 397\nCTL formula\nsquare brackets, 210\nCTL*, 254\nDAG, 70\ndag, 364\ndashed box\nﬂavour, 339\ndata structure, 123\nde Morgan laws, 57, 216, 251\nfor modalities, 313\ndeadlock, 178, 184, 215, 219\ndebugging systems, 222\ndebugging systems, 257\ndecision problem, 131\nof validity in predicate logic, 133\ndecision procedure, 55\ndeclarative explanation, 26\ndeclarative sentence, 2, 93\ntruth value, 37\ndefault case, 192\nof KT45, 337\nof KT45n, 337\nof LTL\npictorial representation, 179\nof predicate logic, 96, 124\nunder-speciﬁed, 143\nmodel checker, 174\nmodel checking, 141, 173, 175, 256\nalgorithm, 217, 225, 231, 318\ndebugging, 394\nexample, 182, 213\nwith fairness constraints, 230\nmodel-based veriﬁcation, 172, 174\nmodule, 265\nmodulo 8 counter, 408\nmodus ponens, 9\nIndex\n423\nmodus tollens, 10, 352\nmuddy-children puzzle, 342, 344\nmultiplicity constraint, 152\nMutex model\npictorial representation, 188\nmutual exclusion, 187\nnatural deduction\nextension to predicate logic, 95\nfor modal logic, 332\nfor temporal logic, 174\ninventor, 91\nnatural deduction rules\nfor basic modal logic, 329\nfor KT45n, 340, 355\nfor predicate logic, 107\nfor propositional logic, 27\nnecessity\nlogical, 308, 318\nphysical, 318\nnegation, 4\nnegation-elimination (see\n‘bottom-elimination’), 21\nnegation-introduction, 22\nnested boolean quantiﬁcation, 394\nnetwork\nsynchronous, 174\nno strict sequencing, 188, 189, 215\nnode\ninitial, 364\nleaf, 103\nnon-terminal, 361\nshared, 70\nterminal, 362, 364\nnon-blocking protocol, 188, 189, 215\nnon-determinism, 190\nnon-termination, 262\nnormal form, 53, 55\nconjunctive, 55, 360\ndisjunctive, 360\nnegation, 60\nCTL*, 250\nLTL, 186, 246\nproduct-of-sums, 406\nsum-of-products, 404\nnot-elimination, 21\nnot-introduction, 22\nOBDD, 367\nabsence of redundant variables,\n370\ncanonical form, 369\ncomplementation, 385\ndeﬁnition, 367\nextensions, 381\nfor pre∃(X), 387\nfor pre∀(X), 387\ninteger multiplication, 381\nintersection, 385\nlimitations, 381\nmemoisation, 377\nnested boolean quantiﬁcation, 380\nof a transition relation, 386\nof an even parity function, 370\nof the odd parity function, 400\noptimal ordering, 406\nreduced, 368\nunique representation, 368\nreduced one for logical ‘iﬀ’, 400\nrepresenting subsets, 383\nrunning time of algorithms\nupper bounds, 380\nsensitivity of size, 370\nsynthesis of boolean formula, 380\ntest\nfor implication, 372\nfor satisﬁability, 372\nfor semantic equivalence, 370\nfor validity, 372\nunion, 385\nsmall scope hypothesis, 143\nSMV, 254\nmain program for ABP, 207\nmodule, 193\nreceiver, 205\nsender, 204\nfor channel, 206\ninstantiation, 193\nprocess, 389\nprogram\nexample, 192\nfor Mutex, 195\nspeciﬁcation, 192\nsoftware\nlife-cycle, 142\nmicromodel, 142\nreliability, 149\nrequirements, 142\nspeciﬁcation, 142\nvalidation, 142\nsoundness\nof forall-elimination, 109\nof natural deduction\nbasic modal logic, 354\npredicate logic, 96, 122\npropositional logic, 45\nof program logics, 267\nof proof rule for while-statements,\n282\nof the substitution principle, 108\n426\nIndex\nspeciﬁcation\nfor ABP, 207\nformal, 259\ninformal, 259\nlanguage, 172\nof a predicate, 157\npatterns, 254\npractical pattern, 183, 215\ntruth table, 58\nspeciﬁcations, 191\nSpin, 254\nstate\ncritical, 188\nexplosion, 229\nexplosion problem, 254\nfair, 397\nﬁnal, 142\nformula, 218\nglobal, 188\ngraph, 180\ninitial, 142, 189, 222, 247, 252, 264\nnon-critical, 188\nof a system, 269\nof core program, 264\nreachable, 247\nresulting, 263, 299\nspace, 229\nsplitting states, 190\ntransition, 142\ntrying, 188\nstate machine, 142\nstorage\nlocation, 288\nstate, 261\nstore\nof core program, 264\nstring, 247, 307\nbinary, 126, 132\nempty, 126\nstrongly connected component, 225\nstructural equality, 153\nstructural induction, 44, 51\nsubformula, 178\nsubstitution\nin predicate logic, 105\ninstance, 323\ninstance of tautology, 314\nprinciple, 108\nsymbolic model checking, 383\nsyntactic\ndomain, 260, 261\nsyntax\nof basic modal logic, 307\nof boolean expressions, 261\nof boolean formulas, 398\nof CTL, 208\nof CTL*, 218\nof KT45n, 335\nof LTL, 175\nof predicate logic, 100\nof propositional logic, 33\nof relational mu-calculus, 390\nof terms, 99\nsystem\nasynchronous, 254\ninterleaving model, 389\nsimultaneous model, 389\naxiomatic, 91\ncommercially critical, 172, 257\ncomponent, 206\nconcurrent, 173\ndebugging, 174\ndescription, 193\ndesign, 174\ndevelopment, 173\nelevator, 184, 215\nﬁnite-state, 256\nhybrid, 277\ninﬁnite-state, 256\nmission-critical, 172\nmulti-agent, 331\nphysical, 175\nreactive, 173, 257, 358",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-5-subsection-2",
                            "title": "The Modal Logic KT45n",
                            "content": "erwise, Γ ⊨L ψ holds for all Γ and ψ! In most applications of logic engineering,\nconsistency is easy to establish.\nWe now study a few important modal logics that extend basic modal logic\nwith a consistent set of formula schemes L.\nThe modal logic K\nThe weakest modal logic doesn’t have any chosen\nformula schemes, like those of Tables 5.7 and 5.12. So L = ∅and this modal\nlogic is called K as it satisﬁes all instances of the formula scheme K; modal\nlogics with this property are called normal and all modal logics we study in\nthis text are normal.\nThe modal logic KT45\nA well-known modal logic is KT45 – also called\nS5 in the technical literature – where L = {T, 4, 5} with T, 4 and 5 from\nTable 5.12. This logic is used to reason about knowledge; 2φ means that\nthe agent Q knows φ. Table 5.12 tell us, respectively, that\nT. Truth: the agent Q knows only true things.\n4. Positive introspection: if the agent Q knows something, then she knows\nthat she knows it.\n5. Negative introspection: if the agent Q doesn’t know something, then\nshe knows that she doesn’t know it.\n5.3 Logic engineering\n327\nIn this application, the formula scheme K means logical omniscience: the\nagent’s knowledge is closed under logical consequence. Note that these prop-\nerties represent idealisations of knowledge. Human knowledge has none of\nthese properties! Even computer agents may not have them all. There are\nseveral attempts in the literature to deﬁne logics of knowledge that are more\nrealistic, but we will not consider them here.\nThe semantics of the logic KT45 must consider only relations R which\nare: reﬂexive (T), transitive (4) and Euclidean (5).\nFact 5.16 A relation is reﬂexive, transitive and Euclidean iﬀit is reﬂexive,\ntransitive and symmetric, i.e. if it is an equivalence relation.\nKT45 is simpler than K in the sense that it has few essentially diﬀerent ways\nof composing modalities.\nTheorem 5.17 Any sequence of modal operators and negations in KT45\ntransitive and symmetric, i.e. if it is an equivalence relation.\nKT45 is simpler than K in the sense that it has few essentially diﬀerent ways\nof composing modalities.\nTheorem 5.17 Any sequence of modal operators and negations in KT45\nis equivalent to one of the following: −, 2, 3, ¬, ¬2 and ¬3, where −\nindicates the absence of any negation or modality.\nThe modal logic KT4\nThe modal logic KT4, that is L equals {T, 4},\nis also called S4 in the literature. Correspondence theory tells us that its\nmodels are precisely the Kripke models M = (W, R, L), where R is reﬂexive\nand transitive. Such structures are often very useful in computer science. For\nexample, if φ stands for the type of a piece of code – φ could be int × int →\nbool, indicating some code which expects a pair of integers as input and\noutputs a boolean value – then 2φ could stand for residual code of type φ.\nThus, in the current world x this code would not have to be executed, but\ncould be saved (= residualised) for execution at a later computation stage.\nThe formula scheme 2φ →φ, the axiom T, then means that code may be\nexecuted right away, whereas the formula scheme 2φ →22φ, the axiom 4,\nallows that residual code remain residual, i.e. we can repeatedly postpone its\nexecution in future computation stages. Such type systems have important\napplications in the specialisation and partial evaluation of code. We refer\nthe interested reader to the bibliographic notes at the end of the chapter.\nTheorem 5.18 Any sequence of modal operators and negations in KT4 is\nequivalent to one of the following: −, 2, 3, 23, 32, 232, 323, ¬, ¬2,\n¬3, ¬23, ¬32, ¬232 and ¬323.\nIntuitionistic propositional logic\nIn Chapter 1, we gave a natural de-\nduction system for propositional logic which was sound and complete with\n328\n5 Modal logics and agents\nrespect to semantic entailment based on truth tables. We also pointed out\nthat the proof rules PBC, LEM and ¬¬e are questionable in certain com-\ndistributed among them.\nDeﬁnition 5.23 A formula φ in the multi-modal logic of KT45n is deﬁned\nby the following grammar:\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (φ ↔φ) |\n(Ki φ) | (EG φ) | (CG φ) | (DG φ)\n336\n5 Modal logics and agents\nq\nq\np, q\nx1\nx2\nx4\nx5\np\nx6\np\nx3\nR1\nR1, R2\nR1, R3\nR1, R2\nR3\nFigure 5.13. A KT45n model for n = 3.\nwhere p is any atomic formula, i ∈A and G ⊆A. We simply write E, C and\nD without subscripts if we refer to EA, CA and DA.\nCompare this deﬁnition with Deﬁnition 5.1. Instead of 2, we have several\nmodalities Ki and we also have EG, CG and DG for each G ⊆A. Actually,\nall of these connectives will shortly be seen to be ‘box-like’ rather than\n‘diamond-like’, in the sense that they distribute over ∧rather than over ∨–\ncompare this to the discussion of equivalences on page 308. The ‘diamond-\nlike’ correspondents of these connectives are not explicitly in the language,\nbut may of course be obtained using negations, i.e. ¬Ki¬, ¬CG¬ etc.\nDeﬁnition 5.24 A model M = (W, (Ri)i∈A, L) of the multi-modal logic\nKT45n with the set A of n agents is speciﬁed by three things:\n1.\na set W of possible worlds;\n2.\nfor each i ∈A, an equivalence relation Ri on W (Ri ⊆W × W), called the\naccessibility relations; and\n3.\na labelling function L : W →P(Atoms).\nCompare this with Deﬁnition 5.3. The diﬀerence is that, instead of just one\naccessibility relation, we now have a family, one for each agent in A; and we\nassume the accessibility relations are equivalence relations.\nWe exploit these properties of Ri in the graphical illustrations of Kripke\nmodels for KT45n. For example, a model of KT453 with set of worlds\n{x1, x2, x3, x4, x5, x6} is shown in Figure 5.13. The links between the worlds\nhave to be labelled with the name of the accessibility relation, since we have\nseveral relations. For example, x1 and x2 are related by R1, whereas x4 and\n5.5 Reasoning about knowledge in a multi-agent system\n337\nKT45, require extra rules if one wants to capture their semantic entailment\nvia proofs. In the case of KT45, this extra strength is expressed by rule\nschemes for the axioms T, 4 and 5:\n2φ\nφ\nT\n2φ\n22φ\n4\n¬2φ\n2¬2φ\n5\nAn equivalent alternative to the rules 4 and 5 would be to stipulate relax-\nations of the rules about moving formulas in and out of dashed boxes. Since\nrule 4 allows us to double-up boxes, we could instead think of it as allowing\nus to move formulas beginning with 2 into dashed boxes. Similarly, axiom\n5 has the eﬀect of allowing us to move formulas beginning with ¬2 into\ndashed boxes. Since 5 is a scheme and since φ and ¬¬φ are equivalent in ba-\nsic modal logic, we could write ¬φ instead of φ throughout without changing\nthe expressive power and meaning of that axiom.\nDeﬁnition 5.20 Let L be a set of formula schemes. We say that Γ ⊢L ψ is\nvalid if ψ has a proof in the natural deduction system for basic modal logic\nextended with the axioms from L and premises from Γ.\nExamples 5.21 We show that the following sequents are valid:\n1.\n|−K 2p ∧2q →2(p ∧q).\n1\n2p ∧2q\nassumption\n2\n2p\n∧e1 1\n3\n2q\n∧e2 1\n4\np\n2e 2\n5\nq\n2e 3\n6\np ∧q\n∧i 4, 5\n7\n2(p ∧q)\n2i 4−6\n8\n2p ∧2q →2(p ∧q)\n→i 1−7\n5.5 Reasoning about knowledge in a multi-agent system\n331\n2.\n|−KT45 p →23p.\n1\np\nassumption\n2\n2¬p\nassumption\n3\n¬p\nT 2\n4\n⊥\n¬e 1, 3\n5\n¬2¬p\n¬i 2−4\n6\n2¬2¬p\naxiom 5 on line 5\n7\np →2¬2¬p\n→i 1−6\n3.\n|−KT45 232p →2p.\n1\n2¬2¬2p\nassumption\n2\n¬2¬2p\n2e 1\n3\n¬2p\nassumption\n4\n2¬2p\naxiom 5 on line 3\n5\n⊥\n¬e 4, 2\n6\n¬¬2p\n¬i 3−5\n7\n2p\n¬¬e 6\n8\np\nT 7\n9\n2p\n2i 2−8\n10\n2¬2¬2p →2p\n→i 1−9\n5.5 Reasoning about knowledge in\na multi-agent system\nIn a multi-agent system, diﬀerent agents have diﬀerent knowledge of the\nworld. An agent may need to reason about its own knowledge about the\nworld; it may also need to reason about what other agents know about\nthe world. For example, in a bargaining situation, the seller of a car must\nconsider what a buyer knows about the car’s value. The buyer must also\nterms of the Ki and CG is deﬁned in terms of EG.\nMany of the results we had for basic modal logic with a single accessi-\nbility relation also hold in this more general setting of several accessibility\nrelations. Summarising,\nr a frame F for KT45n (W, (Ri)i∈A) for the modal logic KT45n is a set W of\nworlds and, for each i ∈A, an equivalence relation Ri on W.\nr a frame F = (W, (Ri)i∈A) for KT45n is said to satisfy φ if, for each labelling\nfunction L: W →P(Atoms) and each w ∈W, we have M, w ⊩φ holds, where\nM = (W, (Ri)i∈A, L). In that case, we say that F ⊨φ holds.\nThe following theorem is useful for answering questions about formu-\nlas involving E and C. Let M = (W, (Ri)i∈A, L) be a model for KT45n\n338\n5 Modal logics and agents\nand x, y ∈W. We say that y is G-reachable in k steps from x if there are\nw1, w2, . . . , wk−1 ∈W and i1, i2, . . . , ik in G such that\nx Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y\nmeaning Ri1(x, w1), Ri2(w1, w2), . . . , Rik(wk, y). We also say that y is G-\nreachable from x if there is some k such that it is G-reachable in k steps.\nTheorem 5.26\n1.\nx ⊩Ek\nGφ iﬀ, for all y that are G-reachable from x in k steps, we have y ⊩φ.\n2.\nx ⊩CG φ iﬀ, for all y that are G-reachable from x, we have y ⊩φ.\nPROOF:\n1.\nFirst, suppose y ⊩φ for all y G-reachable from x in k steps. We will prove\nthat x ⊩Ek\nGφ holds. It is suﬃcient to show that x ⊩Ki1Ki2 . . . Kik φ for any\ni1, i2, . . . , ik ∈G. Take any i1, i2, . . . , ik ∈G and any w1, w2,. . . , wk−1 and y\nsuch that there is a path of the form x Ri1 w1 Ri2 w2 . . . Rik−1 wk−1 Rik y. Since\ny is G-reachable from x in k steps, we have y ⊩φ by our assumption, so x ⊩\nKi1Ki2 . . . Kik φ as required.\nConversely, suppose x ⊩Ek\nGφ holds and y is G-reachable from x in k steps. We\nmust show that y ⊩φ holds. Take i1, i2, . . . , ik by G-reachability; since x ⊩Ek\nGφ\nimplies x ⊩Ki1Ki2 . . . Kik φ, we have y ⊩φ.\n2.\nThis argument is similar.\nSome valid formulas in KT45n\nThe formula K holds for the connec-",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-5-subsection-3",
                            "title": "Natural Deduction for KT45n",
                            "content": "KT45, require extra rules if one wants to capture their semantic entailment\nvia proofs. In the case of KT45, this extra strength is expressed by rule\nschemes for the axioms T, 4 and 5:\n2φ\nφ\nT\n2φ\n22φ\n4\n¬2φ\n2¬2φ\n5\nAn equivalent alternative to the rules 4 and 5 would be to stipulate relax-\nations of the rules about moving formulas in and out of dashed boxes. Since\nrule 4 allows us to double-up boxes, we could instead think of it as allowing\nus to move formulas beginning with 2 into dashed boxes. Similarly, axiom\n5 has the eﬀect of allowing us to move formulas beginning with ¬2 into\ndashed boxes. Since 5 is a scheme and since φ and ¬¬φ are equivalent in ba-\nsic modal logic, we could write ¬φ instead of φ throughout without changing\nthe expressive power and meaning of that axiom.\nDeﬁnition 5.20 Let L be a set of formula schemes. We say that Γ ⊢L ψ is\nvalid if ψ has a proof in the natural deduction system for basic modal logic\nextended with the axioms from L and premises from Γ.\nExamples 5.21 We show that the following sequents are valid:\n1.\n|−K 2p ∧2q →2(p ∧q).\n1\n2p ∧2q\nassumption\n2\n2p\n∧e1 1\n3\n2q\n∧e2 1\n4\np\n2e 2\n5\nq\n2e 3\n6\np ∧q\n∧i 4, 5\n7\n2(p ∧q)\n2i 4−6\n8\n2p ∧2q →2(p ∧q)\n→i 1−7\n5.5 Reasoning about knowledge in a multi-agent system\n331\n2.\n|−KT45 p →23p.\n1\np\nassumption\n2\n2¬p\nassumption\n3\n¬p\nT 2\n4\n⊥\n¬e 1, 3\n5\n¬2¬p\n¬i 2−4\n6\n2¬2¬p\naxiom 5 on line 5\n7\np →2¬2¬p\n→i 1−6\n3.\n|−KT45 232p →2p.\n1\n2¬2¬2p\nassumption\n2\n¬2¬2p\n2e 1\n3\n¬2p\nassumption\n4\n2¬2p\naxiom 5 on line 3\n5\n⊥\n¬e 4, 2\n6\n¬¬2p\n¬i 3−5\n7\n2p\n¬¬e 6\n8\np\nT 7\n9\n2p\n2i 2−8\n10\n2¬2¬2p →2p\n→i 1−9\n5.5 Reasoning about knowledge in\na multi-agent system\nIn a multi-agent system, diﬀerent agents have diﬀerent knowledge of the\nworld. An agent may need to reason about its own knowledge about the\nworld; it may also need to reason about what other agents know about\nthe world. For example, in a bargaining situation, the seller of a car must\nconsider what a buyer knows about the car’s value. The buyer must also\ncan think of the rules K4 and K5 and C4 and C5 as relaxations of the\n340\n5 Modal logics and agents\nKi\n...\nφ\nKiφ\nKii\nEG\n...\nφ\nEGφ\nEGi\nCG\n...\nφ\nCGφ\nCGi\nKiφ\nKi\n...\nφ\n...\nKie\nEGφ\nEG\n...\nφ\n...\nEGe\nCGφ\nCG\n...\nφ\n...\nCGe\nKi φ for each i ∈G\nEG φ\nKE\nEG φ\ni ∈G\nKi φ\nEKi\nCG φ\nEG . . . EG φ\nCE\nCG φ\nij ∈G\nKi1 . . . Kik φ\nCK\nCG φ\nCGCG φ\nC4\n¬CG φ\nCG¬CG φ\nC5\nKi φ\nφ\nKT\nKi φ\nKiKi φ\nK4\n¬Ki φ\nKi¬Ki φ\nK5\nFigure 5.14. Natural deduction rules for KT45n.\nrules about moving formulas in and out of dashed proof boxes. Since rule\nK4 allows us to double-up Ki, we could instead think of it as allowing us\nto move formulas beginning with Ki into Ki-dashed boxes. Similarly, rule\nC5 has the eﬀect of allowing us to move formulas beginning with ¬CG into\nCG-dashed boxes.\nAn intuitive way of thinking about the dashed boxes is that formulas in\nthem are known to the agent in question. When you open a Ki-dashed box,\nyou are considering what agent i knows. It’s quite intuitive that an ordinary\nformula φ cannot be brought into such a dashed box, because the mere truth\nof φ does not mean that agent i knows it. In particular, you can’t use the\nrule ¬i if one of the premises of the rule is outside the dashed box you’re\nworking in.\n5.5 Reasoning about knowledge in a multi-agent system\n341\n1\nC(p ∨q)\npremise\n2\nK1(K2 p ∨K2 ¬p)\npremise\n3\nK1¬K2 q\npremise\n4\nK1K2 (p ∨q)\nCK 1\nK1\n5\nK2 (p ∨q)\nK1e 4\n6\nK2 p ∨K2 ¬p\nK1e 2\n7\n¬K2 q\nK1e 3\n8\nK2 p\nassumption\n9\np\naxiom T 8\n10\n11\n12\n13\n14\nK2 ¬p\nassumption\nK2\n¬p\nK2e 8\np ∨q\nK2e 5\nq\nprop 9, 10\nK2 q\nK2i 9−11\n⊥\n¬e 12, 7\np\n⊥e 13\n15\np\n∨e 6, 8−14, 8−14\n16\nK1 p\nK1i 5−15\nFigure 5.15. A proof of C(p ∨q), K1(K2p ∨K2 ¬p), K1¬K2 q |−K1 p.\nObserve the power of C φ in the premises: we can bring φ into any dashed\nbox by the application of the rules CK and Kie, no matter how deeply nested\nboxes are. The rule Ek φ, on the other hand, ensures that φ can be brought\ninto any dashed box with nesting ≤k. Compare this with Theorem 5.26.\nExample 5.27 We show that the sequent1 C(p ∨q), K1(K2p ∨K2 ¬p),\ndistributed among them.\nDeﬁnition 5.23 A formula φ in the multi-modal logic of KT45n is deﬁned\nby the following grammar:\nφ ::= ⊥| ⊤| p | (¬φ) | (φ ∧φ) | (φ ∨φ) | (φ →φ) | (φ ↔φ) |\n(Ki φ) | (EG φ) | (CG φ) | (DG φ)\n336\n5 Modal logics and agents\nq\nq\np, q\nx1\nx2\nx4\nx5\np\nx6\np\nx3\nR1\nR1, R2\nR1, R3\nR1, R2\nR3\nFigure 5.13. A KT45n model for n = 3.\nwhere p is any atomic formula, i ∈A and G ⊆A. We simply write E, C and\nD without subscripts if we refer to EA, CA and DA.\nCompare this deﬁnition with Deﬁnition 5.1. Instead of 2, we have several\nmodalities Ki and we also have EG, CG and DG for each G ⊆A. Actually,\nall of these connectives will shortly be seen to be ‘box-like’ rather than\n‘diamond-like’, in the sense that they distribute over ∧rather than over ∨–\ncompare this to the discussion of equivalences on page 308. The ‘diamond-\nlike’ correspondents of these connectives are not explicitly in the language,\nbut may of course be obtained using negations, i.e. ¬Ki¬, ¬CG¬ etc.\nDeﬁnition 5.24 A model M = (W, (Ri)i∈A, L) of the multi-modal logic\nKT45n with the set A of n agents is speciﬁed by three things:\n1.\na set W of possible worlds;\n2.\nfor each i ∈A, an equivalence relation Ri on W (Ri ⊆W × W), called the\naccessibility relations; and\n3.\na labelling function L : W →P(Atoms).\nCompare this with Deﬁnition 5.3. The diﬀerence is that, instead of just one\naccessibility relation, we now have a family, one for each agent in A; and we\nassume the accessibility relations are equivalence relations.\nWe exploit these properties of Ri in the graphical illustrations of Kripke\nmodels for KT45n. For example, a model of KT453 with set of worlds\n{x1, x2, x3, x4, x5, x6} is shown in Figure 5.13. The links between the worlds\nhave to be labelled with the name of the accessibility relation, since we have\nseveral relations. For example, x1 and x2 are related by R1, whereas x4 and\n5.5 Reasoning about knowledge in a multi-agent system\n337\ntransitive and symmetric, i.e. if it is an equivalence relation.\nKT45 is simpler than K in the sense that it has few essentially diﬀerent ways\nof composing modalities.\nTheorem 5.17 Any sequence of modal operators and negations in KT45\nis equivalent to one of the following: −, 2, 3, ¬, ¬2 and ¬3, where −\nindicates the absence of any negation or modality.\nThe modal logic KT4\nThe modal logic KT4, that is L equals {T, 4},\nis also called S4 in the literature. Correspondence theory tells us that its\nmodels are precisely the Kripke models M = (W, R, L), where R is reﬂexive\nand transitive. Such structures are often very useful in computer science. For\nexample, if φ stands for the type of a piece of code – φ could be int × int →\nbool, indicating some code which expects a pair of integers as input and\noutputs a boolean value – then 2φ could stand for residual code of type φ.\nThus, in the current world x this code would not have to be executed, but\ncould be saved (= residualised) for execution at a later computation stage.\nThe formula scheme 2φ →φ, the axiom T, then means that code may be\nexecuted right away, whereas the formula scheme 2φ →22φ, the axiom 4,\nallows that residual code remain residual, i.e. we can repeatedly postpone its\nexecution in future computation stages. Such type systems have important\napplications in the specialisation and partial evaluation of code. We refer\nthe interested reader to the bibliographic notes at the end of the chapter.\nTheorem 5.18 Any sequence of modal operators and negations in KT4 is\nequivalent to one of the following: −, 2, 3, 23, 32, 232, 323, ¬, ¬2,\n¬3, ¬23, ¬32, ¬232 and ¬323.\nIntuitionistic propositional logic\nIn Chapter 1, we gave a natural de-\nduction system for propositional logic which was sound and complete with\n328\n5 Modal logics and agents\nrespect to semantic entailment based on truth tables. We also pointed out\nthat the proof rules PBC, LEM and ¬¬e are questionable in certain com-\nEG φ →EGEG φ is not valid; if it were valid, it would imply that common\nknowledge was nothing more than knowledge by everybody. The scheme\n¬EG φ →EG¬EG φ is also not valid. The failure of these formulas to be\nvalid can be traced to the fact that REG is not necessarily an equivalence\nrelation, even though each Ri is an equivalence relation. However, REG is\nreﬂexive, so EG φ →φ is valid, provided that G ̸= ∅. If G = ∅, then EG φ\nholds vacuously, even if φ is false.\nSince RCG is an equivalence relation, the formulas T, 4 and 5 above do\nhold for CG, although the third one still requires the condition that G ̸= ∅.\n5.5.3 Natural deduction for KT45n\nThe proof system for KT45 is easily extended to KT45n; but for simplicity,\nwe omit reference to the connective D.\n1.\nThe dashed boxes now come in diﬀerent ‘ﬂavours’ for diﬀerent modal connec-\ntives; we’ll indicate the modality in the top left corner of the dashed box.\n2.\nThe axioms T, 4 and 5 can be used for any Ki, whereas axioms 4 and 5 can be\nused for CG, but not for EG – recall the discussion in Section 5.5.2.\n3.\nIn the rule CE, we may deduce Ek\nGφ from CG φ for any k; or we could go\ndirectly to Ki1 . . . Kik φ for any agents i1, . . . , ik∈G by using the rule CK.\nStrictly speaking, these rules are a whole set of such rules, one for each choice\nof k and i1, . . . , ik, but we refer to all of them as CE and CK respectively.\n4.\nApplying rule EKi, we may deduce Ki φ from EG φ for any i ∈G. From\n\u0001\ni∈G Ki φ we may deduce EG φ by virtue of rule KE. Note that the proof\nrule EKi is like a generalised and-elimination rule, whereas KE behaves like\nan and-introduction rule.\nThe proof rules for KT45n are summarised in Figure 5.14. As before, we\ncan think of the rules K4 and K5 and C4 and C5 as relaxations of the\n340\n5 Modal logics and agents\nKi\n...\nφ\nKiφ\nKii\nEG\n...\nφ\nEGφ\nEGi\nCG\n...\nφ\nCGφ\nCGi\nKiφ\nKi\n...\nφ\n...\nKie\nEGφ\nEG\n...\nφ\n...\nEGe\nCGφ\nCG\n...\nφ\n...\nCGe\nKi φ for each i ∈G\nEG φ\nKE\nEG φ\ni ∈G\nKi φ\nEKi\nCG φ\nEG . . . EG φ\nCE\nCG φ\nij ∈G",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-5-subsection-4",
                            "title": "Formalising the Examples",
                            "content": "3.\nA function L : W →P(Atoms), called the labelling function.\nWe write R(x, y) to denote that (x, y) is in R.\nThese models are often called Kripke models, in honour of S. Kripke who\ninvented them and worked extensively in modal logic in the 1950s and 1960s.\nIntuitively, w ∈W stands for a possible world and R(w, w′) means that w′\nis a world accessible from world w. The actual nature of that relationship\ndepends on what we intend to model. Although the deﬁnition of models\nlooks quite complicated, we can use an easy graphical notation to depict\nﬁnite models. We illustrate the graphical notation by an example. Suppose\nW equals {x1, x2, x3, x4, x5, x6} and the relation R is given as follows:\nr R(x1, x2), R(x1, x3), R(x2, x2), R(x2, x3), R(x3, x2), R(x4, x5), R(x5, x4),\nR(x5, x6); and no other pairs are related by R.\nSuppose further that the labelling function behaves as follows:\nx\nx1 x2\nx3\nx4 x5 x6\nL(x) {q} {p, q} {p} {q} ∅{p}\n310\n5 Modal logics and agents\nThen, the Kripke model is illustrated in Figure 5.3. The set W is drawn as\na set of circles, with arrows between them showing the relation R. Within\neach circle is the value of the labelling function in that world. If you have\nread Chapter 3, then you might have noticed that Kripke structures are also\nthe models for CTL, where W is S, the set of states; R is →, the relation\nof state transitions; and L is the labelling function.\nDeﬁnition 5.4 Let M = (W, R, L) be a model of basic modal logic. Sup-\npose x ∈W and φ is a formula of (5.1). We will deﬁne when formula φ is true\nin the world x. This is done via a satisfaction relation x ⊩φ by structural\ninduction on φ:\nx ⊩⊤\nx ̸⊩⊥\nx ⊩p iﬀp ∈L(x)\nx ⊩¬φ iﬀx ̸⊩φ\nx ⊩φ ∧ψ\niﬀx ⊩φ and x ⊩ψ\nx ⊩φ ∨ψ\niﬀx ⊩φ , or x ⊩ψ\nx ⊩φ →ψ\niﬀx ⊩ψ , whenever we have x ⊩φ\nx ⊩φ ↔ψ\niﬀ(x ⊩φ iﬀx ⊩ψ)\nx ⊩2ψ\niﬀ, for each y ∈W with R(x, y), we have y ⊩ψ\nx ⊩3ψ\niﬀthere is a y ∈W such that R(x, y) and y ⊩ψ.\nWhen x ⊩φ holds, we say ‘x satisﬁes φ,’ or ‘φ is true in world x.’ We write\nset of n-tuples over A, to A; and\n4.\nfor each P ∈P with arity n > 0, a subset P M ⊆An of n-tuples over A.\n2.4 Semantics of predicate logic\n125\nThe distinction between f and fM and between P and P M is most im-\nportant. The symbols f and P are just that: symbols, whereas fM and\nP M denote a concrete function (or element) and relation in a model M,\nrespectively.\nExample 2.15 Let F\ndef\n= {i} and P\ndef\n= {R, F}; where i is a constant, F a\npredicate symbol with one argument and R a predicate symbol with two\narguments. A model M contains a set of concrete elements A – which may be\na set of states of a computer program. The interpretations iM, RM, and F M\nmay then be a designated initial state, a state transition relation, and a set\nof ﬁnal (accepting) states, respectively. For example, let A\ndef\n= {a, b, c}, iM def\n=\na, RM def\n= {(a, a), (a, b), (a, c), (b, c), (c, c)}, and F M def\n= {b, c}. We informally\ncheck some formulas of predicate logic for this model:\n1.\nThe formula\n∃y R(i, y)\nsays that there is a transition from the initial state to some state; this is true\nin our model, as there are transitions from the initial state a to a, b, and c.\n2.\nThe formula\n¬F(i)\nstates that the initial state is not a ﬁnal, accepting state. This is true in our\nmodel as b and c are the only ﬁnal states and a is the intitial one.\n3.\nThe formula\n∀x∀y∀z (R(x, y) ∧R(x, z) →y = z)\nmakes use of the equality predicate and states that the transition relation is\ndeterministic: all transitions from any state can go to at most one state (there\nmay be no transitions from a state as well). This is false in our model since\nstate a has transitions to b and c.\n4.\nThe formula\n∀x∃y R(x, y)\nstates that the model is free of states that deadlock: all states have a transition\nto some state. This is true in our model: a can move to a, b or c; and b and c\ncan move to c.\nExample 2.16 Let F\ndef\n= {e, ·} and P\ndef\n= {≤}, where e is a constant, · is a\n2.\nTry to prove that ⊢AR η ∧¬B →ψ and ⊢AR φ →η are valid, where B is the\nboolean guard of the while-statement. If both proofs succeed, go to 3. Otherwise\n(if at least one proof fails), go back to 1.\n3.\nPush η upwards through the body C of the while-statement; this involves ap-\nplying other rules dictated by the form of C. Let us name the formula that\nemerges η′.\n286\n4 Program verification\n4.\nTry to prove that ⊢AR η ∧B →η′ is valid; this proves that η is indeed an in-\nvariant. If you succeed, go to 5. Otherwise, go back to 1.\n5.\nNow write η above the while-statement and write φ above that η, annotating\nthat η with an instance of Implied based on the successful proof of the validity\nof ⊢AR φ →η in 2. Mission accomplished!\nExample 4.17 We continue the example of the factorial. The partial proof\nobtained by pushing y = x! upwards through the while-statement – thus\nchecking the hypothesis that y = z! is an invariant – is as follows:\ny = 1;\nz = 0;\n\u0001\ny = z!\n\u0002\n?\nwhile (z != x) {\n\u0001\ny = z! ∧z ̸= x\n\u0002\nInvariant Hyp. ∧guard\n\u0001\ny · (z + 1) = (z + 1)!\n\u0002\nImplied\nz = z + 1;\n\u0001\ny · z = z!\n\u0002\nAssignment\ny = y * z;\n\u0001\ny = z!\n\u0002\nAssignment\n} \u0001\ny = x!\n\u0002\n?\nWhether y = z! is a suitable invariant depends on three things:\nr The ability to prove that it is indeed an invariant, i.e. that y = z! implies y · (z +\n1) = (z + 1)!. This is the case, since we just multiply each side of y = z! by z + 1\nand appeal to the inductive deﬁnition of (z + 1)! in Example 4.2.\nr The ability to prove that η is strong enough that it and the negation of the\nboolean guard together imply the postcondition; this is also the case, for y = z!\nand x = z imply y = x!.\nr The ability to prove that η is weak enough to be established by the code leading\nup to the while-statement. This is what we prove by continuing to push the result\nupwards through the code preceding the while-statement.\nContinuing, then: pushing y = z! through z = 0 results in y = 0! and push-\n(c) For each formula of the previous item, ﬁnd a world which does not satisfy\nthe formula.\n2. Find a Kripke model M and a formula scheme which is not satisﬁed in M, but\nwhich has true instances in M.\n5.6 Exercises\n351\n3. Consider the Kripke model M = (W, R, L) where W = {a, b, c, d, e}; R =\n{(a, c), (a, e), (b, a), (b, c), (d, e), (e, a)}; and L(a) = {p}, L(b) = {p, q}, L(c) =\n{p, q}, L(d) = {q} and L(e) = ∅.\n(a) Draw a graph for M.\n(b) Investigate which of the formulas in exercise 1(b) on page 350 have a world\nwhich satisﬁes it.\n4. (a) Think about what you have to do to decide whether p →23q is true in a\nmodel.\n(b)\n*\nFind a model in which it is true and one in which it is false.\n5. For each of the following pairs of formulas, can you ﬁnd a model and a world in\nit which distinguishes them, i.e. makes one of them true and one false? In that\ncase, you are showing that they do not entail each other. If you cannot, it might\nmean that the formulas are equivalent. Justify your answer.\n(a) 2p and 22p\n(b) 2¬p and ¬3p\n(c) 2(p ∧q) and 2p ∧2q\n(d)\n*\n3(p ∧q) and 3p ∧3q\n(e) 2(p ∨q) and 2p ∨2q\n(f)\n*\n3(p ∨q) and 3p ∨3q\n(g) 2(p →q) and 2p →2q\n(h) 3⊤and ⊤\n(i) 2⊤and ⊤\n(j) 3⊥and ⊥.\n6. Show that the following formulas of basic modal logic are valid:\n(a)\n*\n2(φ ∧ψ) ↔(2φ ∧2ψ)\n(b) 3(φ ∨ψ) ↔(3φ ∨3ψ)\n(c)\n*\n2⊤↔⊤\n(d) 3⊥↔⊥\n(e) 3⊤→(2φ →3φ)\n7. Inspect Deﬁnition 5.4. We said that we deﬁned x ⊩φ by structural induction on\nφ. Is this really correct? Note the implicit deﬁnition of a second relation x ̸⊩φ.\nWhy is this deﬁnition still correct and in what sense does it still rely on structural\ninduction?\nExercises 5.3\n1. For which of the readings of 2 in Table 5.7 are the formulas below valid?\n(a)\n*\n(φ →2φ) →(φ →3φ)\n(b) (2φ →(φ ∧22φ ∧3φ)) →((2φ →(φ ∧22φ)) ∧(3φ →23φ)).\n2. Dynamic logic: Let P range over the programs of our core language in Chapter 4.\nConsider a modal logic whose modal operators are ⟨P⟩and [P] for all such\nprograms P. Evaluate such formulas in stores l as in Deﬁnition 4.3 (page 264).\n352\nlong as they match the pattern required by the respective rule. For example,\n32\n1 Propositional logic\nthe application of the proof rule →e in\n1\np →q\npremise\n2\np\npremise\n3\nq\n→e 1, 2\nis equally valid if we substitute p with p ∨¬r and q with r →p:\n1\np ∨¬r →(r →p)\npremise\n2\np ∨¬r\npremise\n3\nr →p\n→e 1, 2\nThis is why we expressed such rules as schemes with Greek symbols stand-\ning for generic formulas. Yet, it is time that we make precise the notion of\n‘any formula we may form.’ Because this text concerns various logics, we will\nintroduce in (1.3) an easy formalism for specifying well-formed formulas. In\ngeneral, we need an unbounded supply of propositional atoms p, q, r, . . ., or\np1, p2, p3, . . . You should not be too worried about the need for inﬁnitely\nmany such symbols. Although we may only need ﬁnitely many of these\npropositions to describe a property of a computer program successfully, we\ncannot specify how many such atomic propositions we will need in any con-\ncrete situation, so having inﬁnitely many symbols at our disposal is a cheap\nway out. This can be compared with the potentially inﬁnite nature of En-\nglish: the number of grammatically correct English sentences is inﬁnite, but\nﬁnitely many such sentences will do in whatever situation you might be in\n(writing a book, attending a lecture, listening to the radio, having a dinner\ndate, . . . ).\nFormulas in our propositional logic should certainly be strings over the\nalphabet {p, q, r, . . . } ∪{p1, p2, p3, . . . } ∪{¬, ∧, ∨, →, (, )}. This is a trivial\nobservation and as such is not good enough for what we are trying to capture.\nFor example, the string (¬)() ∨pq →is a word over that alphabet, yet, it\ndoes not seem to make a lot of sense as far as propositional logic is concerned.\nSo what we have to deﬁne are those strings which we want to call formulas.\nWe call such formulas well-formed.\nDeﬁnition 1.27 The well-formed formulas of propositional logic are those",
                            "children": []
                        }
                    ]
                }
            ]
        },
        {
            "id": "chapter-1",
            "title": "Binary Decision Diagrams",
            "content": null,
            "children": [
                {
                    "id": "chapter-1-section-1",
                    "title": "Representing Boolean Functions",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-1-subsection-1",
                            "title": "Propositional Formulas and Truth Tables",
                            "content": "well-formed:\n(a) p ∧¬(p ∨¬q) →(r →s)\n(b) p ∧¬(p ∨q ∧s) →(r →s)\n(c) p ∧¬(p ∨∧s) →(r →s).\nAmong the ill-formed formulas above which ones, and in how many ways, could\nyou ‘ﬁx’ by the insertion of brackets only?\nExercises 1.4\n1.\n*\nConstruct the truth table for ¬p ∨q and verify that it coincides with the one for\np →q. (By ‘coincide’ we mean that the respective columns of T and F values are\nthe same.)\n2. Compute the complete truth table of the formula\n(a)\n*\n((p →q) →p) →p\n(b) represented by the parse tree in Figure 1.3 on page 34\n1.7 Exercises\n83\n¬\n→\n¬\nr\n∨\np\n∧\nq\n¬\np\nFigure 1.22. A parse tree of a negated implication.\n84\n1 Propositional logic\n¬\n→\n¬\n∧\n→\nq\np\n∨\nq\nr\np\nFigure 1.23. Another parse tree of a negated implication.\n(c)\n*\np ∨(¬(q ∧(r →q)))\n(d) (p ∧q) →(p ∨q)\n(e) ((p →¬q) →¬p) →q\n(f) (p →q) ∨(p →¬q)\n(g) ((p →q) →p) →p\n(h) ((p ∨q) →r) →((p →r) ∨(q →r))\n(i) (p →q) →(¬p →¬q).\n3. Given a valuation and a parsetree of a formula, compute the truth value of the\nformula for that valuation (as done in a bottom-up fashion in Figure 1.7 on\npage 40) with the parse tree in\n(a)\n*\nFigure 1.10 on page 44 and the valuation in which q and r evaluate to T and\np to F;\n(b) Figure 1.4 on page 36 and the valuation in which q evaluates to T and p and\nr evaluate to F;\n(c) Figure 1.23 where we let p be T, q be F and r be T; and\n(d) Figure 1.23 where we let p be F, q be T and r be F.\n4. Compute the truth value on the formula’s parse tree, or specify the corresponding\nline of a truth table where\n(a)\n*\np evaluates to F, q to T and the formula is p →(¬q ∨(q →p))\n(b)\n*\nthe formula is ¬((¬q ∧(p →r)) ∧(r →q)), p evaluates to F, q to T and r\nevaluates to T.\n1.7 Exercises\n85\n5.\n*\nA formula is valid iﬀit computes T for all its valuations; it is satisﬁable iﬀit\ncomputes T for at least one of its valuations. Is the formula of the parse tree in\nFigure 1.10 on page 44 valid? Is it satisﬁable?\n6. Let ∗be a new logical connective such that p ∗q does not hold iﬀp and q are\neither both false or both true.\ndiﬀerent syntactically and natural deduction treats them diﬀerently as well.\nBut using the truth tables for ¬ and ∨you can check that φ →ψ evaluates\n1.4 Semantics of propositional logic\n39\nto T iﬀ¬φ ∨ψ does so. This means that φ →ψ and ¬φ ∨ψ are semantically\nequivalent; more on that in Section 1.5.\nGiven a formula φ which contains the propositional atoms p1, p2, . . . , pn,\nwe can construct a truth table for φ, at least in principle. The caveat is that\nthis truth table has 2n many lines, each line listing a possible combination\nof truth values for p1, p2, . . . , pn; and for large n this task is impossible to\ncomplete. Our aim is thus to compute the value of φ for each of these 2n\ncases for moderately small values of n. Let us consider the example φ in\nFigure 1.3. It involves three propositional atoms (n = 3) so we have 23 = 8\ncases to consider.\nWe illustrate how things go for one particular case, namely for the val-\nuation in which q evaluates to F; and p and r evaluate to T. What does\n¬p ∧q →p ∧(q ∨¬r) evaluate to? Well, the beauty of our semantics is that\nit is compositional. If we know the meaning of the subformulas ¬p ∧q and\np ∧(q ∨¬r), then we just have to look up the appropriate line of the →\ntruth table to ﬁnd the value of φ, for φ is an implication of these two sub-\nformulas. Therefore, we can do the calculation by traversing the parse tree\nof φ in a bottom-up fashion. We know what its leaves evaluate to since we\nstated what the atoms p, q and r evaluated to. Because the meaning of p is\nT, we see that ¬p computes to F. Now q is assumed to represent F and the\nconjunction of F and F is F. Thus, the left subtree of the node →evaluates\nto F. As for the right subtree of →, r stands for T so ¬r computes to F and q\nmeans F, so the disjunction of F and F is still F. We have to take that result,\nF, and compute its conjunction with the meaning of p which is T. Since the\nconjunction of T and F is F, we get F as the meaning of the right subtree\nscience: no eﬃcient algorithms for this task are known, and it is strongly\nsuspected that there aren’t any. Similarly, deciding whether two arbitrary\npropositional formulas f and g denote the same boolean function is sus-\npected to be exponentially expensive.\nIt is straightforward to see how to perform the boolean operations ·, +, ⊕\nand ¯ on these two representations. In the case of truth tables, they involve\napplying the operation to each line; for example, given truth tables for f and\ng over the same set of variables (and in the same order), the truth table for\nf ⊕g is obtained by applying ⊕to the truth value of f and g in each line. If\nf and g do not have the same set of arguments, it is easy to pad them out\nby adding further arguments. In the case of representation by propositional\nformulas, the operations ·, ⊕, etc., are simply syntactic manipulations. For\nexample, given formulas φ and ψ representing the functions f and g, the\nformulas representing f · g and f ⊕g are, respectively, φ ∧ψ and (φ ∧¬ψ) ∨\n(¬φ ∧ψ).\nWe could also consider representing boolean functions by various sub-\nclasses of propositional formulas, such as conjunctive and disjunctive normal\nforms. In the case of disjunctive normal form (DNF, in which a formula is a\ndisjunction of conjunctions of literals), the representation is sometimes com-\npact, but in the worst cases it can be very lengthy. Checking satisﬁability is a\nstraightforward operation, however, because it is suﬃcient to ﬁnd a disjunct\nwhich does not have two complementary literals. Unfortunately, there is not\na similar way of checking validity. Performing + on two formulas in DNF\nsimply involves inserting ∨between them. Performing · is more complicated;\nwe cannot simply insert ∧between the two formulas, because the result will\nnot in general be in DNF, so we have to perform lengthy applications of\nthe distributivity rule φ ∧(ψ1 ∨ψ2) ≡(φ ∧ψ1) ∨(φ ∧ψ1). Computing the\nnegation of a DNF formula is also expensive. The DNF formula φ may be\nmeans F, so the disjunction of F and F is still F. We have to take that result,\nF, and compute its conjunction with the meaning of p which is T. Since the\nconjunction of T and F is F, we get F as the meaning of the right subtree\nof →. Finally, to evaluate the meaning of φ, we compute F →F which is T.\nFigure 1.7 shows how the truth values propagate upwards to reach the root\nwhose associated truth value is the truth value of φ given the meanings of\np, q and r above.\nIt should now be quite clear how to build a truth table for more com-\nplex formulas. Figure 1.8 contains a truth table for the formula (p →¬q) →\n(q ∨¬p). To be more precise, the ﬁrst two columns list all possible combina-\ntions of values for p and q. The next two columns compute the corresponding\nvalues for ¬p and ¬q. Using these four columns, we may compute the column\nfor p →¬q and q ∨¬p. To do so we think of the ﬁrst and fourth columns\nas the data for the →truth table and compute the column of p →¬q ac-\ncordingly. For example, in the ﬁrst line p is T and ¬q is F so the entry for\np →¬q is T →F = F by deﬁnition of the meaning of →. In this fashion, we\ncan ﬁll out the rest of the ﬁfth column. Column 6 works similarly, only we\nnow need to look up the truth table for ∨with columns 2 and 3 as input.\n40\n1 Propositional logic\np\nq\np\nr\nT\nT\nF\nT\nF\nF\nF\nF\n¬\nF\n∧\n∨\nq\nT\nF\n∧\n¬\n→\nFigure 1.7. The evaluation of a logical formula under a given valuation.\np\nq\n¬p\n¬q\np →¬q\nq ∨¬p\n(p →¬q) →(q ∨¬p)\nT\nT\nF\nF\nF\nT\nT\nT\nF\nF\nT\nT\nF\nF\nF\nT\nT\nF\nT\nT\nT\nF\nF\nT\nT\nT\nT\nT\nFigure 1.8. An example of a truth table for a more complex logical formula.\nFinally, column 7 results from applying the truth table of →to columns 5\nand 6.\n1.4.2 Mathematical induction\nHere is a little anecdote about the German mathematician Gauss who, as a\npupil at age 8, did not pay attention in class (can you imagine?), with the\nresult that his teacher made him sum up all natural numbers from 1 to 100.\nThe story has it that Gauss came up with the correct answer 5050 within\n(¬p ∨¬q ∨r) ∧(p ∨¬q ∨¬r) ∧(p ∨¬q ∨r) ∧(p ∨q ∨¬r).\nIf we don’t have a full truth table at our disposal, but do know the structure\nof φ, then we would like to compute a version of φ in CNF. It should be\nclear by now that a full truth table of φ and an equivalent formula in\nCNF are pretty much the same thing as far as questions about validity are\nconcerned – although the formula in CNF may be much more compact.\n1.5.2 Conjunctive normal forms and validity\nWe have already seen the beneﬁts of conjunctive normal forms in that they\nallow for a fast and easy syntactic test of validity. Therefore, one wonders\nwhether any formula can be transformed into an equivalent formula in CNF.\nWe now develop an algorithm achieving just that. Note that, by Deﬁni-\ntion 1.40, a formula is valid iﬀany of its equivalent formulas is valid. We\nreduce the problem of determining whether any φ is valid to the problem\nof computing an equivalent ψ ≡φ such that ψ is in CNF and checking, via\nLemma 1.43, whether ψ is valid.\n1.5 Normal forms\n59\nBefore we sketch such a procedure, we make some general remarks about\nits possibilities and its realisability constraints. First of all, there could be\nmore or less eﬃcient ways of computing such normal forms. But even more\nso, there could be many possible correct outputs, for ψ1 ≡φ and ψ2 ≡φ\ndo not generally imply that ψ1 is the same as ψ2, even if ψ1 and ψ2 are in\nCNF. For example, take φ\ndef\n= p, ψ1\ndef\n= p and ψ2\ndef\n= p ∧(p ∨q); then convince\nyourself that φ ≡ψ2 holds. Having this ambiguity of equivalent conjunctive\nnormal forms, the computation of a CNF for φ with minimal ‘cost’ (where\n‘cost’ could for example be the number of conjuncts, or the height of φ’s\nparse tree) becomes a very important practical problem, an issue persued in\nChapter 6. Right now, we are content with stating a deterministic algorithm\nwhich always computes the same output CNF for a given input φ.\nThis algorithm, called CNF, should satisfy the following requirements:\n(1)",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-1-subsection-2",
                            "title": "Binary Decision Diagrams",
                            "content": "the cycle s0 →s1 →s0, and is not a dag. If we interpret the links in BDDs\n(whether solid or dashed) as always going in a downwards direction, then\nthe BDDs of this chapter are also directed graphs. They are also acyclic and\nhave a unique initial node. The optimisations C1–C3 preserve the property\nof being a dag; and fully reduced BDDs have precisely two terminal nodes.\nWe now formally deﬁne BDDs as certain kinds of dags:\nDeﬁnition 6.5 A binary decision diagram (BDD) is a ﬁnite dag with\na unique initial node, where all terminal nodes are labelled with 0 or\n1 and all non-terminal nodes are labelled with a boolean variable. Each\n6.1 Representing boolean functions\n365\n0\n1\n0\nx\nFigure 6.6. The BDDs (a) B0, representing the constant 0 boolean\nfunction; similarly, the BDD B1 has only one node 1 and represents\nthe constant 1 boolean function; and (b) Bx, representing the boolean\nvariable x.\nnon-terminal node has exactly two edges from that node to others: one la-\nbelled 0 and one labelled 1 (we represent them as a dashed line and a solid\nline, respectively).\nA BDD is said to be reduced if none of the optimisations C1–C3 can be\napplied (i.e. no more reductions are possible).\nAll the decision structures we have seen in this chapter (Figures 6.2–6.5)\nare BDDs, as are the constant functions B0 and B1, and the function Bx\nfrom Figure 6.6. If B is a BDD where V = {x1, x2, . . . , xn} is the set of labels\nof non-terminal nodes, then B determines a boolean function f(V ) in the\nsame way as binary decision trees (see Deﬁnition 6.3): given an assignment\nof 0s and 1s to the variables in V , we compute the value of f by starting\nwith the unique initial node. If its variable has value 0, we follow the dashed\nline; otherwise we take the solid line. We continue for each node until we\nreach a terminal node. Since the BDD is ﬁnite by deﬁnition, we eventually\nreach a terminal node which is labelled with 0 or 1. That label is the result\nof f for that particular assignment of truth values.\nvariables x and y.\nDeﬁnition 6.3 Let T be a ﬁnite binary decision tree. Then T determines\na unique boolean function of the variables in non-terminal nodes, in the\nfollowing way. Given an assignment of 0s and 1s to the boolean variables\n362\n6 Binary decision diagrams\n1\n0\ny\nx\ny\n1\n0\ny\nx\nFigure 6.3. (a) Sharing the terminal nodes of the binary decision tree\nin Figure 6.2; (b) further optimisation by removing a redundant decision\npoint.\noccurring in T, we start at the root of T and take the dashed line when-\never the value of the variable at the current node is 0; otherwise, we travel\nalong the solid line. The function value is the value of the terminal node we\nreach.\nFor example, the binary decision tree of Figure 6.2 represents a boolean\nfunction f(x, y). To ﬁnd f(0, 1), start at the root of the tree. Since the value\nof x is 0 we follow the dashed line out of the node labelled x and arrive\nat the leftmost node labelled y. Since y’s value is 1, we follow the solid\nline out of that y-node and arrive at the leftmost terminal node labelled\n0. Thus, f(0, 1) equals 0. In computing f(0, 0), we similarly travel down\nthe tree, but now following two dashed lines to obtain 1 as a result. You\ncan see that the two other possibilities result in reaching the remaining\ntwo terminal nodes labelled 0. Thus, this binary decision tree computes the\nfunction f(x, y)\ndef\n= x + y.\nBinary decision trees are quite close to the representation of boolean func-\ntions as truth tables as far as their sizes are concerned. If the root of a binary\ndecision tree is an x-node then it has two subtrees (one for the value of x\nbeing 0 and another one for x having value 1). So if f depends on n boolean\nvariables, the corresponding binary decision tree will have at least 2n+1 −1\nnodes (see exercise 5 on page 399). Since f’s truth table has 2n lines, we\nsee that decision trees as such are not a more compact representation of\nboolean functions. However, binary decision trees often contain some redun-\nis represented by the OBDD of the boolean function\n(l11 · l12 · · · · · l1n) + (l21 · l22 · · · · · l2n) + · · · + (lm1 · lm2 · · · · · lmn)\nwhere li1 · li2 · · · · · lin represents state si.\n384\n6 Binary decision diagrams\ns2\nx1\ns0\nx2\ns1\nFigure 6.24. A simple CTL model (Example 6.12).\nset of\nrepresentation by\nrepresentation by\nstates\nboolean values\nboolean function\n∅\n0\n{s0}\n(1, 0)\nx1 · x2\n{s1}\n(0, 1)\nx1 · x2\n{s2}\n(0, 0)\nx1 · x2\n{s0, s1}\n(1, 0), (0, 1)\nx1 · x2 + x1 · x2\n{s0, s2}\n(1, 0), (0, 0)\nx1 · x2 + x1 · x2\n{s1, s2}\n(0, 1), (0, 0)\nx1 · x2 + x1 · x2\nS\n(1, 0), (0, 1), (0, 0)\nx1 · x2 + x1 · x2 + x1 · x2\nFigure 6.25. Representation of subsets of states of the model of Figure 6.24.\nThe key point which makes this representation interesting is that the\nOBDD representing a set of states may be quite small.\nExample 6.12 Consider the CTL model in Figure 6.24, given by:\nS\ndef\n= {s0, s1, s2}\n→\ndef\n= {(s0, s1), (s1, s2), (s2, s0), (s2, s2)}\nL(s0)\ndef\n= {x1}\nL(s1)\ndef\n= {x2}\nL(s2)\ndef\n= ∅.\nNote that it has the property that, for all states s1 and s2, L(s1) = L(s2)\nimplies s1 = s2, i.e. a state is determined entirely by the atomic formulas\ntrue in it. Sets of states may be represented by boolean values and by boolean\nformulas with the ordering [x1, x2], as shown in Figure 6.25.\nNotice that the vector (1, 1) and the corresponding function x1 · x2 are\nunused. Therefore, we are free to include it in the representation of a subset\n6.3 Symbolic model checking\n385\nx2\n0\n1\nx1\n0\n1\nx1\nx2\nx2\nFigure 6.26. Two OBDDs for the set {s0, s1} (Example 6.12).\nof S or not; so we may choose to include it or not in order to optimise the\nsize of the OBDD. For example, the subset {s0, s1} is better represented\nby the boolean function x1 + x2, since its OBDD is smaller than that for\nx1 · x2 + x1 · x2 (Figure 6.26).\nIn order to justify the claim that the representation of subsets of S as\nOBDDs will be suitable for the algorithm presented in Section 3.6.1, we need\nnodes (see exercise 5 on page 399). Since f’s truth table has 2n lines, we\nsee that decision trees as such are not a more compact representation of\nboolean functions. However, binary decision trees often contain some redun-\ndancy which we can exploit.\nSince 0 and 1 are the only terminal nodes of binary decision trees, we can\noptimise the representation by having pointers to just one copy of 0 and\none copy of 1. For example, the binary decision tree in Figure 6.2 can be\noptimised in this way and the resulting structure is depicted in Figure 6.3(a).\nNote that we saved storage space for two redundant terminal 0-nodes, but\nthat we still have as many edges (pointers) as before.\n6.1 Representing boolean functions\n363\nx\nx\n1\n0\nz\ny\ny\ny\ny\nFigure 6.4. A BDD with duplicated subBDDs.\nA second optimisation we can do is to remove unnecessary decision points\nin the tree. In Figure 6.3(a), the right-hand y is unnecessary, because we go\nto the same place whether it is 0 or 1. Therefore the structure could be\nfurther reduced, to the one shown on the right, (b).\nAll these structures are examples of binary decision diagrams (BDDs).\nThey are more general than binary decision trees; the sharing of the leaves\nmeans they are not trees. As a third optimisation, we also allow subBDDs to\nbe shared. A subBDD is the part of a BDD occurring below a given node. For\nexample, in the BDD of Figure 6.4, the two inner y-nodes perform the same\nrole, because the subBDDs below them have the same structure. Therefore,\none of them could be removed, resulting in the BDD in Figure 6.5(a). Indeed,\nthe left-most y-node could also be merged with the middle one; then the\nx-node above both of them would become redundant. Removing it would\nresult in the BDD on the right of Figure 6.5.\nTo summarise, we encountered three diﬀerent ways of reducing a BDD to\na more compact form:\nC1. Removal of duplicate terminals. If a BDD contains more than one\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\nBinary decision diagrams\n358\n6.1\nRepresenting boolean functions\n358\n6.1.1\nPropositional formulas and truth tables\n359\n6.1.2\nBinary decision diagrams\n361\n6.1.3\nOrdered BDDs\n366\n6.2\nAlgorithms for reduced OBDDs\n372\n6.2.1\nThe algorithm reduce\n372\n6.2.2\nThe algorithm apply\n373\n6.2.3\nThe algorithm restrict\n377\n6.2.4\nThe algorithm exists\n377\n6.2.5\nAssessment of OBDDs\n380\n6.3\nSymbolic model checking\n382\n6.3.1\nRepresenting subsets of the set of states\n383\n6.3.2\nRepresenting the transition relation\n385\n6.3.3\nImplementing the functions pre∃and pre∀\n387\n6.3.4\nSynthesising OBDDs\n387\n6.4\nA relational mu-calculus\n390\n6.4.1\nSyntax and semantics\n390\n6.4.2\nCoding CTL models and speciﬁcations\n393\n6.5\nExercises\n398\n6.6\nBibliographic notes\n413\nBibliography\n414\nIndex\n418\nForeword to the first edition\nby\nEdmund M. Clarke\nFORE Systems Professor of Computer Science\nCarnegie Mellon University\nPittsburgh, PA\nFormal methods have ﬁnally come of age! Speciﬁcation languages, theorem\nprovers, and model checkers are beginning to be used routinely in industry.\nMathematical logic is basic to all of these techniques. Until now textbooks\non logic for computer scientists have not kept pace with the development\nof tools for hardware and software speciﬁcation and veriﬁcation. For exam-\nple, in spite of the success of model checking in verifying sequential circuit\ndesigns and communication protocols, until now I did not know of a sin-\ngle text, suitable for undergraduate and beginning graduate students, that\nattempts to explain how this technique works. As a result, this material is\nrarely taught to computer scientists and electrical engineers who will need to",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-1-subsection-3",
                            "title": "Ordered BDDs",
                            "content": "ring along any path. We then adhere to that same ordering for all the BDDs\nwe manipulate.\nDeﬁnition 6.6 Let [x1, . . . , xn] be an ordered list of variables without du-\nplications and let B be a BDD all of whose variables occur somewhere in\nthe list. We say that B has the ordering [x1, . . . , xn] if all variable labels of\nB occur in that list and, for every occurrence of xi followed by xj along any\npath in B, we have i < j.\nAn ordered BDD (OBDD) is a BDD which has an ordering for some list\nof variables.\nNote that the BDDs of Figures 6.3(a,b) and 6.9 are ordered (with ordering\n[x, y]). We don’t insist that every variable in the list is used in the paths.\nThus, the OBDDs of Figures 6.3 and 6.9 have the ordering [x, y, z] and so\n368\n6 Binary decision diagrams\n0\n1\nz\nx\ny\ny\nx\nFigure 6.10. A BDD which does not have an ordering of variables.\ndoes any list having x, y and z in it in that order, such as [u, x, y, v, z, w] and\n[x, u, y, z]. Even the BDDs B0 and B1 in Figure 6.6 are OBDDs, a suitable\nordering list being the empty list (there are no variables), or indeed any list.\nThe BDD Bx of Figure 6.6(b) is also an OBDD, with any list containing x\nas its ordering.\nThe BDD of Figure 6.7 is not ordered. To see why this is so, consider the\npath taken if the values of x and y are 0. We begin with the root, an x-\nnode, and reach a y-node and then an x-node again. Thus, no matter what\nlist arrangement we choose (remembering that no double occurrences are\nallowed), this path violates the ordering condition. Another example of a\nBDD that is not ordered can be seen in Figure 6.10. In that case, we cannot\nﬁnd an order since the path for (x, y, z) ⇒(0, 0, 0) – meaning that x, y and z\nare assigned 0 – shows that y needs to occur before x in such a list, whereas\nthe path for (x, y, z) ⇒(1, 1, 1) demands that x be before y.\nIt follows from the deﬁnition of OBDDs that one cannot have multiple\noccurrences of any variable along a path.\nthe cycle s0 →s1 →s0, and is not a dag. If we interpret the links in BDDs\n(whether solid or dashed) as always going in a downwards direction, then\nthe BDDs of this chapter are also directed graphs. They are also acyclic and\nhave a unique initial node. The optimisations C1–C3 preserve the property\nof being a dag; and fully reduced BDDs have precisely two terminal nodes.\nWe now formally deﬁne BDDs as certain kinds of dags:\nDeﬁnition 6.5 A binary decision diagram (BDD) is a ﬁnite dag with\na unique initial node, where all terminal nodes are labelled with 0 or\n1 and all non-terminal nodes are labelled with a boolean variable. Each\n6.1 Representing boolean functions\n365\n0\n1\n0\nx\nFigure 6.6. The BDDs (a) B0, representing the constant 0 boolean\nfunction; similarly, the BDD B1 has only one node 1 and represents\nthe constant 1 boolean function; and (b) Bx, representing the boolean\nvariable x.\nnon-terminal node has exactly two edges from that node to others: one la-\nbelled 0 and one labelled 1 (we represent them as a dashed line and a solid\nline, respectively).\nA BDD is said to be reduced if none of the optimisations C1–C3 can be\napplied (i.e. no more reductions are possible).\nAll the decision structures we have seen in this chapter (Figures 6.2–6.5)\nare BDDs, as are the constant functions B0 and B1, and the function Bx\nfrom Figure 6.6. If B is a BDD where V = {x1, x2, . . . , xn} is the set of labels\nof non-terminal nodes, then B determines a boolean function f(V ) in the\nsame way as binary decision trees (see Deﬁnition 6.3): given an assignment\nof 0s and 1s to the variables in V , we compute the value of f by starting\nwith the unique initial node. If its variable has value 0, we follow the dashed\nline; otherwise we take the solid line. We continue for each node until we\nreach a terminal node. Since the BDD is ﬁnite by deﬁnition, we eventually\nreach a terminal node which is labelled with 0 or 1. That label is the result\nof f for that particular assignment of truth values.\nall its 1-terminals by Bg. To see why this is so, consider how to get to a\n1-terminal in the resulting BDD. You have to satisfy the requirements for\ngetting to a 1 imposed by both of the BDDs. Similarly, a BDD for f + g\ncan be obtained by replacing all 0 terminals of Bf by Bg. Note that these\noperations are likely to generate BDDs with multiple occurrences of variables\nalong a path. Later, in Section 6.2, we will see deﬁnitions of + and · on BDDs\nthat don’t have this undesirable eﬀect.\nThe complementation operation ¯ is also possible: a BDD representing f\ncan be obtained by replacing all 0-terminals in Bf by 1-terminals and vice\nversa. Figure 6.8 shows the complement of the BDD in Figure 6.2.\n6.1.3 Ordered BDDs\nWe have seen that the representation of boolean functions by BDDs is often\ncompact, thanks to the sharing of information aﬀorded by the reductions\nC1–C3. However, BDDs with multiple occurrences of a boolean variable\nalong a path seem rather ineﬃcient. Moreover, there seems no easy way to\ntest for equivalence of BDDs. For example, the BDDs of Figures 6.7 and 6.9\nrepresent the same boolean function (the reader should check this). Neither\nof them can be optimised further by applying the rules C1–C3. However,\n6.1 Representing boolean functions\n367\nx\ny\ny\n0\n1\n1\n1\nFigure 6.8. The complement of the BDD in Figure 6.2.\ny\n0\n1\nx\ny\nz\nFigure 6.9. A BDD representing the same function as the BDD of\nFigure 6.7, but having the variable ordering [x, y, z].\ntesting whether they denote the same boolean function seems to involve as\nmuch computational eﬀort as computing the entire truth table for f(x, y, z).\nWe can improve matters by imposing an ordering on the variables occur-\nring along any path. We then adhere to that same ordering for all the BDDs\nwe manipulate.\nDeﬁnition 6.6 Let [x1, . . . , xn] be an ordered list of variables without du-\nplications and let B be a BDD all of whose variables occur somewhere in\nare assigned 0 – shows that y needs to occur before x in such a list, whereas\nthe path for (x, y, z) ⇒(1, 1, 1) demands that x be before y.\nIt follows from the deﬁnition of OBDDs that one cannot have multiple\noccurrences of any variable along a path.\nWhen operations are performed on two OBDDs, we usually require that\nthey have compatible variable orderings. The orderings of B1 and B2 are\nsaid to be compatible if there are no variables x and y such that x comes\nbefore y in the ordering of B1 and y comes before x in the ordering of B2.\nThis commitment to an ordering gives us a unique representation of boolean\nfunctions as OBDDs. For example, the BDDs in Figures 6.8 and 6.9 have\ncompatible variable orderings.\nTheorem 6.7 The reduced OBDD representing a given function f is\nunique. That is to say, let B and B′ be two reduced OBDDs with\n6.1 Representing boolean functions\n369\ncompatible variable orderings. If B and B represent the same boolean func-\ntion, then they have identical structure.\nIn other words, with OBDDs we cannot get a situation like the one en-\ncountered earlier, in which we have two distinct reduced BDDs which repre-\nsent the same function, provided that the orderings are compatible. It follows\nthat checking equivalence of OBDDs is immediate. Checking whether two\nOBDDs (having compatible orderings) represent the same function is simply\na matter of checking whether they have the same structure1.\nA useful consequence of the theorem above is that, if we apply the reduc-\ntions C1–C3 to an OBDD until no further reductions are possible, then we\nare guaranteed that the result is always the same reduced OBDD. The order\nin which we applied the reductions does not matter. We therefore say that\nOBDDs have a canonical form, namely their unique reduced OBDD. Most\nother representations (conjunctive normal forms, etc.) do not have canonical\nforms.\nThe algorithms for · and + for BDDs, presented in Section 6.1.2, won’t\nline; otherwise we take the solid line. We continue for each node until we\nreach a terminal node. Since the BDD is ﬁnite by deﬁnition, we eventually\nreach a terminal node which is labelled with 0 or 1. That label is the result\nof f for that particular assignment of truth values.\nThe deﬁnition of a BDD does not prohibit that a boolean variable occur\nmore than once on a path in the dag. For example, consider the BDD in\nFigure 6.7.\nSuch a representation is wasteful, however. The solid link from the left-\nmost x to the 1-terminal is never taken, for example, because one can only\nget to that x-node when x has value 0.\nThanks to the reductions C1–C3, BDDs can often be quite compact rep-\nresentations of boolean functions. Let us consider how to check satisﬁability\nand perform the boolean operations on functions represented as BDDs. A\nBDD represents a satisﬁable function if a 1-terminal node is reachable from\nthe root along a consistent path in a BDD which represents it. A consistent\npath is one which, for every variable, has only dashed lines or only solid lines\nleaving nodes labelled by that variable. (In other words, we cannot assign\n366\n6 Binary decision diagrams\nx\ny\nz\nx\ny\nx\n0\n1\nFigure 6.7. A BDD where some boolean variables occur more than\nonce on an evaluation path.\na variable the values 0 and 1 simultaneously.) Checking validity is similar,\nbut we check that no 0-terminal is reachable by a consistent path.\nThe operations · and + can be performed by ‘surgery’ on the component\nBDDs. Given BDDs Bf and Bg representing boolean functions f and g, a\nBDD representing f · g can be obtained by taking the BDD f and replacing\nall its 1-terminals by Bg. To see why this is so, consider how to get to a\n1-terminal in the resulting BDD. You have to satisfy the requirements for\ngetting to a 1 imposed by both of the BDDs. Similarly, a BDD for f + g\ncan be obtained by replacing all 0 terminals of Bf by Bg. Note that these",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-2",
                    "title": "Algorithms for Reduced OBDDs",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-2-subsection-1",
                            "title": "The Algorithm Reduce",
                            "content": "with reduction C3).\nr Otherwise, we set id(n) to the next unused integer label.\nNote that only the last case creates a new label. Consider the OBDD\nin left side of Figure 6.14; each node has an integer label obtained in the\nmanner just described. The algorithm reduce then ﬁnishes by redirecting\nedges bottom-up as outlined in C1–C3. The resulting reduced OBDD is in\nright of Figure 6.14. Since there are eﬃcient bottom-up traversal algorithms\nfor dags, reduce is an eﬃcient operation in the number of nodes of an\nOBDD.\n6.2.2 The algorithm apply\nAnother procedure at the heart of OBDDs is the algorithm apply. It is\nused to implement operations on boolean functions such as +, · , ⊕and\ncomplementation (via f ⊕1). Given OBDDs Bf and Bg for boolean formulas\nf and g, the call apply (op, Bf, Bg) computes the reduced OBDD of the\nboolean formula f op g, where op denotes any function from {0, 1} × {0, 1}\nto {0, 1}.\n374\n6 Binary decision diagrams\nThe intuition behind the apply algorithm is fairly simple. The algorithm\noperates recursively on the structure of the two OBDDs:\n1.\nlet v be the variable highest in the ordering (=leftmost in the list) which occurs\nin Bf or Bg.\n2.\nsplit the problem into two subproblems for v being 0 and v being 1 and solve\nrecursively;\n3.\nat the leaves, apply the boolean operation op directly.\nThe result will usually have to be reduced to make it into an OBDD. Some\nreduction can be done ‘on the ﬂy’ in step 2, by avoiding the creation of a new\nnode if both branches are equal (in which case return the common result),\nor if an equivalent node already exists (in which case, use it).\nLet us make all this more precise and detailed.\nDeﬁnition 6.9 Let f be a boolean formula and x a variable.\n1.\nWe denote by f[0/x] the boolean formula obtained by replacing all occurrences\nof x in f by 0. The formula f[1/x] is deﬁned similarly. The expressions f[0/x]\nand f[1/x] are called restrictions of f.\n2.\nlabel id(n) to each node n of B, in such a way that the subOBDDs with\nroot nodes n and m denote the same boolean function if, and only if, id(n)\nequals id(m).\nSince reduce starts with the layer of terminal nodes, it assigns the ﬁrst\nlabel (say #0) to the ﬁrst 0-node it encounters. All other terminal 0-nodes\ndenote the same function as the ﬁrst 0-node and therefore get the same label\n(compare with reduction C1). Similarly, the 1-nodes all get the next label,\nsay #1.\nNow let us inductively assume that reduce has already assigned integer\nlabels to all nodes of a layer > i (i.e. all terminal nodes and xj-nodes with\nj > i). We describe how nodes of layer i (i.e. xi-nodes) are being handled.\nDeﬁnition 6.8 Given a non-terminal node n in a BDD, we deﬁne lo(n) to\nbe the node pointed to via the dashed line from n. Dually, hi(n) is the node\npointed to via the solid line from n.\nLet us describe how the labelling is done. Given an xi-node n, there are\nthree ways in which it may get its label:\n6.2 Algorithms for reduced OBDDs\n373\n0\n1\n#0\n#1\n0\n1\n0\n1\nx3\nx3\nx2\nx2\nx1\n#0\n#1\n#0\n#1\n#2\n#2\n#3\n#2\n#4\n=⇒\nx3\nx2\nx1\n#2\n#3\n#4\nReduce\nFigure 6.14. An example execution of the algorithm reduce.\nr If the label id(lo(n)) is the same as id(hi(n)), then we set id(n) to be that label.\nThat is because the boolean function represented at n is the same function as the\none represented at lo(n) and hi(n). In other words, node n performs a redundant\ntest and can be eliminated by reduction C2.\nr If there is another node m such that n and m have the same variable xi, and\nid(lo(n)) = id(lo(m)) and id(hi(n)) = id(hi(m)), then we set id(n) to be id(m).\nThis is because the nodes n and m compute the same boolean function (compare\nwith reduction C3).\nr Otherwise, we set id(n) to the next unused integer label.\nNote that only the last case creates a new label. Consider the OBDD\nin left side of Figure 6.14; each node has an integer label obtained in the\n\u0001\nassume\n\u0002\nmethod\n\u0001\nguarantee\n\u0002\nvery\nmuch in the style developed in this chapter, except that for all method\ninvocations within that body we can assume that their Hoare triples are\ncorrect.\nExample 4.21 We have already used program validation by contract in our\nveriﬁcation of the program that computes the minimal sum for all sections\nof an array in Figure 4.3 on page 291. Let us focus on the proof fragment\n(Inv1(min(s, min(t + a[k], a[k])), k + 1) ∧Inv2(min(t + a[k], a[k]), k + 1))\nImplied (Lemma 4.20)\nt = min(t + a[k], a[k]);\n(Inv1(min(s, t), k + 1) ∧Inv2(t, k + 1))\nAssignment\ns = min(s,t);\n(Inv1(s, k + 1) ∧Inv2(t, k + 1))\nAssignment\nIts last line serves as the postcondition which gets pushed through the as-\nsignment s = min(s,t). But min(s,t) is a method call whose guarantees\nare speciﬁed as ‘result equals min(s, t),’ where min(s, t) is a mathematical\nnotation for the smaller of the numbers s and t. Thus, the rule Assignment\ndoes not substitute the syntax of the method invocation min(s,t) for all\noccurrences of s in Inv1(s, k + 1) ∧Inv2(t, k + 1), but changes all such s to\nthe guarantee min(s, t) of the method call min(s,t) – program validation\n4.6 Exercises\n299\nby contract in action! A similar comment applies for the assignment t =\nmin(t + a[k], a[k]).\nProgram validation by contract has to be used wisely to avoid circular\nreasoning. If each method is a node in a graph, let’s draw an edge from\nmethod n to method m iﬀwithin the body of n there is a call to method m.\nFor program validation by contract to be sound, we require that there be\nno cycles in this method-dependency graph.\n4.6 Exercises\nExercises 4.1\n1.\n*\nIf you already have written computer programs yourself, assemble for each pro-\ngramming language you used a list of features of its software development envi-\nronment (compiler, editor, linker, run-time environment etc) that may improve\nthe likelihood that your programs work correctly. Try to rate the eﬀectiveness of\neach such feature.\ncomplexity, 380\ncontrol structure, 374\nrecursive descent, 375\nalgorithm CNF, 59\nalgorithm reduce, 372\ncomplexity, 380\nalgorithm restrict, 377\ncomplexity, 380\nalgorithm reduce\nexample execution, 373\nAlloy\n[], 153\nfun-statement, 155\nwith, 146\nassertion, 144\ncheck directive, 144\nconsistency check, 144\nconstrain signature, 150\ncounterexample, 144\ndot operator, 144\nextending signature, 169\nimplication, 147\nlet-expression, 153\nlimitations, 156\nmodiﬁers, 150\nmodule, 146\nopening module, 156\npolymorphism, 156\npostcondition, 151\nprecondition, 151\nreﬂexive, transitive closure, 169\nrun directive, 146\nsignature, 143\ninstance, 144\nsmall scope hypothesis, 143, 168\ntransitive closure, 155\nuniversal quantiﬁcation, 146\nalternating bit protocol, 203\nalways in the future, 318\nand-elimination, 6, 339\nand-introduction, 6, 339\napplication domain, 173, 257\napproach\nmodel-based, 173\nproof-based, 173\napproximants\nµmZ.f, 392\nνmZ.f, 393\narity, 99\narray, 299\nbounds, 136, 287\nﬁeld, 287\nof integers, 287\nsection, 287\nartiﬁcial intelligence, 306\nartiﬁcial language, 93\nassertion checking, 143\nassignment, 191\ninitial, 292\nnon-deterministic, 205, 230\nprogram notation, 261\nstatement, 261\nassociativity laws, 56, 88\nassumption, 4\ndischarging, 28, 329\ntemporary, 11, 121\n418\nIndex\n419\nasynchronous\ncircuit, 358\ninterleaving, 189\natomic formula, 335\nof modal logic, 307\nof predicate logic\nmeaning, 124\naxiom\n5, 331\nT, 341\n4, 327, 330, 339\n5, 330, 339\nT, 327, 330, 339, 343\nfor assignment, 270\nfor equality, 107\ninstance, 271\nBackus Naur form (BNF), 33\nbackwards breadth-ﬁrst search, 225,\n232\nbase case, 41, 42, 86\nbasic modal logic, 307\nBDD, 364\nhi(n), 372\nlo(n), 372\nas boolean function, 365\ncomplement, 367\nconsistent path, 365\nedge, 361\nexamples, 365\nhas an ordering, 367\nlayer of variables, 361\nline\ndashed, 362, 365\nsolid, 362, 365\nordered, 367\nread-1, 405\nreduced, 365\nremoval of duplicate non-terminals, 363\nremoval of duplicate terminals, 363\nremoval of redundant tests, 363\nsatisﬁable, 365\nsubBDD, 363\n(R1, S1)\nx1\nx2\nx3\n(R3, S3)\n(R2, S3)\n(R3, S2)\nx4\nx3\n(R5, S4)\n(R6, S5)\n(R4, S3)\n(R6, S3)\n(R4, S3)\n(R4, S3)\nx4\n(R5, S4)\n(R6, S5)\n(R6, S5)\nx4\n(R6, S5)\nx4\n(R5, S4)\n(R6, S4)\n(R6, S5)\nFigure 6.16. The recursive call structure of apply for the example in\nFigure 6.15 (without memoisation).\n0\n1\nx4\nx3\nx2\nx1\nFigure 6.17. The result of apply (+, Bf, Bg), where Bf and Bg are given\nin Figure 6.15.\n6.2 Algorithms for reduced OBDDs\n377\nthe ﬁrst time and the result remembered for future calls. This program-\nming technique is known as memoisation. As well as being more eﬃcient,\nit has the advantage that the resulting OBDD requires less reduction. (In\nthis example, using memoisation eliminates the need for the ﬁnal call to\nreduce altogether.) Without memoisation, apply is exponential in the size\nof its arguments, since each non-leaf call generates a further two calls. With\nmemoisation, the number of calls to apply is bounded by 2 · |Bf| · |Bg|, where\n|B| is the size of the BDD. This is a worst-time complexity; the actual per-\nformance is often much better than this.\n6.2.3 The algorithm restrict\nGiven an OBDD Bf representing a boolean formula f, we need an algo-\nrithm restrict such that the call restrict(0, x, Bf) computes the reduced\nOBDD representing f[0/x] using the same variable ordering as Bf. The al-\ngorithm for restrict(0, x, Bf) works as follows. For each node n labelled\nwith x, incoming edges are redirected to lo(n) and n is removed. Then we\ncall reduce on the resulting OBDD. The call restrict (1, x, Bf) proceeds\nsimilarly, only we now redirect incoming edges to hi(n).\n6.2.4 The algorithm exists\nA boolean function can be thought of as putting a constraint on the values\nof its argument variables. For example, the function x + (y · z) evaluates to 1\nonly if x is 1; or y is 0 and z is 1 – this is a constraint on x, y, and z.\nIt is useful to be able to express the relaxation of the constraint on a subset\nof the variables concerned. To allow this, we write ∃x. f for the boolean",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-2",
                            "title": "The Algorithm Apply",
                            "content": "with reduction C3).\nr Otherwise, we set id(n) to the next unused integer label.\nNote that only the last case creates a new label. Consider the OBDD\nin left side of Figure 6.14; each node has an integer label obtained in the\nmanner just described. The algorithm reduce then ﬁnishes by redirecting\nedges bottom-up as outlined in C1–C3. The resulting reduced OBDD is in\nright of Figure 6.14. Since there are eﬃcient bottom-up traversal algorithms\nfor dags, reduce is an eﬃcient operation in the number of nodes of an\nOBDD.\n6.2.2 The algorithm apply\nAnother procedure at the heart of OBDDs is the algorithm apply. It is\nused to implement operations on boolean functions such as +, · , ⊕and\ncomplementation (via f ⊕1). Given OBDDs Bf and Bg for boolean formulas\nf and g, the call apply (op, Bf, Bg) computes the reduced OBDD of the\nboolean formula f op g, where op denotes any function from {0, 1} × {0, 1}\nto {0, 1}.\n374\n6 Binary decision diagrams\nThe intuition behind the apply algorithm is fairly simple. The algorithm\noperates recursively on the structure of the two OBDDs:\n1.\nlet v be the variable highest in the ordering (=leftmost in the list) which occurs\nin Bf or Bg.\n2.\nsplit the problem into two subproblems for v being 0 and v being 1 and solve\nrecursively;\n3.\nat the leaves, apply the boolean operation op directly.\nThe result will usually have to be reduced to make it into an OBDD. Some\nreduction can be done ‘on the ﬂy’ in step 2, by avoiding the creation of a new\nnode if both branches are equal (in which case return the common result),\nor if an equivalent node already exists (in which case, use it).\nLet us make all this more precise and detailed.\nDeﬁnition 6.9 Let f be a boolean formula and x a variable.\n1.\nWe denote by f[0/x] the boolean formula obtained by replacing all occurrences\nof x in f by 0. The formula f[1/x] is deﬁned similarly. The expressions f[0/x]\nand f[1/x] are called restrictions of f.\n2.\n(R1, S1)\nx1\nx2\nx3\n(R3, S3)\n(R2, S3)\n(R3, S2)\nx4\nx3\n(R5, S4)\n(R6, S5)\n(R4, S3)\n(R6, S3)\n(R4, S3)\n(R4, S3)\nx4\n(R5, S4)\n(R6, S5)\n(R6, S5)\nx4\n(R6, S5)\nx4\n(R5, S4)\n(R6, S4)\n(R6, S5)\nFigure 6.16. The recursive call structure of apply for the example in\nFigure 6.15 (without memoisation).\n0\n1\nx4\nx3\nx2\nx1\nFigure 6.17. The result of apply (+, Bf, Bg), where Bf and Bg are given\nin Figure 6.15.\n6.2 Algorithms for reduced OBDDs\n377\nthe ﬁrst time and the result remembered for future calls. This program-\nming technique is known as memoisation. As well as being more eﬃcient,\nit has the advantage that the resulting OBDD requires less reduction. (In\nthis example, using memoisation eliminates the need for the ﬁnal call to\nreduce altogether.) Without memoisation, apply is exponential in the size\nof its arguments, since each non-leaf call generates a further two calls. With\nmemoisation, the number of calls to apply is bounded by 2 · |Bf| · |Bg|, where\n|B| is the size of the BDD. This is a worst-time complexity; the actual per-\nformance is often much better than this.\n6.2.3 The algorithm restrict\nGiven an OBDD Bf representing a boolean formula f, we need an algo-\nrithm restrict such that the call restrict(0, x, Bf) computes the reduced\nOBDD representing f[0/x] using the same variable ordering as Bf. The al-\ngorithm for restrict(0, x, Bf) works as follows. For each node n labelled\nwith x, incoming edges are redirected to lo(n) and n is removed. Then we\ncall reduce on the resulting OBDD. The call restrict (1, x, Bf) proceeds\nsimilarly, only we now redirect incoming edges to hi(n).\n6.2.4 The algorithm exists\nA boolean function can be thought of as putting a constraint on the values\nof its argument variables. For example, the function x + (y · z) evaluates to 1\nonly if x is 1; or y is 0 and z is 1 – this is a constraint on x, y, and z.\nIt is useful to be able to express the relaxation of the constraint on a subset\nof the variables concerned. To allow this, we write ∃x. f for the boolean\nvariables x and y.\nDeﬁnition 6.3 Let T be a ﬁnite binary decision tree. Then T determines\na unique boolean function of the variables in non-terminal nodes, in the\nfollowing way. Given an assignment of 0s and 1s to the boolean variables\n362\n6 Binary decision diagrams\n1\n0\ny\nx\ny\n1\n0\ny\nx\nFigure 6.3. (a) Sharing the terminal nodes of the binary decision tree\nin Figure 6.2; (b) further optimisation by removing a redundant decision\npoint.\noccurring in T, we start at the root of T and take the dashed line when-\never the value of the variable at the current node is 0; otherwise, we travel\nalong the solid line. The function value is the value of the terminal node we\nreach.\nFor example, the binary decision tree of Figure 6.2 represents a boolean\nfunction f(x, y). To ﬁnd f(0, 1), start at the root of the tree. Since the value\nof x is 0 we follow the dashed line out of the node labelled x and arrive\nat the leftmost node labelled y. Since y’s value is 1, we follow the solid\nline out of that y-node and arrive at the leftmost terminal node labelled\n0. Thus, f(0, 1) equals 0. In computing f(0, 0), we similarly travel down\nthe tree, but now following two dashed lines to obtain 1 as a result. You\ncan see that the two other possibilities result in reaching the remaining\ntwo terminal nodes labelled 0. Thus, this binary decision tree computes the\nfunction f(x, y)\ndef\n= x + y.\nBinary decision trees are quite close to the representation of boolean func-\ntions as truth tables as far as their sizes are concerned. If the root of a binary\ndecision tree is an x-node then it has two subtrees (one for the value of x\nbeing 0 and another one for x having value 1). So if f depends on n boolean\nvariables, the corresponding binary decision tree will have at least 2n+1 −1\nnodes (see exercise 5 on page 399). Since f’s truth table has 2n lines, we\nsee that decision trees as such are not a more compact representation of\nboolean functions. However, binary decision trees often contain some redun-\n7. Explain why the four cases of the control structure for apply are exhaustive,\ni.e. there are no other possible cases in its execution.\n8. Consider the reduced OBDDs Bf and Bg in Figure 6.30. Recall that, in order\nto compute the reduced OBDD for f op g, you need to\n– construct the tree showing the recursive descent of apply (op, Bf, Bg) as\ndone in Figure 6.16;\n– use that tree to simulate apply (op, Bf, Bg); and\n– reduce, if necessary, the resulting OBDD.\nPerform these steps on the OBDDs of Figure 6.30 for the operation ‘op’ being\n(a) +\n(b) ⊕\n(c) ·\n9. Let Bf be the OBDD in Figure 6.11 (page 370). Compute apply (⊕, Bf, B1) and\nreduce the resulting OBDD. If you did everything correctly, then this OBDD\nshould be isomorphic to the one obtained from swapping 0- and 1-nodes in\nFigure 6.11.\n10.\n*\nConsider the OBDD Bc in Figure 6.31 which represents the ‘don’t care’ condi-\ntions for comparing the boolean functions f and g represented in Figure 6.30.\nThis means that we want to compare whether f and g are equal for all values\nof variables except those for which c is true (i.e. we ‘don’t care’ when c is true).\n(a) Show that the boolean formula (f ⊕g) + c is valid (always computes 1)\nif, and only if, f and g are equivalent on all values for which c evaluates\nto 0.\n404\n6 Binary decision diagrams\n0\n1\nz\ny\ny\nx\nFigure 6.31. The reduced OBDD Bc representing the ‘don’t care’ con-\nditions for the equivalence test of the OBDDs in Figure 6.30.\n(b) Proceed in three steps as in exercise 8 on page 403 to compute the reduced\nOBDD for (f ⊕g) + c from the OBDDs for f, g and c. Which call to apply\nneeds to be ﬁrst?\n11. We say that v ∈{0, 1} is a (left)-controlling value for the operation op, if either\nv op x = 1 or v op x = 0 for all values of x. We say that v is a controlling value\nif it is a left- and right-controlling value.\n(a) Deﬁne the notion of a right-controlling value.\n(b) Give examples of operations with controlling values.\nstatement until, and if, the value of c equals 1. The if-statement tests\nwhether c is even – divisible by 2 – if so, c stores its current value divided\nby 2; if not, c stores ‘three times its current value plus 1.’ The expression\nc / 2 denotes integer division, so 11 / 2 renders 5 as does 10 / 2.\nTo get a feel for this algorithm, consider an execution trace in which the\nvalue of x is 5: the value of c evolves as 5 16 8 4 2 1. For another example,\nif the value of x is initially 172, the evolution of c is\n172 86 43 130 65 196 98 49 148 74 37 112 56 28 14 7 22\n11 34 17 52 26 13 40 20 10 5 16 8 4 2 1\nThis execution requires 32 iterations of the while-statement to reach a ter-\nminating state in which the value of c equals 1. Notice how this trace reaches\n5, from where on the continuation is as if 5 were the initial value of x.\nFor the initial value 123456789 of x we abstract the evolution of c with +\n(its value increases in the else-branch) and −(its value decreases in the\nif-branch):\n+ - - - - - - + - - - + - + - - + - + - + - + - + - + - - + - - -\n- + - - - - + - - + - - + - - + - + - - - + - + - - - - - + - - +\n- + - - + - - - - + - - - - - - + - - + - + - - + - + - + - - + -\n+ - + - + - - + - - - + - + - + - - + - + - - + - + - + - + - + -\n+ - - - + - + - + - + - - - - + - - + - - + - - - - + - - - + - +\n- + - - - - - + - - - -\n296\n4 Program verification\nThis requires 177 iterations of the while-statement to reach a terminating\nstate. Although it is re-assuring that some program runs terminate, the\nirregular pattern of + and −above make it seem very hard, if not impossible,\nto come up with a variant that proves the termination of Collatz on all\nexecutions in which the initial value of x is positive.\nFinally, let’s consider a really big integer:\n32498723462509735034567279652376420563047563456356347563\\\\\n96598734085384756074086560785607840745067340563457640875\\\\\n62984573756306537856405634056245634578692825623542135761\\\\\n9519765129854122965424895465956457",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-3",
                            "title": "The Algorithm Restrict",
                            "content": "only if x is 1; or y is 0 and z is 1 – this is a constraint on x, y, and z.\nIt is useful to be able to express the relaxation of the constraint on a subset\nof the variables concerned. To allow this, we write ∃x. f for the boolean\nfunction f with the constraint on x relaxed. Formally, ∃x. f is deﬁned as\nf[0/x] + f[1/x]; that is, ∃x. f is true if f could be made true by putting x\nto 0 or to 1. Given that ∃x. f\ndef\n= f[0/x] + f[1/x] the exists algorithm can\nbe implemented in terms of the algorithms apply and restrict as\napply (+, restrict (0, x, Bf), restrict (1, x, Bf)) .\n(6.3)\nConsider, for example, the OBDD Bf for the function f\ndef\n= x1 · y1 + x2 ·\ny2 + x3 · y3, shown in Figure 6.19. Figure 6.20 shows restrict(0, x3, Bf)\nand restrict(1, x3, Bf) and the result of applying + to them. (In this case\nthe apply function happens to return its second argument.)\nWe can improve the eﬃciency of this algorithm. Consider what happens\nduring the apply stage of (6.3). In that case, the apply algorithm works on\ntwo BDDs which are identical all the way down to the level of the x-nodes;\n378\n6 Binary decision diagrams\n1\n0\nx\nx\nx\nz\ny\nFigure 6.18. An example of a BDD which is not a read-1-BDD.\n1\n0\nx1\nx2\nx3\ny1\ny2\ny3\nFigure 6.19. A BDD Bf to illustrate the exists algorithm.\ntherefore the returned BDD also has that structure down to the x-nodes.\nAt the x-nodes, the two argument BDDs diﬀer, so the apply algorithm\nwill compute the apply of + to these two subBDDs and return that as the\nsubBDD of the result. This is illustrated in Figure 6.20. Therefore, we can\ncompute the OBDD for ∃x. f by taking the OBDD for f and replacing each\nnode labelled with x by the result of calling apply on + and its two branches.\nThis can easily be generalised to a sequence of exists operations. We\nwrite ∃ˆx. f to mean ∃x1.∃x2. . . . ∃xn. f, where ˆx denotes (x1, x2, . . . , xn).\n6.2 Algorithms for reduced OBDDs\n379\n1\n0\nx1\nx2\ny1\ny2\ny3\n1\n0\n1\n0\nx1\nx2\ny1\ny2\nx1\nx2\ny1\ny2\ny3\n\u0001\nassume\n\u0002\nmethod\n\u0001\nguarantee\n\u0002\nvery\nmuch in the style developed in this chapter, except that for all method\ninvocations within that body we can assume that their Hoare triples are\ncorrect.\nExample 4.21 We have already used program validation by contract in our\nveriﬁcation of the program that computes the minimal sum for all sections\nof an array in Figure 4.3 on page 291. Let us focus on the proof fragment\n(Inv1(min(s, min(t + a[k], a[k])), k + 1) ∧Inv2(min(t + a[k], a[k]), k + 1))\nImplied (Lemma 4.20)\nt = min(t + a[k], a[k]);\n(Inv1(min(s, t), k + 1) ∧Inv2(t, k + 1))\nAssignment\ns = min(s,t);\n(Inv1(s, k + 1) ∧Inv2(t, k + 1))\nAssignment\nIts last line serves as the postcondition which gets pushed through the as-\nsignment s = min(s,t). But min(s,t) is a method call whose guarantees\nare speciﬁed as ‘result equals min(s, t),’ where min(s, t) is a mathematical\nnotation for the smaller of the numbers s and t. Thus, the rule Assignment\ndoes not substitute the syntax of the method invocation min(s,t) for all\noccurrences of s in Inv1(s, k + 1) ∧Inv2(t, k + 1), but changes all such s to\nthe guarantee min(s, t) of the method call min(s,t) – program validation\n4.6 Exercises\n299\nby contract in action! A similar comment applies for the assignment t =\nmin(t + a[k], a[k]).\nProgram validation by contract has to be used wisely to avoid circular\nreasoning. If each method is a node in a graph, let’s draw an edge from\nmethod n to method m iﬀwithin the body of n there is a call to method m.\nFor program validation by contract to be sound, we require that there be\nno cycles in this method-dependency graph.\n4.6 Exercises\nExercises 4.1\n1.\n*\nIf you already have written computer programs yourself, assemble for each pro-\ngramming language you used a list of features of its software development envi-\nronment (compiler, editor, linker, run-time environment etc) that may improve\nthe likelihood that your programs work correctly. Try to rate the eﬀectiveness of\neach such feature.\ncomplexity, 380\ncontrol structure, 374\nrecursive descent, 375\nalgorithm CNF, 59\nalgorithm reduce, 372\ncomplexity, 380\nalgorithm restrict, 377\ncomplexity, 380\nalgorithm reduce\nexample execution, 373\nAlloy\n[], 153\nfun-statement, 155\nwith, 146\nassertion, 144\ncheck directive, 144\nconsistency check, 144\nconstrain signature, 150\ncounterexample, 144\ndot operator, 144\nextending signature, 169\nimplication, 147\nlet-expression, 153\nlimitations, 156\nmodiﬁers, 150\nmodule, 146\nopening module, 156\npolymorphism, 156\npostcondition, 151\nprecondition, 151\nreﬂexive, transitive closure, 169\nrun directive, 146\nsignature, 143\ninstance, 144\nsmall scope hypothesis, 143, 168\ntransitive closure, 155\nuniversal quantiﬁcation, 146\nalternating bit protocol, 203\nalways in the future, 318\nand-elimination, 6, 339\nand-introduction, 6, 339\napplication domain, 173, 257\napproach\nmodel-based, 173\nproof-based, 173\napproximants\nµmZ.f, 392\nνmZ.f, 393\narity, 99\narray, 299\nbounds, 136, 287\nﬁeld, 287\nof integers, 287\nsection, 287\nartiﬁcial intelligence, 306\nartiﬁcial language, 93\nassertion checking, 143\nassignment, 191\ninitial, 292\nnon-deterministic, 205, 230\nprogram notation, 261\nstatement, 261\nassociativity laws, 56, 88\nassumption, 4\ndischarging, 28, 329\ntemporary, 11, 121\n418\nIndex\n419\nasynchronous\ncircuit, 358\ninterleaving, 189\natomic formula, 335\nof modal logic, 307\nof predicate logic\nmeaning, 124\naxiom\n5, 331\nT, 341\n4, 327, 330, 339\n5, 330, 339\nT, 327, 330, 339, 343\nfor assignment, 270\nfor equality, 107\ninstance, 271\nBackus Naur form (BNF), 33\nbackwards breadth-ﬁrst search, 225,\n232\nbase case, 41, 42, 86\nbasic modal logic, 307\nBDD, 364\nhi(n), 372\nlo(n), 372\nas boolean function, 365\ncomplement, 367\nconsistent path, 365\nedge, 361\nexamples, 365\nhas an ordering, 367\nlayer of variables, 361\nline\ndashed, 362, 365\nsolid, 362, 365\nordered, 367\nread-1, 405\nreduced, 365\nremoval of duplicate non-terminals, 363\nremoval of duplicate terminals, 363\nremoval of redundant tests, 363\nsatisﬁable, 365\nsubBDD, 363\n∧\n5: F\n4: T\na:T\nb:F\nc:T\nf:T\ng:F\ni:F\nh:T\nb:F\nc:T\nb:F\nc:T\nc:T\nconstraints\ntemporary T mark\nat test node;\nexplore consequences\ne:F\ng:F\nd:F\nat conjunction\ncontradictory\nFigure 1.18. Marking an unmarked node with T and exploring what\nnew constraints would follow from this. The analysis shows that this\ntest marking causes contradictory constraints. We use lowercase letters\n‘a:’ etc to denote temporary marks.\nIf both runs ﬁnd contradictory constraints, the algorithm stops and re-\nports that T(φ) is unsatisﬁable. Otherwise, all nodes that received the same\nmark in both of these runs receive that very mark as a permanent one; that\nis, we update the mark state of Figure 1.17 with all such shared marks.\nWe test any further unmarked nodes in the same manner until we either\nﬁnd contradictory permanent marks, a complete witness to satisﬁability (all\nnodes have consistent marks), or we have tested all currently unmarked\nnodes in this manner without detecting any shared marks. Only in the lat-\nter case does the analysis terminate without knowing whether the formulas\nrepresented by that DAG are satisﬁable.\n76\n1 Propositional logic\nExample 1.49 We revisit our stuck analysis of Figure 1.17. We test a ¬-\nnode and explore the consequences of setting that ¬-node’s mark to T; Fig-\nure 1.18 shows the result of that analysis. Dually, Figure 1.19 tests the\nconsequences of setting that ¬-node’s mark to F. Since both runs reveal a\ncontradiction, the algorithm terminates, ruling that the formula in (1.11) is\nnot satisﬁable.\nIn the exercises, you are asked to show that the speciﬁcation of our cubic\nSAT solver is sound. Its running time is indeed cubic in the size of the\nDAG (and the length of original formula). One factor stems from the linear\nSAT solver used in each test run. A second factor is introduced since each\nunmarked node has to be tested. The third factor is needed since each new\npermanent mark causes all unmarked nodes to be tested again.\np\nq\nr\n¬\n¬\n¬\n¬\n¬\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n¬\n∧\n¬\n∧\n¬\n∧\n¬\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\nBinary decision diagrams\n358\n6.1\nRepresenting boolean functions\n358\n6.1.1\nPropositional formulas and truth tables\n359\n6.1.2\nBinary decision diagrams\n361\n6.1.3\nOrdered BDDs\n366\n6.2\nAlgorithms for reduced OBDDs\n372\n6.2.1\nThe algorithm reduce\n372\n6.2.2\nThe algorithm apply\n373\n6.2.3\nThe algorithm restrict\n377\n6.2.4\nThe algorithm exists\n377\n6.2.5\nAssessment of OBDDs\n380\n6.3\nSymbolic model checking\n382\n6.3.1\nRepresenting subsets of the set of states\n383\n6.3.2\nRepresenting the transition relation\n385\n6.3.3\nImplementing the functions pre∃and pre∀\n387\n6.3.4\nSynthesising OBDDs\n387\n6.4\nA relational mu-calculus\n390\n6.4.1\nSyntax and semantics\n390\n6.4.2\nCoding CTL models and speciﬁcations\n393\n6.5\nExercises\n398\n6.6\nBibliographic notes\n413\nBibliography\n414\nIndex\n418\nForeword to the first edition\nby\nEdmund M. Clarke\nFORE Systems Professor of Computer Science\nCarnegie Mellon University\nPittsburgh, PA\nFormal methods have ﬁnally come of age! Speciﬁcation languages, theorem\nprovers, and model checkers are beginning to be used routinely in industry.\nMathematical logic is basic to all of these techniques. Until now textbooks\non logic for computer scientists have not kept pace with the development\nof tools for hardware and software speciﬁcation and veriﬁcation. For exam-\nple, in spite of the success of model checking in verifying sequential circuit\ndesigns and communication protocols, until now I did not know of a sin-\ngle text, suitable for undergraduate and beginning graduate students, that\nattempts to explain how this technique works. As a result, this material is\nrarely taught to computer scientists and electrical engineers who will need to",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-2-subsection-4",
                            "title": "The Algorithm Exists",
                            "content": "only if x is 1; or y is 0 and z is 1 – this is a constraint on x, y, and z.\nIt is useful to be able to express the relaxation of the constraint on a subset\nof the variables concerned. To allow this, we write ∃x. f for the boolean\nfunction f with the constraint on x relaxed. Formally, ∃x. f is deﬁned as\nf[0/x] + f[1/x]; that is, ∃x. f is true if f could be made true by putting x\nto 0 or to 1. Given that ∃x. f\ndef\n= f[0/x] + f[1/x] the exists algorithm can\nbe implemented in terms of the algorithms apply and restrict as\napply (+, restrict (0, x, Bf), restrict (1, x, Bf)) .\n(6.3)\nConsider, for example, the OBDD Bf for the function f\ndef\n= x1 · y1 + x2 ·\ny2 + x3 · y3, shown in Figure 6.19. Figure 6.20 shows restrict(0, x3, Bf)\nand restrict(1, x3, Bf) and the result of applying + to them. (In this case\nthe apply function happens to return its second argument.)\nWe can improve the eﬃciency of this algorithm. Consider what happens\nduring the apply stage of (6.3). In that case, the apply algorithm works on\ntwo BDDs which are identical all the way down to the level of the x-nodes;\n378\n6 Binary decision diagrams\n1\n0\nx\nx\nx\nz\ny\nFigure 6.18. An example of a BDD which is not a read-1-BDD.\n1\n0\nx1\nx2\nx3\ny1\ny2\ny3\nFigure 6.19. A BDD Bf to illustrate the exists algorithm.\ntherefore the returned BDD also has that structure down to the x-nodes.\nAt the x-nodes, the two argument BDDs diﬀer, so the apply algorithm\nwill compute the apply of + to these two subBDDs and return that as the\nsubBDD of the result. This is illustrated in Figure 6.20. Therefore, we can\ncompute the OBDD for ∃x. f by taking the OBDD for f and replacing each\nnode labelled with x by the result of calling apply on + and its two branches.\nThis can easily be generalised to a sequence of exists operations. We\nwrite ∃ˆx. f to mean ∃x1.∃x2. . . . ∃xn. f, where ˆx denotes (x1, x2, . . . , xn).\n6.2 Algorithms for reduced OBDDs\n379\n1\n0\nx1\nx2\ny1\ny2\ny3\n1\n0\n1\n0\nx1\nx2\ny1\ny2\nx1\nx2\ny1\ny2\ny3\ncomplexity, 380\ncontrol structure, 374\nrecursive descent, 375\nalgorithm CNF, 59\nalgorithm reduce, 372\ncomplexity, 380\nalgorithm restrict, 377\ncomplexity, 380\nalgorithm reduce\nexample execution, 373\nAlloy\n[], 153\nfun-statement, 155\nwith, 146\nassertion, 144\ncheck directive, 144\nconsistency check, 144\nconstrain signature, 150\ncounterexample, 144\ndot operator, 144\nextending signature, 169\nimplication, 147\nlet-expression, 153\nlimitations, 156\nmodiﬁers, 150\nmodule, 146\nopening module, 156\npolymorphism, 156\npostcondition, 151\nprecondition, 151\nreﬂexive, transitive closure, 169\nrun directive, 146\nsignature, 143\ninstance, 144\nsmall scope hypothesis, 143, 168\ntransitive closure, 155\nuniversal quantiﬁcation, 146\nalternating bit protocol, 203\nalways in the future, 318\nand-elimination, 6, 339\nand-introduction, 6, 339\napplication domain, 173, 257\napproach\nmodel-based, 173\nproof-based, 173\napproximants\nµmZ.f, 392\nνmZ.f, 393\narity, 99\narray, 299\nbounds, 136, 287\nﬁeld, 287\nof integers, 287\nsection, 287\nartiﬁcial intelligence, 306\nartiﬁcial language, 93\nassertion checking, 143\nassignment, 191\ninitial, 292\nnon-deterministic, 205, 230\nprogram notation, 261\nstatement, 261\nassociativity laws, 56, 88\nassumption, 4\ndischarging, 28, 329\ntemporary, 11, 121\n418\nIndex\n419\nasynchronous\ncircuit, 358\ninterleaving, 189\natomic formula, 335\nof modal logic, 307\nof predicate logic\nmeaning, 124\naxiom\n5, 331\nT, 341\n4, 327, 330, 339\n5, 330, 339\nT, 327, 330, 339, 343\nfor assignment, 270\nfor equality, 107\ninstance, 271\nBackus Naur form (BNF), 33\nbackwards breadth-ﬁrst search, 225,\n232\nbase case, 41, 42, 86\nbasic modal logic, 307\nBDD, 364\nhi(n), 372\nlo(n), 372\nas boolean function, 365\ncomplement, 367\nconsistent path, 365\nedge, 361\nexamples, 365\nhas an ordering, 367\nlayer of variables, 361\nline\ndashed, 362, 365\nsolid, 362, 365\nordered, 367\nread-1, 405\nreduced, 365\nremoval of duplicate non-terminals, 363\nremoval of duplicate terminals, 363\nremoval of redundant tests, 363\nsatisﬁable, 365\nsubBDD, 363\nThis can easily be generalised to a sequence of exists operations. We\nwrite ∃ˆx. f to mean ∃x1.∃x2. . . . ∃xn. f, where ˆx denotes (x1, x2, . . . , xn).\n6.2 Algorithms for reduced OBDDs\n379\n1\n0\nx1\nx2\ny1\ny2\ny3\n1\n0\n1\n0\nx1\nx2\ny1\ny2\nx1\nx2\ny1\ny2\ny3\nFigure 6.20. restrict(0, x3, Bf) and restrict(1, x3, Bf) and the result\nof applying + to them.\n1\n0\nx1\nx2\nx3\ny1\ny2\ny3\n1\n0\nx1\nx2\ny1\ny2\ny3\n1\n0\nx1\ny1\ny2\ny3\n∃x3\n⇒\n∃x2\n⇒\nFigure 6.21. OBDDs for f, ∃x3. f and ∃x2.∃x3. f.\nThe OBDD for this boolean function is obtained from the OBDD for f by\nreplacing every node labelled with an xi by the + of its two branches.\nFigure 6.21 shows the computation of ∃x3. f and ∃x2.∃x3. f (which is\nsemantically equivalent to x1 · y1 + y2 + y3) in this way.\nThe boolean quantiﬁer ∀is the dual of ∃:\n∀x.f\ndef\n= f[0/x] · f[1/x]\nasserting that f could be made false by putting x to 0 or to 1.\nThe translation of boolean formulas into OBDDs using the algorithms of\nthis section is summarised in Figure 6.22.\n380\n6 Binary decision diagrams\nBoolean formula f\nRepresenting OBDD Bf\n0\nB0 (Fig. 6.6)\n1\nB1 (Fig. 6.6)\nx\nBx (Fig. 6.6)\nf\nswap the 0- and 1-nodes in Bf\nf + g\napply (+, Bf, Bg)\nf · g\napply (· , Bf, Bg)\nf ⊕g\napply (⊕, Bf, Bg)\nf[1/x]\nrestrict (1, x, Bf)\nf[0/x]\nrestrict (0, x, Bf)\n∃x.f\napply (+, Bf[0/x], Bf[1/x])\n∀x.f\napply (· , Bf[0/x], Bf[1/x])\nFigure 6.22. Translating boolean formulas f to OBDDs Bf, given a\nfixed, global ordering on boolean variables.\nAlgorithm Input OBDD(s)\nOutput OBDD\nTime-complexity\nreduce\nB\nreduced B\nO(|B| · log |B|)\napply\nBf, Bg (reduced) Bf op g (reduced)\nO(|Bf| · |Bg|)\nrestrict Bf (reduced)\nBf[0/x] or Bf[1/x] (reduced) O(|Bf| · log |Bf|)\n∃\nBf (reduced)\nB∃x1.∃x2....∃xn.f (reduced)\nNP-complete\nFigure 6.23. Upper bounds in terms of the input OBDD(s) for the\nworst-case running times of our algorithms needed in our implementa-\ntion of boolean formulas.\n6.2.5 Assessment of OBDDs\nTime complexities for computing OBDDs\nWe can measure the com-\nstatement until, and if, the value of c equals 1. The if-statement tests\nwhether c is even – divisible by 2 – if so, c stores its current value divided\nby 2; if not, c stores ‘three times its current value plus 1.’ The expression\nc / 2 denotes integer division, so 11 / 2 renders 5 as does 10 / 2.\nTo get a feel for this algorithm, consider an execution trace in which the\nvalue of x is 5: the value of c evolves as 5 16 8 4 2 1. For another example,\nif the value of x is initially 172, the evolution of c is\n172 86 43 130 65 196 98 49 148 74 37 112 56 28 14 7 22\n11 34 17 52 26 13 40 20 10 5 16 8 4 2 1\nThis execution requires 32 iterations of the while-statement to reach a ter-\nminating state in which the value of c equals 1. Notice how this trace reaches\n5, from where on the continuation is as if 5 were the initial value of x.\nFor the initial value 123456789 of x we abstract the evolution of c with +\n(its value increases in the else-branch) and −(its value decreases in the\nif-branch):\n+ - - - - - - + - - - + - + - - + - + - + - + - + - + - - + - - -\n- + - - - - + - - + - - + - - + - + - - - + - + - - - - - + - - +\n- + - - + - - - - + - - - - - - + - - + - + - - + - + - + - - + -\n+ - + - + - - + - - - + - + - + - - + - + - - + - + - + - + - + -\n+ - - - + - + - + - + - - - - + - - + - - + - - - - + - - - + - +\n- + - - - - - + - - - -\n296\n4 Program verification\nThis requires 177 iterations of the while-statement to reach a terminating\nstate. Although it is re-assuring that some program runs terminate, the\nirregular pattern of + and −above make it seem very hard, if not impossible,\nto come up with a variant that proves the termination of Collatz on all\nexecutions in which the initial value of x is positive.\nFinally, let’s consider a really big integer:\n32498723462509735034567279652376420563047563456356347563\\\\\n96598734085384756074086560785607840745067340563457640875\\\\\n62984573756306537856405634056245634578692825623542135761\\\\\n9519765129854122965424895465956457\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\nBinary decision diagrams\n358\n6.1\nRepresenting boolean functions\n358\n6.1.1\nPropositional formulas and truth tables\n359\n6.1.2\nBinary decision diagrams\n361\n6.1.3\nOrdered BDDs\n366\n6.2\nAlgorithms for reduced OBDDs\n372\n6.2.1\nThe algorithm reduce\n372\n6.2.2\nThe algorithm apply\n373\n6.2.3\nThe algorithm restrict\n377\n6.2.4\nThe algorithm exists\n377\n6.2.5\nAssessment of OBDDs\n380\n6.3\nSymbolic model checking\n382\n6.3.1\nRepresenting subsets of the set of states\n383\n6.3.2\nRepresenting the transition relation\n385\n6.3.3\nImplementing the functions pre∃and pre∀\n387\n6.3.4\nSynthesising OBDDs\n387\n6.4\nA relational mu-calculus\n390\n6.4.1\nSyntax and semantics\n390\n6.4.2\nCoding CTL models and speciﬁcations\n393\n6.5\nExercises\n398\n6.6\nBibliographic notes\n413\nBibliography\n414\nIndex\n418\nForeword to the first edition\nby\nEdmund M. Clarke\nFORE Systems Professor of Computer Science\nCarnegie Mellon University\nPittsburgh, PA\nFormal methods have ﬁnally come of age! Speciﬁcation languages, theorem\nprovers, and model checkers are beginning to be used routinely in industry.\nMathematical logic is basic to all of these techniques. Until now textbooks\non logic for computer scientists have not kept pace with the development\nof tools for hardware and software speciﬁcation and veriﬁcation. For exam-\nple, in spite of the success of model checking in verifying sequential circuit\ndesigns and communication protocols, until now I did not know of a sin-\ngle text, suitable for undergraduate and beginning graduate students, that\nattempts to explain how this technique works. As a result, this material is\nrarely taught to computer scientists and electrical engineers who will need to",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-3",
                    "title": "Symbolic Model Checking",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-3-subsection-1",
                            "title": "Representing Subsets of the Set of States",
                            "content": "represent a subset T by the boolean function fT which maps (v1, v2, . . . , vn)\nonto 1 if s ∈T and maps it onto 0 otherwise.\nThere are 2n boolean vectors (v1, v2, . . . , vn) of length n. Therefore, n\nshould be chosen such that 2n−1 < |S| ≤2n, where |S| is the number of\nelements in S. If |S| is not an exact power of 2, there will be some vec-\ntors which do not correspond to any element of S; they are just ignored.\nThe function fT : {0, 1}n →{0, 1} which tells us, for each s, represented by\n(v1, v2, . . . , vn), whether it is in the set T or not, is called the characteristic\nfunction of T.\nIn the case that S is the set of states of a transition system M = (S, →, L)\n(see Deﬁnition 3.4), there is a natural way of choosing the representation\nof S as boolean vectors. The labelling function L : S →P(Atoms) (where\nP(Atoms) is the set of subsets of Atoms) gives us the encoding. We assume\na ﬁxed ordering on the set Atoms, say x1, x2, . . . , xn, and then represent\ns ∈S by the vector (v1, v2, . . . , vn), where, for each i, vi equals 1 if xi ∈\nL(s) and vi is 0 otherwise. In order to guarantee that each s has a unique\nrepresentation as a boolean vector, we require that, for all s1, s2 ∈S, L(s1) =\nL(s2) implies s1 = s2. If this is not the case, perhaps because 2|Atoms| < |S|,\nwe can add extra atomic propositions in order to make enough distinctions\n(Cf. introduction of the turn variable for mutual exclusion in Section 3.3.4.)\nFrom now on, we refer to a state s ∈S by its representing boolean vector\n(v1, v2, . . . , vn), where vi is 1 if xi ∈L(s) and 0 otherwise. As an OBDD,\nthis state is represented by the OBDD of the boolean function l1 · l2 · · · · · ln,\nwhere li is xi if xi ∈L(s) and xi otherwise. The set of states {s1, s2, . . . , sm}\nis represented by the OBDD of the boolean function\n(l11 · l12 · · · · · l1n) + (l21 · l22 · · · · · l2n) + · · · + (lm1 · lm2 · · · · · lmn)\nwhere li1 · li2 · · · · · lin represents state si.\n384\n6 Binary decision diagrams\ns2\nx1\ns0\nx2\ns1\nTheorem 3.24. Therefore it suﬃces to show that this set equals [[E(φ U ψ)]].\nSimply observe what kind of states we obtain by iterating G on the empty set\n∅: G1(∅) = [[ψ]] ∪([[φ]] ∩pre∃([[∅]])) = [[ψ]] ∪([[φ]] ∩∅) = [[ψ]] ∪∅= [[ψ]], which are\nall states s0 ∈[[E(φ U ψ)]], where we chose i = 0 according to the deﬁnition of\nUntil. Now,\nG2(∅) = [[ψ]] ∪([[φ]] ∩pre∃(G1(∅)))\ntells us that the elements of G2(∅) are all those s0 ∈[[E(φ U ψ)]] where we chose\ni ≤1. By mathematical induction, we see that Gk+1(∅) is the set of all states\ns0 for which we chose i ≤k to secure s0 ∈[[E(φ U ψ)]]. Since this holds for all\nk, we see that [[E(φ U ψ)]] is nothing but the union of all sets Gk+1(∅) with\nk ≥0; but, since Gn+1(∅) is a ﬁxed point of G, we see that this union is just\nGn+1(∅).\n2\nThe correctness of the coding of SATEU follows similarly to that of\nSATEG. We change the line Y := Y ∪(W ∩pre∃(Y )) into Y := SAT(ψ) ∪\n(W ∩pre∃(Y )) and observe that this does not change the result of the pro-\ncedure, because the ﬁrst time round the loop, Y is SAT(ψ); and, since Y is\nalways increasing, it makes no diﬀerence whether we perform a union with\nY or with SAT(ψ). Having made that change, it is then clear that SATEU is\njust computing the least ﬁxed point of G using Theorem 3.24.\nWe illustrate these results about the functions F\nand G above\nthrough an example. Consider the system in Figure 3.38. We begin\nby computing the set [[EF p]]. By the deﬁnition of EF\nthis is just\n[[E(⊤U p)]]. So we have φ1\ndef\n= ⊤and φ2\ndef\n= p. From Figure 3.38, we ob-\ntain [[p]] = {s3} and of course [[⊤]] = S. Thus, the function G above\nequals G(X) = {s3} ∪pre∃(X). Since [[E(⊤U p)]] equals the least ﬁxed\npoint of G, we need to iterate G on ∅until this process stabilises.\nFirst, G1(∅) = {s3} ∪pre∃(∅) = {s3}. Second, G2(∅) = G(G1(∅)) = {s3} ∪\npre∃({s3}) = {s1, s3}. Third, G3(∅) = G(G2(∅)) = {s3} ∪pre∃({s1, s3}) =\n{s0, s1, s2, s3}. Fourth, G4(∅) = G(G3(∅)) = {s3} ∪pre∃({s0, s1, s2, s3}) =\nbegin\nW := SAT (φ);\nX := S;\nY := SAT (ψ);\nrepeat until X = Y\nbegin\nX := Y ;\nY := Y ∪(W ∩pre∃(Y ))\nend\nreturn Y\nend\nFigure 3.31. The function SATEU. It computes the states satisfying φ by\ncalling SAT. Then, it accumulates states satisfying E[φ U ψ] in the manner\ndescribed in the labelling algorithm.\nThe ‘state explosion’ problem\nAlthough the labelling algorithm (with\nthe clever way of handling EG) is linear in the size of the model, unfortu-\nnately the size of the model is itself more often than not exponential in the\nnumber of variables and the number of components of the system which\nexecute in parallel. This means that, for example, adding a boolean variable\nto your program will double the complexity of verifying a property of it.\nThe tendency of state spaces to become very large is known as the state\nexplosion problem. A lot of research has gone into ﬁnding ways of overcoming\nit, including the use of:\nr Eﬃcient data structures, called ordered binary decision diagrams (OBDDs),\nwhich represent sets of states instead of individual states. We study these in\nChapter 6 in detail. SMV is implemented using OBDDs.\nr Abstraction: one may interpret a model abstractly, uniformly or for a speciﬁc\nproperty.\nr Partial order reduction: for asynchronous systems, several interleavings of com-\nponent traces may be equivalent as far as satisfaction of the formula to be checked\nis concerned. This can often substantially reduce the size of the model-checking\nproblem.\nr Induction: model-checking systems with (e.g.) large numbers of identical, or sim-\nilar, components can often be implemented by ‘induction’ on this number.\n230\n3 Verification by model checking\nr Composition: break the veriﬁcation problem down into several simpler veriﬁca-\ntion problems.\nThe last four issues are beyond the scope of this book, but references may\nbe found at the end of this chapter.\n3.6.2 CTL model checking with fairness\nThe veriﬁcation of M, s0 ⊨φ might fail because the model M may contain\nby the boolean function x1 + x2, since its OBDD is smaller than that for\nx1 · x2 + x1 · x2 (Figure 6.26).\nIn order to justify the claim that the representation of subsets of S as\nOBDDs will be suitable for the algorithm presented in Section 3.6.1, we need\nto look at how the operations on subsets which are used in that algorithm\ncan be implemented in terms of the operations we have deﬁned on OBDDs.\nThe operations in that algorithm are:\nr Intersection, union and complementation of subsets. It is clear that these are\nrepresented by the boolean functions ·, + and ¯ respectively. The implementation\nvia OBDDs of · and + uses the apply algorithm (Section 6.2.2).\nr The functions\npre∃(X) = {s ∈S | exists s′, (s →s′ and s′ ∈X)}\n(6.4)\npre∀(X) = {s | for all s′, (s →s′ implies s′ ∈X)}.\nThe function pre∃(instrumental in SATEX and SATEU) takes a subset X of states\nand returns the set of states which can make a transition into X. The function\npre∀, used in SATAF, takes a set X and returns the set of states which can make\na transition only into X. In order to see how these are implemented in terms of\nOBDDs, we need ﬁrst to look at how the transition relation itself is represented.\n6.3.2 Representing the transition relation\nThe transition relation →of a model M = (S, →, L) is a subset of S × S.\nWe have already seen that subsets of a given ﬁnite set may be represented\nas OBDDs by considering the characteristic function of a binary encoding.\nJust like in the case of subsets of S, the binary encoding is naturally given\nby the labelling function L. Since →is a subset of S × S, we need two copies\nof the boolean vectors. Thus, the link s →s′ is represented by the pair of\n386\n6 Binary decision diagrams\nx1\nx2\nx′\n1\nx′\n2\n→\n0\n0\n0\n0\n1\n0\n0\n0\n1\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n1\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\n1\n1\n1\n0\n1\n0\n0\n1\n0\n1\n1\n0\n1\n1\n0\n0\n0\n1\n1\n0\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n0\nx1\nx′\n1\nx2\nx′\n2\n→\n0\n0\n0\n0\n1\n0\n0\n0\n1\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n1\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\nnow we are interested only in the mechanism in principle of the algorithm\nfor SAT; any (correct and eﬃcient) implementation of sets would do and\nwe study such an implementation in Chapter 6. We assume that SAT has\naccess to all the relevant parts of the model: S, →and L. In particular,\nwe ignore the fact that SAT would require a description of M as input as\nwell. We simply assume that SAT operates directly on any such given model.\nNote how SAT translates φ into an equivalent formula of the adequate set\nchosen.\n3.6 Model-checking algorithms\n227\nfunction SAT (φ)\n/* determines the set of states satisfying φ */\nbegin\ncase\nφ is ⊤: return S\nφ is ⊥: return ∅\nφ is atomic: return {s ∈S | φ ∈L(s)}\nφ is ¬φ1 : return S −SAT (φ1)\nφ is φ1 ∧φ2 : return SAT (φ1) ∩SAT (φ2)\nφ is φ1 ∨φ2 : return SAT (φ1) ∪SAT (φ2)\nφ is φ1 →φ2 : return SAT (¬φ1 ∨φ2)\nφ is AX φ1 : return SAT (¬EX ¬φ1)\nφ is EX φ1 : return SATEX(φ1)\nφ is A[φ1 U φ2] : return SAT(¬(E[¬φ2 U (¬φ1 ∧¬φ2)] ∨EG ¬φ2))\nφ is E[φ1 U φ2] : return SATEU(φ1, φ2)\nφ is EF φ1 : return SAT (E(⊤U φ1))\nφ is EG φ1 : return SAT(¬AF ¬φ1)\nφ is AF φ1 : return SATAF (φ1)\nφ is AG φ1 : return SAT (¬EF ¬φ1)\nend case\nend function\nFigure 3.28. The function SAT. It takes a CTL formula as input and\nreturns the set of states satisfying the formula. It calls the functions\nSATEX, SATEU and SATAF, respectively, if EX , EU or AF is the root of the\ninput’s parse tree.\nThe algorithm is presented in Figure 3.28 and its subfunctions in Fig-\nures 3.29–3.31. They use program variables X, Y , V and W which are sets\nof states. The program for SAT handles the easy cases directly and passes\nmore complicated cases on to special procedures, which in turn might call\nSAT recursively on subexpressions. These special procedures rely on imple-\nmentations of the functions\npre∃(Y ) = {s ∈S | exists s′, (s →s′ and s′ ∈Y )}\npre∀(Y ) = {s ∈S | for all s′, (s →s′ implies s′ ∈Y )}.\n‘Pre’ denotes travelling backwards along the transition relation. Both func-",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-2",
                            "title": "Representing the Transition Relation",
                            "content": "quite diﬀerent.\nThe following are not well-formed formulas:\nr U r – since U is binary, not unary\nr p G q – since G is unary, not binary.\n178\n3 Verification by model checking\nDeﬁnition 3.3 A subformula of an LTL formula φ is any formula ψ whose\nparse tree is a subtree of φ’s parse tree.\nThe subformulas of p W (q U r), e.g., are p, q, r, q U r and p W (q U r).\n3.2.2 Semantics of LTL\nThe kinds of systems we are interested in verifying using LTL may be\nmodelled as transition systems. A transition system models a system by\nmeans of states (static structure) and transitions (dynamic structure). More\nformally:\nDeﬁnition 3.4 A transition system M = (S, →, L) is a set of states S\nendowed with a transition relation\n→(a binary relation on S), such\nthat every s ∈S has some s′ ∈S with s →s′, and a labelling function\nL: S →P(Atoms).\nTransition systems are also simply called models in this chapter. So a model\nhas a collection of states S, a relation →, saying how the system can move\nfrom state to state, and, associated with each state s, one has the set of\natomic propositions L(s) which are true at that particular state. We write\nP(Atoms) for the power set of Atoms, a collection of atomic descriptions.\nFor example, the power set of {p, q} is {∅, {p}, {q}, {p, q}}. A good way of\nthinking about L is that it is just an assignment of truth values to all the\npropositional atoms, as it was the case for propositional logic (we called\nthat a valuation). The diﬀerence now is that we have more than one state,\nso this assignment depends on which state s the system is in: L(s) contains\nall atoms which are true in state s.\nWe may conveniently express all the information about a (ﬁnite) tran-\nsition system M using directed graphs whose nodes (which we call states)\ncontain all propositional atoms that are true in that state. For example, if\nour system has only three states s0, s1 and s2; if the only possible transi-\ntions between states are s0 →s1, s0 →s2, s1 →s0, s1 →s2 and s2 →s2;\nit.\nThe transition system corresponding to this program is shown in\nFigure 3.11. Each state shows the values of the variables; for example, ct1\nis the state in which process 1 and 2 are critical and trying, respectively,\nand turn=1. The labels on the transitions show which process was selected\nfor execution. In general, each state has several transitions, some in which\nprocess 1 moves and others in which process 2 moves.\nThis model is a bit diﬀerent from the previous model given for mutual\nexclusion in Figure 3.8, for these two reasons:\nr Because the boolean variable turn has been explicitly introduced to distinguish\nbetween states s3 and s9 of Figure 3.8, we now distinguish between certain states\n198\n3 Verification by model checking\ncn0\ntn0\ntc0\ntt0\nnn0\nct0\n1,2\n2\n1\n1\n1\n2\n1,2\n1\n2\n2\n2\n2\n1\n1\n2\n1\n1,2\n1\n1,2\n1,2\n1\n2\n2\n2\n1\n2\n1\n1\n1\n2\n1\n2\n2\nnn1\ntn1\ncn1\nct1\nnt1\ntt1\nnc1\ntc1\n1,2\n2\nnc0\nnt0\n1,2\n2\n1\n1,2\n1,2\n1\n1,2\nFigure 3.11. The transition system corresponding to the SMV code\nin Figure 3.10. The labels on the transitions denote the process which\nmakes the move. The label 1, 2 means that either process could make\nthat move.\n3.3 Model checking: systems, tools, properties\n199\n(for example, ct0 and ct1) which were identical before. However, these states\nare not distinguished if you look just at the transitions from them. Therefore,\nthey satisfy the same LTL formulas which don’t mention turn. Those states are\ndistinguished only by the way they can arise.\nr We have eliminated an over-simpliﬁcation made in the model of Figure 3.8. Recall\nthat we assumed the system would move to a diﬀerent state on every tick of the\nclock (there were no transitions from a state to itself). In Figure 3.11, we allow\ntransitions from each state to itself, representing that a process was chosen for\nexecution and did some private computation, but did not move in or out of its\ncritical section. Of course, by doing this we have introduced paths in which one\nConsider the path π = s1 →s2 →. . . . It represents a possible future of\nour system: ﬁrst it is in state s1, then it is in state s2, and so on. We write\nπi for the suﬃx starting at si, e.g., π3 is s3 →s4 →. . . .\n180\n3 Verification by model checking\np, q\nr\nr\nr\nq, r\np, q\nq, r\ns0\ns2\ns2\ns2\ns0\ns1\ns1\nr\ns2\nr\ns2\nFigure 3.5. Unwinding the system of Figure 3.3 as an infinite tree of\nall computation paths beginning in a particular state.\nIt is useful to visualise all possible computation paths from a given state\ns by unwinding the transition system to obtain an inﬁnite computation tree.\nFor example, if we unwind the state graph of Figure 3.3 for the designated\nstarting state s0, then we get the inﬁnite tree in Figure 3.5. The execu-\ntion paths of a model M are explicitly represented in the tree obtained by\nunwinding the model.\nDeﬁnition 3.6 Let M = (S, →, L) be a model and π = s1 →. . . be a path\nin M. Whether π satisﬁes an LTL formula is deﬁned by the satisfaction\nrelation ⊨as follows:\n1.\nπ ⊨⊤\n2.\nπ ̸⊨⊥\n3.\nπ ⊨p iﬀp ∈L(s1)\n4.\nπ ⊨¬φ iﬀπ ̸⊨φ\n5.\nπ ⊨φ1 ∧φ2 iﬀπ ⊨φ1 and π ⊨φ2\n6.\nπ ⊨φ1 ∨φ2 iﬀπ ⊨φ1 or π ⊨φ2\n7.\nπ ⊨φ1 →φ2 iﬀπ ⊨φ2 whenever π ⊨φ1\n8.\nπ ⊨X φ iﬀπ2 ⊨φ\n9.\nπ ⊨G φ iﬀ, for all i ≥1, πi ⊨φ\n3.2 Linear-time temporal logic\n181\ns0\ns1\ns2\ns3\ns4\ns5\ns6\ns7\ns8\ns9\ns10\n\u0001\n\u0002\u0003\n\u0004\np\nq\n. . .\nFigure 3.6. An illustration of the meaning of Until in the semantics of\nLTL. Suppose p is satisfied at (and only at) s3, s4, s5, s6, s7, s8 and q is\nsatisfied at (and only at) s9. Only the states s3 to s9 each satisfy p U q\nalong the path shown.\n10.\nπ ⊨F φ iﬀthere is some i ≥1 such that πi ⊨φ\n11.\nπ ⊨φ U ψ iﬀthere is some i ≥1 such that πi ⊨ψ and for all j = 1, . . . , i −1\nwe have πj ⊨φ\n12.\nπ ⊨φ W ψ iﬀeither there is some i ≥1 such that πi ⊨ψ and for all j =\n1, . . . , i −1 we have πj ⊨φ; or for all k ≥1 we have πk ⊨φ\n13.\nπ ⊨φ R ψ iﬀeither there is some i ≥1 such that πi ⊨φ and for all j = 1, . . . , i\nwe have πj ⊨ψ, or for all k ≥1 we have πk ⊨ψ.\nx1\nx2\nx′\n1\nx′\n2\n→\n0\n0\n0\n0\n1\n0\n0\n0\n1\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n1\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\n1\n1\n1\n0\n1\n0\n0\n1\n0\n1\n1\n0\n1\n1\n0\n0\n0\n1\n1\n0\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n0\nx1\nx′\n1\nx2\nx′\n2\n→\n0\n0\n0\n0\n1\n0\n0\n0\n1\n0\n0\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n1\n0\n0\n1\n0\n1\n0\n1\n0\n0\n1\n1\n0\n0\n0\n1\n1\n1\n0\n1\n0\n0\n0\n0\n1\n0\n0\n1\n1\n1\n0\n1\n0\n0\n1\n0\n1\n1\n0\n1\n1\n0\n0\n0\n1\n1\n0\n1\n0\n1\n1\n1\n0\n0\n1\n1\n1\n1\n0\nFigure 6.27. The truth table for the transition relation of Figure 6.24\n(see Example 6.13). The left version shows the ordering of variables\n[x1, x2, x′\n1, x′\n2], while the right one orders the variables [x1, x′\n1, x2, x′\n2] (the\nrows are ordered lexicographically).\nboolean vectors ((v1, v2, . . . , vn), (v′\n1, v′\n2, . . . , v′\nn)), where vi is 1 if pi ∈L(s)\nand 0 otherwise; and similarly, v′\ni is 1 if pi ∈L(s′) and 0 otherwise. As an\nOBDD, the link is represented by the OBDD for the boolean function\n(l1 · l2 · · · · · ln) · (l′\n1 · l′\n2 · · · · · l′\nn)\nand a set of links (for example, the entire relation →) is the OBDD for the\n+ of such formulas.\nExample 6.13 To compute the OBDD for the transition relation of Fig-\nure 6.24, we ﬁrst show it as a truth table (Figure 6.27 (left)). Each 1 in\nthe ﬁnal column corresponds to a link in the transition relation and each 0\ncorresponds to the absence of a link. The boolean function is obtained by\ntaking the disjunction of the rows having 1 in the last column and is\nf→def\n= x1 · x2 · x′\n1 · x′\n2 + x1 · x2 · x′\n1 · x′\n2 + x1 · x2 · x′\n1 · x′\n2 + x1 · x2 · x′\n1 · x′\n2.\n(6.5)\nIt turns out that it is usually more eﬃcient to interleave unprimed and\nprimed variables in the OBDD variable ordering for →. We therefore use\n6.3 Symbolic model checking\n387\n0\n1\nx2\nx2\nx′\n2\nx′\n2\nx1\nx′\n1\nx′\n1\nFigure 6.28. An OBDD for the transition relation of Example 6.13.\n[x1, x′\n1, x2, x′\n2] rather than [x1, x2, x′\n1, x′\n2]. Figure 6.27 (right) shows the truth\ntable redrawn with the interleaved ordering of the columns and the rows\nreordered lexicographically. The resulting OBDD is shown in Figure 6.28.\nas binary decision trees or truth tables) which are exponential in size.\nSMV allows us to deﬁne the next value of a variable in terms of the\ncurrent values of variables (see the examples of code in Section 3.3.2)3. This\ncan be compiled into a set of boolean functions fi, one for each variable xi,\nwhich deﬁne the next value of xi in terms of the current values of all the\nvariables. In order to cope with non-deterministic assignment (such as the\nassignment to status in the example on page 192), we extend the set of\nvariables by adding unconstrained variables which model the input. Each x′\ni\nis a deterministic function of this enlarged set of variables; thus, x′\ni ↔fi,\nwhere f ↔g = 1 if, and only if, f and g compute the same values, i.e. it is\na shorthand for f ⊕g.\nThe boolean function representing the transition relation is therefore of\nthe form\n\u0001\n1≤i≤n\nx′\ni ↔fi,\n(6.6)\nwhere \u0002\n1≤i≤n gi is a shorthand for g1 · g2 · . . . · gn. Note that the \u0002 ranges\nonly over the non-input variables. So, if u is an input variable, the boolean\nfunction does not contain any u′ ↔fu.\nFigure 6.22 showed how the reduced OBDD could be computed from the\nparse tree of such a boolean function. Thus, it is possible to compile SMV\nprograms into OBDDs such that their speciﬁcations can be executed accord-\ning to the pseudo-code of the function SAT, now interpreted over OBDDs.\nOn page 396 we will see that this OBDD implementation can be extended\nto simple fairness constraints.\nModelling sequential circuits\nAs a further application of OBDDs to\nveriﬁcation, we show how OBDDs representing circuits may be synthesised.\nSynchronous circuits.\nSuppose that we have a design of a sequential circuit\nsuch as the one in Figure 6.29. This is a synchronous circuit (meaning that\n3 SMV also allows next values to be deﬁned in terms of next values, i.e. the keyword next to appear\nin expressions on the right-hand side of :=. This is useful for describing synchronisations, for\nexample, but we ignore that feature here.",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-3",
                            "title": "Implementing the Functions pre∃ and pre∀",
                            "content": "below hold; justify your answers:\n(a)\n*\nl ⊨(x + y < z) →¬(x ∗y = z)\n(b) l ⊨∀u (u < y) ∨(u ∗z < y ∗z)\n(c)\n*\nl ⊨x + y −z < x ∗y ∗z.\n2.\n*\nFor any φ, ψ and P explain why ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever the relation\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds.\n3. Let the relation P ⊢l ; l′ hold iﬀP’s execution in store l terminates, resulting\nin store l′. Use this formal judgment P ⊢l ; l′ along with the relation l ⊨φ to\ndeﬁne ⊨par and ⊨tot symbolically.\n4. Another reason for proving partial correctness in isolation is that some program\nfragments have the form while (true) {C}. Give useful examples of such pro-\ngram fragments in application programming.\n5.\n*\nUse the proof rule for assignment and logical implication as appropriate to show\nthe validity of\n(a) ⊢par\n\u0001\nx > 0\n\u0002\ny = x + 1\n\u0001\ny > 1\n\u0002\n(b) ⊢par\n\u0001\n⊤\n\u0002\ny = x; y = x + x + y\n\u0001\ny = 3 · x\n\u0002\n(c) ⊢par\n\u0001\nx > 1\n\u0002\na = 1; y = x; y = y - a\n\u0001\ny > 0 ∧x > y\n\u0002\n.\n6.\n*\nWrite down a program P such that\n(a)\n\u0001\n⊤\n\u0002\nP\n\u0001\ny = x + 2\n\u0002\n(b)\n\u0001\n⊤\n\u0002\nP\n\u0001\nz > x + y + 4\n\u0002\nholds under partial correctness; then prove that this is so.\n7. For all instances of Implied in the proof on page 274, specify their corresponding\n⊢AR sequents.\n8. There is a safe way of relaxing the format of the proof rule for assignment: as\nlong as no variable occurring in E gets updated in between the assertion ψ[E/x]\nand the assignment x = E we may conclude ψ right after this assignment. Ex-\nplain why such a proof rule is sound.\n9. (a) Show, by means of an example, that the ‘reversed’ version of the rule Implied\n⊢AR φ →φ′\n\u0001\nφ\n\u0002\nC\n\u0001\nψ\n\u0002\n⊢AR ψ′ →ψ\n\u0001\nφ′\u0002\nC\n\u0001\nψ′\u0002\nImplied Reversed\nis unsound for partial correctness.\n(b) Explain why the modiﬁed rule If-Statement in (4.7) is sound with respect\nto the partial and total satisfaction relation.\n4.6 Exercises\n301\n(c)\n*\nShow that any instance of the modiﬁed rule If-Statement in a proof can\nbe replaced by an instance of the original If-statement and instances of the\nrule Implied. Is the converse true as well?\n10.\n*\nProve the validity of the sequent ⊢par\n\u0001\nall those possible values, writing x0 as a generic value representing them\nall. If assuming φ[x0/x] allows us to prove some χ which doesn’t mention\nx0, then this χ must be true whichever x0 makes φ[x0/x] true. And that’s\nprecisely what the rule ∃e allows us to deduce. Of course, we impose the\nside condition that x0 can’t occur outside its box (therefore, in particular,\nit cannot occur in χ). The box is controlling two things: the scope of x0 and\nalso the scope of the assumption φ[x0/x].\nJust as ∨e says that to use φ1 ∨φ2, you have to be prepared for either of\nthe φi, so ∃e says that to use ∃x φ you have to be prepared for any possible\nφ[x0/x]. Another way of thinking about ∃e goes like this: If you know ∃x φ\nand you can derive some χ from φ[x0/x], i.e. by giving a name to the thing\nyou know exists, then you can derive χ even without giving that thing a\nname (provided that χ does not refer to the name x0).\nThe rule ∃x e is also similar to ∨e in the sense that both of them are\nelimination rules which don’t have to conclude a subformula of the formula\nthey are about to eliminate. Please verify that all other elimination rules\nintroduced so far have this subformula property.2 This property is computa-\ntionally very pleasant, for it allows us to narrow down the search space for\na proof dramatically. Unfortunately, ∃x e, like its cousin ∨e, is not of that\ncomputationally benign kind.\n2 For ∀x e we perform a substitution [t/x], but it preserves the logical structure of φ.\n114\n2 Predicate logic\nLet us practice these rules on a couple of examples. Certainly, we should\nbe able to prove the validity of the sequent ∀x φ ⊢∃x φ. The proof\n1\n∀x φ\npremise\n2\nφ[x/x]\n∀x e 1\n3\n∃x φ\n∃x i 2\ndemonstrates that, where we chose t to be x with respect to both ∀x e and\nto ∃x i (and note that x is free for x in φ and that φ[x/x] is simply φ again).\nProving the validity of the sequent ∀x (P(x) →Q(x)),\n∃x P(x)\n⊢\n∃x Q(x) is more complicated:\n1\n∀x (P(x) →Q(x))\npremise\n2\n∃x P(x)\npremise\nx0\n3\nP(x0)\nin the partial-correctness calculus we develop in this chapter, we say that the\nsequent ⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid.\n2.\nSimilarly, if it can be proved in the total-correctness calculus to be developed\nin this chapter, we say that the sequent ⊢tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid.\nThus, ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds if P is partially correct, while the validity of\n⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nmeans that P can be proved to be partially-correct by our\ncalculus. The ﬁrst one means it is actually correct, while the second one\nmeans it is provably correct according to our calculus.\nIf our calculus is any good, then the relation ⊢par should be contained in\n⊨par! More precisely, we will say that our calculus is sound if, whenever it\ntells us something can be proved, that thing is indeed true. Thus, it is sound\nif it doesn’t tell us that false things can be proved. Formally, we write that\n⊢par is sound if\n⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever ⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid\nfor all φ, ψ and P; and, similarly, ⊢tot is sound if\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever ⊢tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid\nfor all φ, ψ and P. We say that a calculus is complete if it is able to prove\neverything that is true. Formally, ⊢par is complete if\n⊢par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nis valid whenever ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds\nfor all φ, ψ and P; and similarly for ⊢tot being complete.\nIn Chapters 1 and 2, we said that soundness is relatively easy to show,\nsince typically the soundness of individual proof rules can be established\nindependently of the others. Completeness, on the other hand, is harder to\n268\n4 Program verification\nshow since it depends on the entire set of proof rules cooperating together.\nThe same situation holds for the program logic we introduce in this chapter.\nEstablishing its soundness is simply a matter of considering each rule in\nturn – done in exercise 3 on page 303 – whereas establishing its (relative)\ncompleteness is harder and beyond the scope of this book.\n4.2.4 Program variables and logical variables\neven number of complementation symbols ¯; such an f is said to be formally\nmonotone in Z. (In exercise 7 on page 410 we consider what happens if we\ndo not require formal monotonicity.)\n6.4 A relational mu-calculus\n391\nConvention 6.15 The binding priorities for the grammar in (6.10) are that\n¯, and [ˆx := ˆx′] have the highest priority; followed by ∃x and ∀y; then µZ\nand νZ; followed by · . The operators + and ⊕have the lowest binding\npriority.\nThe symbols µ and ν are called least ﬁxed-point and greatest ﬁxed-point\noperators, respectively. In the formula µZ.f, the interesting case is that in\nwhich f contains an occurrence of Z. In that case, f can be thought of as\na function, taking Z to f. The formula µZ.f is intended to mean the least\nﬁxed point of that function. Similarly, νZ.f is the greatest ﬁxed point of the\nfunction. We will see how this is done in the semantics.\nThe formula f[ˆx := ˆx′] expresses an explicit substitution which forces f\nto be evaluated using the values of x′\ni rather than xi. (Recall that the primed\nvariables refer to the next state.) Thus, this syntactic form is not a meta-\noperation denoting a substitution, but an explicit syntactic form in its own\nright. The substitution will be made on the semantic side, not the syntactic\nside. This diﬀerence will become clear when we present the semantics of ⊨.\nA valuation ρ for f is an assignment of values 0 or 1 to all variables v.\nWe deﬁne a satisfaction relation ρ ⊨f inductively over the structure of such\nformulas f, given a valuation ρ.\nDeﬁnition 6.16 Let ρ be a valuation and v a variable. We write ρ(v) for\nthe value of v assigned by ρ. We deﬁne ρ[v \u0011→0] to be the updated valuation\nwhich assigns 0 to v and ρ(w) to all other variables w. Dually, ρ[v \u0011→1]\nassigns 1 to v and ρ(w) to all other variables w.\nFor example, if ρ is the valuation represented by (x, y, Z) ⇒(1, 0, 1) –\nmeaning that ρ(x) = 1, ρ(y) = 0, ρ(Z) = 1 and ρ(v) = 0 for all other vari-\n(e) What is the scope of ∃x in φ?\n(f)\n*\nSuppose that we change φ to ∃x (P(y, z) ∧(∀x (¬Q(x, x) ∨P(x, z)))). What\nis the scope of ∃x now?\n5. (a) Let P be a predicate symbol with arity 3. Draw the parse tree of ψ\ndef\n=\n¬(∀x ((∃y P(x, y, z)) ∧(∀z P(x, y, z)))).\n(b) Indicate the free and bound variables in that parse tree.\n(c) List all variables which occur free and bound therein.\n(d) Compute ψ[t/x], ψ[t/y] and ψ[t/z], where t\ndef\n= g(f(g(y, y)), y). Is t free for x\nin ψ; free for y in ψ; free for z in ψ?\n6. Rename the variables for φ in Example 2.9 (page 106) such that the resulting\nformula ψ has the same meaning as φ, but f(y, y) is free for x in ψ.\nExercises 2.3\n1. Prove the validity of the following sequents using, among others, the rules =i\nand =e. Make sure that you indicate for each application of =e what the rule\ninstances φ, t1 and t2 are.\n(a) (y = 0) ∧(y = x) ⊢0 = x\n(b) t1 = t2 ⊢(t + t2) = (t + t1)\n(c) (x = 0) ∨((x + x) > 0) ⊢(y = (x + x)) →((y > 0) ∨(y = (0 + x))).\n2. Recall that we use = to express the equality of elements in our models. Consider\nthe formula ∃x ∃y (¬(x = y) ∧(∀z ((z = x) ∨(z = y)))). Can you say, in plain\nEnglish, what this formula speciﬁes?\n3. Try to write down a sentence of predicate logic which intuitively holds in a\nmodel iﬀthe model has (respectively)\n(a)\n*\nexactly three distinct elements\n(b) at most three distinct elements\n(c)\n*\nonly ﬁnitely many distinct elements.\n2.8 Exercises\n161\nWhat ‘limitation’ of predicate logic causes problems in ﬁnding such a sentence\nfor the last item?\n4. (a) Find a (propositional) proof for φ →(q1 ∧q2) |−(φ →q1) ∧(φ →q2).\n(b) Find a (predicate) proof for φ →∀x Q(x) |−∀x (φ →Q(x)), provided that\nx is not free in φ.\n(Hint: whenever you used ∧rules in the (propositional) proof of the previous\nitem, use ∀rules in the (predicate) proof.)\n(c) Find a proof for ∀x (P(x) →Q(x)) |−∀x P(x) →∀x Q(x).\n(Hint: try (p1 →q1) ∧(p2 →q2) |−p1 ∧p2 →q1 ∧q2 ﬁrst.)",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-3-subsection-4",
                            "title": "Synthesising OBDDs",
                            "content": "in which we applied the reductions does not matter. We therefore say that\nOBDDs have a canonical form, namely their unique reduced OBDD. Most\nother representations (conjunctive normal forms, etc.) do not have canonical\nforms.\nThe algorithms for · and + for BDDs, presented in Section 6.1.2, won’t\nwork for OBDDs as they may introduce multiple occurrences of the same\nvariable on a path. We will soon develop more sophisticated algorithms\nfor these operations on OBDDs, which exploit the compatible ordering of\nvariables in paths.\nOBDDs allow compact representations of certain classes of boolean func-\ntions which only have exponential representations in other systems, such as\ntruth tables and conjunctive normal forms. As an example consider the even\nparity function feven(x1, x2, . . . , xn) which is deﬁned to be 1 if there is an\neven number of variables xi with value 1; otherwise, it is deﬁned to be 0.\nIts representation as an OBDD requires only 2n + 1 nodes. Its OBDD for\nn = 4 and the ordering [x1, x2, x3, x4] can be found in Figure 6.11.\nThe impact of the chosen variable ordering\nThe size of the OBDD\nrepresenting the parity functions is independent of the chosen variable or-\ndering. This is because the parity functions are themselves independent of\nthe order of variables: swapping the values of any two variables does not\nchange the value of the function; such functions are called symmetric.\nHowever, in general the chosen variable ordering makes a signiﬁcant dif-\nference to the size of the OBDD representing a given function. Consider\nthe boolean function (x1 + x2) · (x3 + x4) · · · · · (x2n−1 + x2n); it corresponds\nto a propositional formula in conjunctive normal form. If we choose the\n1 In an implementation this will amount to checking whether two pointers are equal.\n370\n6 Binary decision diagrams\n1\n0\nx1\nx2\nx3\nx4\nx3\nx2\nx4\nFigure 6.11. An OBDD for the even parity function for four bits.\n‘natural’ ordering [x1, x2, x3, x4, . . . ], then we can represent this function as\nan ordering on their boolean variables. Clearly, every OBDD is a read-1-BDD;\nbut not every read-1-BDD is an OBDD (see Figure 6.10). In Figure 6.18 we see\na BDD which is not a read-1-BDD; the path for (x, y, z) ⇒(1, 0, 1) ‘reads’ the\nvalue of x twice.\nCritically assess the implementation of boolean formulas via OBDDs to see which\nimplementation details could be carried out for read-1-BDDs as well. Which\nimplementation aspects would be problematic?\n4. (For those who have had a course on ﬁnite automata.) Every boolean function\nf in n arguments can be viewed as a subset Lf of {0, 1}n; deﬁned to be the\nset of all those bit vectors (v1, v2, . . . , vn) for which f computes 1. Since this\nis a ﬁnite set, Lf is a regular language and has therefore a deterministic ﬁnite\nautomaton with a minimal number of states which accepts Lf. Can you match\nsome of the OBDD operations with those known for ﬁnite automata? How close\nis the correspondence? (You may have to consider non-reduced OBDDs.)\n5. (a) Show that every boolean function in n arguments can be represented as a\nboolean formula of the grammar\nf ::= 0 | x | f | f1 + f2.\n(b) Why does this also imply that every such function can be represented by a\nreduced OBDD in any variable ordering?\n6. Use mathematical induction on n to prove that there are exactly 2(2n) many\ndiﬀerent boolean functions in n arguments.\nExercises 6.9\n1. Use the exists algorithm to compute the OBDDs for\n(a) ∃x3.f, given the OBDD for f in Figure 6.11 (page 370)\n(b) ∀y.g, given the OBDD for g in Figure 6.9 (page 367)\n(c) ∃x2.∃x3.x1 · y1 + x2 · y2 + x3 · y3.\n2. Let f be a boolean function depending on n variables.\n(a) Show:\n406\n6 Binary decision diagrams\ni. The formula ∃x.f depends on all those variables that f depends upon,\nexcept x.\nii. If f computes to 1 with respect to a valuation ρ, then ∃x.f computes 1\nwith respect to the same valuation.\niii. If ∃x.f computes to 1 with respect to a valuation ρ, then there is a valuation\nveriﬁcation in the early 1990s, because they have allowed systems with much\nlarger state spaces to be veriﬁed. In this section, we describe in detail how\nthe model-checking algorithm presented in Chapter 3 can be implemented\nusing OBDDs as the basic data structure.\nThe pseudo-code presented in Figure 3.28 on page 227 takes as input a\nCTL formula φ and returns the set of states of the given model which satisfy\nφ. Inspection of the code shows that the algorithm consists of manipulating\nintermediate sets of states. We show in this section how the model and the\nintermediate sets of states can be stored as OBDDs; and how the operations\nrequired in that pseudo-code can be implemented in terms of the operations\non OBDDs which we have seen in this chapter.\nWe start by showing how sets of states are represented with OBDDs,\ntogether with some of the operations required. Then, we extend that to\nthe representation of the transition system; and ﬁnally, we show how the\nremainder of the required operations is implemented.\n6.3 Symbolic model checking\n383\nModel checking using OBDDs is called symbolic model checking. The term\nemphasises that individual states are not represented; rather, sets of states\nare represented symbolically, namely, those which satisfy the formula being\nchecked.\n6.3.1 Representing subsets of the set of states\nLet S be a ﬁnite set (we forget for the moment that it is a set of states). The\ntask is to represent the various subsets of S as OBDDs. Since OBDDs encode\nboolean functions, we need somehow to code the elements of S as boolean\nvalues. The way to do this in general is to assign to each element s ∈S a\nunique vector of boolean values (v1, v2, . . . , vn), each vi ∈{0, 1}. Then, we\nrepresent a subset T by the boolean function fT which maps (v1, v2, . . . , vn)\nonto 1 if s ∈T and maps it onto 0 otherwise.\nThere are 2n boolean vectors (v1, v2, . . . , vn) of length n. Therefore, n\nshould be chosen such that 2n−1 < |S| ≤2n, where |S| is the number of\nring along any path. We then adhere to that same ordering for all the BDDs\nwe manipulate.\nDeﬁnition 6.6 Let [x1, . . . , xn] be an ordered list of variables without du-\nplications and let B be a BDD all of whose variables occur somewhere in\nthe list. We say that B has the ordering [x1, . . . , xn] if all variable labels of\nB occur in that list and, for every occurrence of xi followed by xj along any\npath in B, we have i < j.\nAn ordered BDD (OBDD) is a BDD which has an ordering for some list\nof variables.\nNote that the BDDs of Figures 6.3(a,b) and 6.9 are ordered (with ordering\n[x, y]). We don’t insist that every variable in the list is used in the paths.\nThus, the OBDDs of Figures 6.3 and 6.9 have the ordering [x, y, z] and so\n368\n6 Binary decision diagrams\n0\n1\nz\nx\ny\ny\nx\nFigure 6.10. A BDD which does not have an ordering of variables.\ndoes any list having x, y and z in it in that order, such as [u, x, y, v, z, w] and\n[x, u, y, z]. Even the BDDs B0 and B1 in Figure 6.6 are OBDDs, a suitable\nordering list being the empty list (there are no variables), or indeed any list.\nThe BDD Bx of Figure 6.6(b) is also an OBDD, with any list containing x\nas its ordering.\nThe BDD of Figure 6.7 is not ordered. To see why this is so, consider the\npath taken if the values of x and y are 0. We begin with the root, an x-\nnode, and reach a y-node and then an x-node again. Thus, no matter what\nlist arrangement we choose (remembering that no double occurrences are\nallowed), this path violates the ordering condition. Another example of a\nBDD that is not ordered can be seen in Figure 6.10. In that case, we cannot\nﬁnd an order since the path for (x, y, z) ⇒(0, 0, 0) – meaning that x, y and z\nare assigned 0 – shows that y needs to occur before x in such a list, whereas\nthe path for (x, y, z) ⇒(1, 1, 1) demands that x be before y.\nIt follows from the deﬁnition of OBDDs that one cannot have multiple\noccurrences of any variable along a path.\nthe cycle s0 →s1 →s0, and is not a dag. If we interpret the links in BDDs\n(whether solid or dashed) as always going in a downwards direction, then\nthe BDDs of this chapter are also directed graphs. They are also acyclic and\nhave a unique initial node. The optimisations C1–C3 preserve the property\nof being a dag; and fully reduced BDDs have precisely two terminal nodes.\nWe now formally deﬁne BDDs as certain kinds of dags:\nDeﬁnition 6.5 A binary decision diagram (BDD) is a ﬁnite dag with\na unique initial node, where all terminal nodes are labelled with 0 or\n1 and all non-terminal nodes are labelled with a boolean variable. Each\n6.1 Representing boolean functions\n365\n0\n1\n0\nx\nFigure 6.6. The BDDs (a) B0, representing the constant 0 boolean\nfunction; similarly, the BDD B1 has only one node 1 and represents\nthe constant 1 boolean function; and (b) Bx, representing the boolean\nvariable x.\nnon-terminal node has exactly two edges from that node to others: one la-\nbelled 0 and one labelled 1 (we represent them as a dashed line and a solid\nline, respectively).\nA BDD is said to be reduced if none of the optimisations C1–C3 can be\napplied (i.e. no more reductions are possible).\nAll the decision structures we have seen in this chapter (Figures 6.2–6.5)\nare BDDs, as are the constant functions B0 and B1, and the function Bx\nfrom Figure 6.6. If B is a BDD where V = {x1, x2, . . . , xn} is the set of labels\nof non-terminal nodes, then B determines a boolean function f(V ) in the\nsame way as binary decision trees (see Deﬁnition 6.3): given an assignment\nof 0s and 1s to the variables in V , we compute the value of f by starting\nwith the unique initial node. If its variable has value 0, we follow the dashed\nline; otherwise we take the solid line. We continue for each node until we\nreach a terminal node. Since the BDD is ﬁnite by deﬁnition, we eventually\nreach a terminal node which is labelled with 0 or 1. That label is the result\nof f for that particular assignment of truth values.",
                            "children": []
                        }
                    ]
                },
                {
                    "id": "chapter-1-section-4",
                    "title": "A Relational Mu-Calculus",
                    "content": null,
                    "children": [
                        {
                            "id": "chapter-1-section-4-subsection-1",
                            "title": "Syntax and Semantics",
                            "content": "set of n-tuples over A, to A; and\n4.\nfor each P ∈P with arity n > 0, a subset P M ⊆An of n-tuples over A.\n2.4 Semantics of predicate logic\n125\nThe distinction between f and fM and between P and P M is most im-\nportant. The symbols f and P are just that: symbols, whereas fM and\nP M denote a concrete function (or element) and relation in a model M,\nrespectively.\nExample 2.15 Let F\ndef\n= {i} and P\ndef\n= {R, F}; where i is a constant, F a\npredicate symbol with one argument and R a predicate symbol with two\narguments. A model M contains a set of concrete elements A – which may be\na set of states of a computer program. The interpretations iM, RM, and F M\nmay then be a designated initial state, a state transition relation, and a set\nof ﬁnal (accepting) states, respectively. For example, let A\ndef\n= {a, b, c}, iM def\n=\na, RM def\n= {(a, a), (a, b), (a, c), (b, c), (c, c)}, and F M def\n= {b, c}. We informally\ncheck some formulas of predicate logic for this model:\n1.\nThe formula\n∃y R(i, y)\nsays that there is a transition from the initial state to some state; this is true\nin our model, as there are transitions from the initial state a to a, b, and c.\n2.\nThe formula\n¬F(i)\nstates that the initial state is not a ﬁnal, accepting state. This is true in our\nmodel as b and c are the only ﬁnal states and a is the intitial one.\n3.\nThe formula\n∀x∀y∀z (R(x, y) ∧R(x, z) →y = z)\nmakes use of the equality predicate and states that the transition relation is\ndeterministic: all transitions from any state can go to at most one state (there\nmay be no transitions from a state as well). This is false in our model since\nstate a has transitions to b and c.\n4.\nThe formula\n∀x∃y R(x, y)\nstates that the model is free of states that deadlock: all states have a transition\nto some state. This is true in our model: a can move to a, b or c; and b and c\ncan move to c.\nExample 2.16 Let F\ndef\n= {e, ·} and P\ndef\n= {≤}, where e is a constant, · is a\nScience. Addison Wesley, 1991.\nSch92. U. Schoening. Logik f¨ur Informatiker. B. I. Wissenschaftsverlag, 1992.\nSch94. D. A. Schmidt. The Structure of Typed Programming Languages.\nFoundations of Computing. The MIT Press, 1994.\nSim94. A. K. Simpson. The Proof Theory and Semantics of Intuitionistic\nModal Logic. PhD thesis, The University of Edinburgh, Department of\nComputer Science, 1994.\nSS90. G. St˚almarck and M. S˚aﬂund. Modeling and verifying systems and\nsoftware in propositional logic. In B. K. Daniels, editor, Safety of\nComputer Control Systems (SAFECOMP’90), pages 31–36. Pergamon\nPress, 1990.\nBibliography\n417\nTay98. R. G. Taylor. Models of Computation and Formal Languages. Oxford\nUniversity Press, 1998.\nTen91. R. D. Tennent. Semantics of Programming Languages. Prentice Hall,\n1991.\nTur91. R. Turner. Constructive Foundations for Functional Languages.\nMcGraw Hill, 1991.\nvD89. D. van Dalen. Logic and Structure. Universitext. Springer-Verlag, 3rd\nedition, 1989.\nVW84. M. Y. Vardi and Pierre Wolper. Automata-theoretic techniques for\nmodal logics of programs. In Proc. 16th ACM Symposium on Theory\nof Computing, pages 446–456, 1984.\nWei98. M. A. Weiss. Data Structures and Problem Solving Using Java.\nAddison-Wesley, 1998.\nIndex\nABP, 203\nacknowledgement channel, 203\nalternating the control bit, 203\nfairness, 203\nmain SMV program, 207\nabsorption laws, 88\nabstract data type\nsets, 226\nabstraction, 175, 229, 247\nand non-determinism, 191\naccessibility relation, 309, 320, 336\nadequate set of connectives\nfor CTL, 216, 222, 231, 397\nfor LTL, 186\nfor propositional logic, 69, 87, 91\nagent, 307, 319, 327\nalgebraic speciﬁcation, 170\nalgorithm\ndeterministic, 59\nalgorithm apply, 373\ncomplexity, 380\ncontrol structure, 374\nrecursive descent, 375\nalgorithm CNF, 59\nalgorithm reduce, 372\ncomplexity, 380\nalgorithm restrict, 377\ncomplexity, 380\nalgorithm reduce\nexample execution, 373\nAlloy\n[], 153\nfun-statement, 155\nwith, 146\nassertion, 144\ncheck directive, 144\nconsistency check, 144\nexamples, as are variables such as x and v. Function symbols also allow us\nto refer to objects: thus, m(a) and g(x, y) are also objects. Expressions in\npredicate logic which denote objects are called terms.\nThe other sort of things in predicate logic denotes truth values; expres-\nsions of this kind are formulas: Y (x, m(x)) is a formula, though x and m(x)\nare terms.\nA predicate vocabulary consists of three sets: a set of predicate symbols\nP, a set of function symbols F and a set of constant symbols C. Each pred-\nicate symbol and each function symbol comes with an arity, the number of\narguments it expects. In fact, constants can be thought of as functions which\ndon’t take any arguments (and we even drop the argument brackets) – there-\nfore, constants live in the set F together with the ‘true’ functions which do\ntake arguments. From now on, we will drop the set C, since it is convenient to\ndo so, and stipulate that constants are 0-arity, so-called nullary, functions.\n2.2.1 Terms\nThe terms of our language are made up of variables, constant symbols\nand functions applied to those. Functions may be nested, as in m(m(x))\nor g(m(a), c): the grade obtained by Andy’s mother in the course c.\nDeﬁnition 2.1 Terms are deﬁned as follows.\nr Any variable is a term.\nr If c ∈F is a nullary function, then c is a term.\nr If t1, t2, . . . , tn are terms and f ∈F has arity n > 0, then f(t1, t2, . . . , tn) is a\nterm.\nr Nothing else is a term.\nIn Backus Naur form we may write\nt ::= x | c | f(t, . . . , t)\nwhere x ranges over a set of variables var, c over nullary function symbols\nin F, and f over those elements of F with arity n > 0.\nIt is important to note that\nr the ﬁrst building blocks of terms are constants (nullary functions) and variables;\nr more complex terms are built from function symbols using as many previously\nbuilt terms as required by such function symbols; and\nr the notion of terms is dependent on the set F. If you change it, you change the\nset of terms.\n100\nbelow hold; justify your answers:\n(a)\n*\nl ⊨(x + y < z) →¬(x ∗y = z)\n(b) l ⊨∀u (u < y) ∨(u ∗z < y ∗z)\n(c)\n*\nl ⊨x + y −z < x ∗y ∗z.\n2.\n*\nFor any φ, ψ and P explain why ⊨par\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds whenever the relation\n⊨tot\n\u0001\nφ\n\u0002\nP\n\u0001\nψ\n\u0002\nholds.\n3. Let the relation P ⊢l ; l′ hold iﬀP’s execution in store l terminates, resulting\nin store l′. Use this formal judgment P ⊢l ; l′ along with the relation l ⊨φ to\ndeﬁne ⊨par and ⊨tot symbolically.\n4. Another reason for proving partial correctness in isolation is that some program\nfragments have the form while (true) {C}. Give useful examples of such pro-\ngram fragments in application programming.\n5.\n*\nUse the proof rule for assignment and logical implication as appropriate to show\nthe validity of\n(a) ⊢par\n\u0001\nx > 0\n\u0002\ny = x + 1\n\u0001\ny > 1\n\u0002\n(b) ⊢par\n\u0001\n⊤\n\u0002\ny = x; y = x + x + y\n\u0001\ny = 3 · x\n\u0002\n(c) ⊢par\n\u0001\nx > 1\n\u0002\na = 1; y = x; y = y - a\n\u0001\ny > 0 ∧x > y\n\u0002\n.\n6.\n*\nWrite down a program P such that\n(a)\n\u0001\n⊤\n\u0002\nP\n\u0001\ny = x + 2\n\u0002\n(b)\n\u0001\n⊤\n\u0002\nP\n\u0001\nz > x + y + 4\n\u0002\nholds under partial correctness; then prove that this is so.\n7. For all instances of Implied in the proof on page 274, specify their corresponding\n⊢AR sequents.\n8. There is a safe way of relaxing the format of the proof rule for assignment: as\nlong as no variable occurring in E gets updated in between the assertion ψ[E/x]\nand the assignment x = E we may conclude ψ right after this assignment. Ex-\nplain why such a proof rule is sound.\n9. (a) Show, by means of an example, that the ‘reversed’ version of the rule Implied\n⊢AR φ →φ′\n\u0001\nφ\n\u0002\nC\n\u0001\nψ\n\u0002\n⊢AR ψ′ →ψ\n\u0001\nφ′\u0002\nC\n\u0001\nψ′\u0002\nImplied Reversed\nis unsound for partial correctness.\n(b) Explain why the modiﬁed rule If-Statement in (4.7) is sound with respect\nto the partial and total satisfaction relation.\n4.6 Exercises\n301\n(c)\n*\nShow that any instance of the modiﬁed rule If-Statement in a proof can\nbe replaced by an instance of the original If-statement and instances of the\nrule Implied. Is the converse true as well?\n10.\n*\nProve the validity of the sequent ⊢par\n\u0001\n4.\nThe formula\n∀x∃y R(x, y)\nstates that the model is free of states that deadlock: all states have a transition\nto some state. This is true in our model: a can move to a, b or c; and b and c\ncan move to c.\nExample 2.16 Let F\ndef\n= {e, ·} and P\ndef\n= {≤}, where e is a constant, · is a\nfunction of two arguments and ≤is a predicate in need of two arguments as\nwell. Again, we write · and ≤in inﬁx notation as in (t1 · t2) ≤(t · t).\n126\n2 Predicate logic\nThe model M we have in mind has as set A all binary strings, ﬁnite\nwords over the alphabet {0, 1}, including the empty string denoted by ϵ. The\ninterpretation eM of e is just the empty word ϵ. The interpretation ·M of · is\nthe concatenation of words. For example, 0110 ·M 1110 equals 01101110. In\ngeneral, if a1a2 . . . ak and b1b2 . . . bn are such words with ai, bj ∈{0, 1}, then\na1a2 . . . ak ·M b1b2 . . . bn equals a1a2 . . . akb1b2 . . . bn. Finally, we interpret ≤\nas the preﬁx ordering of words. We say that s1 is a preﬁx of s2 if there is\na binary word s3 such that s1 ·M s3 equals s2. For example, 011 is a preﬁx\nof 011001 and of 011, but 010 is neither. Thus, ≤M is the set {(s1, s2) |\ns1 is a preﬁx of s2}. Here are again some informal model checks:\n1.\nIn our model, the formula\n∀x ((x ≤x · e) ∧(x · e ≤x))\nsays that every word is a preﬁx of itself concatenated with the empty word and\nconversely. Clearly, this holds in our model, for s ·M ϵ is just s and every word\nis a preﬁx of itself.\n2.\nIn our model, the formula\n∃y ∀x (y ≤x)\nsays that there exists a word s that is a preﬁx of every other word. This is true,\nfor we may chose ϵ as such a word (there is no other choice in this case).\n3.\nIn our model, the formula\n∀x ∃y (y ≤x)\nsays that every word has a preﬁx. This is clearly the case and there are in\ngeneral multiple choices for y, which are dependent on x.\n4.\nIn our model, the formula ∀x ∀y ∀z ((x ≤y) →(x · z ≤y · z)) says that when-\never a word s1 is a preﬁx of s2, then s1s has to be a preﬁx of s2s for every word",
                            "children": []
                        },
                        {
                            "id": "chapter-1-section-4-subsection-2",
                            "title": "Coding CTL Models and Specifications",
                            "content": "The NuSMV model checker\n191\n3.3.3\nRunning NuSMV\n194\n3.3.4\nMutual exclusion revisited\n195\n3.3.5\nThe ferryman\n199\n3.3.6\nThe alternating bit protocol\n203\n3.4\nBranching-time logic\n207\n3.4.1\nSyntax of CTL\n208\nContents\nvii\n3.4.2\nSemantics of CTL\n211\n3.4.3\nPractical patterns of speciﬁcations\n215\n3.4.4\nImportant equivalences between CTL formulas\n215\n3.4.5\nAdequate sets of CTL connectives\n216\n3.5\nCTL* and the expressive powers of LTL and CTL\n217\n3.5.1\nBoolean combinations of temporal formulas in CTL\n220\n3.5.2\nPast operators in LTL\n221\n3.6\nModel-checking algorithms\n221\n3.6.1\nThe CTL model-checking algorithm\n222\n3.6.2\nCTL model checking with fairness\n230\n3.6.3\nThe LTL model-checking algorithm\n232\n3.7\nThe ﬁxed-point characterisation of CTL\n238\n3.7.1\nMonotone functions\n240\n3.7.2\nThe correctness of SATEG\n242\n3.7.3\nThe correctness of SATEU\n243\n3.8\nExercises\n245\n3.9\nBibliographic notes\n254\n4\nProgram veriﬁcation\n256\n4.1\nWhy should we specify and verify code?\n257\n4.2\nA framework for software veriﬁcation\n258\n4.2.1\nA core programming language\n259\n4.2.2\nHoare triples\n262\n4.2.3\nPartial and total correctness\n265\n4.2.4\nProgram variables and logical variables\n268\n4.3\nProof calculus for partial correctness\n269\n4.3.1\nProof rules\n269\n4.3.2\nProof tableaux\n273\n4.3.3\nA case study: minimal-sum section\n287\n4.4\nProof calculus for total correctness\n292\n4.5\nProgramming by contract\n296\n4.6\nExercises\n299\n4.7\nBibliographic notes\n304\n5\nModal logics and agents\n306\n5.1\nModes of truth\n306\n5.2\nBasic modal logic\n307\n5.2.1\nSyntax\n307\n5.2.2\nSemantics\n308\n5.3\nLogic engineering\n316\n5.3.1\nThe stock of valid formulas\n317\nviii\nContents\n5.3.2\nImportant properties of the accessibility relation\n320\n5.3.3\nCorrespondence theory\n322\n5.3.4\nSome modal logics\n326\n5.4\nNatural deduction\n328\n5.5\nReasoning about knowledge in a multi-agent system\n331\n5.5.1\nSome examples\n332\n5.5.2\nThe modal logic KT45n\n335\n5.5.3\nNatural deduction for KT45n\n339\n5.5.4\nFormalising the examples\n342\n5.6\nExercises\n350\n5.7\nBibliographic notes\n356\n6\n3.6.1 The CTL model-checking algorithm\nHumans may ﬁnd it easier to do model checks on the unwindings of models\ninto inﬁnite trees, given a designated initial state, for then all possible paths\nare plainly visible. However, if we think of implementing a model checker\non a computer, we certainly cannot unwind transition systems into inﬁ-\nnite trees. We need to do checks on ﬁnite data structures. For this reason,\nwe now have to develop new insights into the semantics of CTL. Such a\ndeeper understanding will provide the basis for an eﬃcient algorithm which,\ngiven M, s ∈S and φ, computes whether M, s ⊨φ holds. In the case that\nφ is not satisﬁed, such an algorithm can be augmented to produce an ac-\ntual path (= run) of the system demonstrating that M cannot satisfy φ.\nThat way, we may debug a system by trying to ﬁx what enables runs which\nrefute φ.\nThere are various ways in which one could consider\nM, s0\n?\n⊨φ\nas a computational problem. For example, one could have the model M, the\nformula φ and a state s0 as input; one would then expect a reply of the form\n‘yes’ (M, s0 ⊨φ holds), or ‘no’ (M, s0 ⊨φ does not hold). Alternatively, the\ninputs could be just M and φ, where the output would be all states s of the\nmodel M which satisfy φ.\nIt turns out that it is easier to provide an algorithm for solving the second\nof these two problems. This automatically gives us a solution to the ﬁrst one,\nsince we can simply check whether s0 is an element of the output set.\nThe labelling algorithm\nWe present an algorithm which, given a model\nand a CTL formula, outputs the set of states of the model that satisfy the\nformula. The algorithm does not need to be able to handle every CTL con-\nnective explicitly, since we have already seen that the connectives ⊥, ¬ and\n∧form an adequate set as far as the propositional connectives are concerned;\nand AF , EU and EX form an adequate set of temporal connectives. Given\nan arbitrary CTL formula φ, we would simply pre-process φ in order to write\nIt is possible to implement the check for such a path in terms of CTL\nmodel checking, and this is in fact what NuSMV does. The combined system\nM × A¬φ is represented as the system to be model checked in NuSMV,\nand the formula to be checked is simply EG ⊤. Thus, we ask the question:\ndoes the combined system have a path. The acceptance conditions of A¬φ\nare represented as implicit fairness conditions for the CTL model-checking\nprocedure. Explicitly, this amounts to asserting ‘FAIRNESS ¬(χ U ψ) ∨ψ’\nfor each formula χ U ψ occurring in C(φ).\n3.7 The fixed-point characterisation of CTL\nOn page 227, we presented an algorithm which, given a CTL formula φ and\na model M = (S, →, L), computes the set of states s ∈S satisfying φ. We\nwrite this set as [[φ]]. The algorithm works recursively on the structure of\nφ. For formulas φ of height 1 (⊥, ⊤or p), [[φ]] is computed directly. Other\n3.7 The fixed-point characterisation of CTL\n239\nformulas are composed of smaller subformulas combined by a connective of\nCTL. For example, if φ is ψ1 ∨ψ2, then the algorithm computes the sets\n[[ψ1]] and [[ψ2]] and combines them in a certain way (in this case, by taking\nthe union) in order to obtain [[ψ1 ∨ψ2]].\nThe more interesting cases arise when we deal with a formula such as\nEX ψ, involving a temporal operator. The algorithm computes the set [[ψ]]\nand then computes the set of all states which have a transition to a state in\n[[ψ]]. This is in accord with the semantics of EX ψ: M, s ⊨EX ψ iﬀthere is\na state s′ with s →s′ and M, s′ ⊨ψ.\nFor most of these logical operators, we may easily continue this discussion\nto see that the algorithms work just as expected. However, the cases EU,\nAF and EG (where we needed to iterate a certain labelling policy until it\nstabilised) are not so obvious to reason about. The topic of this section is to\ndevelop the semantic insights into these operators that allow us to provide a\ncomplete proof for their termination and correctness. Inspecting the pseudo-\nthat φ is inﬁnitely often true, we check G F φ →ψ. This means: all paths\nsatisfying inﬁnitely often φ also satisfy ψ. It is not possible to express this\nin CTL. In particular, any way of adding As or Es to G F φ →ψ will result\nin a formula with a diﬀerent meaning from the intended one. For example,\nAG AF φ →ψ means that if all paths are fair then ψ holds, rather than what\nwas intended: ψ holds along all paths which are fair.\n3.6.3 The LTL model-checking algorithm\nThe algorithm presented in the sections above for CTL model checking\nis quite intuitive: given a system and a CTL formula, it labels states of\nthe system with the subformulas of the formula which are satisﬁed there.\nThe state-labelling approach is appropriate because subformulas of the for-\nmula may be evaluated in states of the system. This is not the case for\nLTL: subformulas of the formula must be evaluated not in states but along\npaths of the system. Therefore, LTL model checking has to adopt a diﬀerent\nstrategy.\nThere are several algorithms for LTL model checking described in the\nliterature. Although they diﬀer in detail, nearly all of them adopt the same\n3.6 Model-checking algorithms\n233\nbasic strategy. We explain that strategy ﬁrst; then, we describe some algo-\nrithms in more detail.\nThe basic strategy\nLet M = (S, →, L) be a model, s ∈S, and φ an LTL\nformula. We determine whether M, s ⊨φ, i.e., whether φ is satisﬁed along\nall paths of M starting at s. Almost all LTL model checking algorithms\nproceed along the following three steps.\n1.\nConstruct an automaton, also known as a tableau, for the formula ¬φ. The\nautomaton for ψ is called Aψ. Thus, we construct A¬φ. The automaton has a\nnotion of accepting a trace. A trace is a sequence of valuations of the proposi-\ntional atoms. From a path, we can abstract its trace. The construction has the\nproperty that for all paths π: π ⊨ψ iﬀthe trace of π is accepted by Aψ. In other\nwords, the automaton Aψ encodes precisely the traces which satisfy ψ.\nsystem description language as CMU SMV, but it has an improved user in-\nterface and a greater variety of algorithms. For example, whereas CMU SMV\nchecks only CTL speciﬁcation, NuSMV supports LTL and CTL. NuSMV im-\nplements bounded model checking [BCCZ99]. Cadence SMV8 is an entirely\nnew model checker focused on compositional systems and abstraction as\nways of addressing the state explosion problem. It was also developed by\nK. McMillan and its description language resembles but much extends the\noriginal SMV.\nA website which gathers frequently used speciﬁcation patterns in various\nframeworks (such as CTL, LTL and regular expressions) is maintained by\nM. Dwyer, G. Avrunin, J. Corbett and L. Dillon9.\nCurrent research in model checking includes attempts to exploit abstrac-\ntions, symmetries and compositionality [CGL94, Lon83, Dam96] in order to\nreduce the impact of the state explosion problem.\nThe model checker Spin, which is geared towards asynchronous systems\nand is based on the temporal logic LTL, can be found at the Spin website10. A\nmodel checker called FDR2 based on the process algebra CSP is available11.\n6 www.cs.cmu.edu/~modelcheck/\n7 nusmv.irst.itc.it\n8 www-cad.eecs.berkeley.edu/~kenmcmil/\n9 patterns.projects.cis.ksu.edu/\n10 netlib.bell-labs.com/netlib/spin/whatispin.html\n11 www.fsel.com.fdr2 download.html\n3.9 Bibliographic notes\n255\nThe Edinburgh Concurrency Workbench12 and the Concurrency Workbench\nof North Carolina13 are similar software tools for the design and analysis of\nconcurrent systems. An example of a customisable and extensible modular\nmodel checking frameworks for the veriﬁcation of concurrent software is\nBogor14.\nThere are many textbooks about veriﬁcation of reactive systems; we men-\ntion [MP91, MP95, Ros97, Hol90]. The SMV code contained in this chapter\ncan be downloaded from www.cs.bham.ac.uk/research/lics/.\n12 www.dcs.ed.ac.uk/home/cwb\n13 www.cs.sunysb.edu/~cwb\n14 http://bogor.projects.cis.ksu.edu/\n4\nProgram verification",
                            "children": []
                        }
                    ]
                }
            ]
        }
    ]
}